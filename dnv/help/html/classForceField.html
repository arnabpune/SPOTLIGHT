<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Denovo omega: ForceField Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Denovo omega<span id="projectnumber">&#160;0.0</span>
   </div>
   <div id="projectbrief">A de-novo optimum-binder molecule-design program.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classForceField-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ForceField Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="forcefield_8hpp_source.html">forcefield/forcefield.hpp</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for ForceField:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classForceField.png" usemap="#ForceField_map" alt=""/>
  <map id="ForceField_map" name="ForceField_map">
<area href="classIncompleteForceField.html" alt="IncompleteForceField" shape="rect" coords="0,56,188,80"/>
<area href="classIncompleteForceField.html" alt="IncompleteForceField" shape="rect" coords="198,56,386,80"/>
<area href="classIncompleteForceField.html" alt="IncompleteForceField" shape="rect" coords="396,56,584,80"/>
<area href="classIncompleteForceField.html" alt="IncompleteForceField" shape="rect" coords="594,56,782,80"/>
<area href="classspecific_1_1ExtendableForceField.html" alt="specific::ExtendableForceField" shape="rect" coords="792,56,980,80"/>
<area href="classspecific_1_1ConstrictedForceField.html" alt="specific::ConstrictedForceField" shape="rect" coords="792,112,980,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8273c2e8667bc21edb7599c1210dda4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">ForceField</a> ()</td></tr>
<tr class="memdesc:a8273c2e8667bc21edb7599c1210dda4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters)  <a href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">More...</a><br /></td></tr>
<tr class="separator:a8273c2e8667bc21edb7599c1210dda4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50040e928edbb4d694f4f2f894debba7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a50040e928edbb4d694f4f2f894debba7">ForceField</a> (const std::string &amp;ff_file)</td></tr>
<tr class="memdesc:a50040e928edbb4d694f4f2f894debba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format (see PDF documentation for format details)  <a href="classForceField.html#a50040e928edbb4d694f4f2f894debba7">More...</a><br /></td></tr>
<tr class="separator:a50040e928edbb4d694f4f2f894debba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea81a4f90173d98b5d683f3508f936"><td class="memItemLeft" align="right" valign="top"><a id="aafea81a4f90173d98b5d683f3508f936" name="aafea81a4f90173d98b5d683f3508f936"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceField</b> (const std::string &amp;ff_file, const std::string &amp;catf)</td></tr>
<tr class="memdesc:aafea81a4f90173d98b5d683f3508f936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format, and categories from a categories file. (see PDF documentation for format details) <br /></td></tr>
<tr class="separator:aafea81a4f90173d98b5d683f3508f936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d792d4afbcfdd034e4c10bdd3ba523e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a6d792d4afbcfdd034e4c10bdd3ba523e">loadResidues</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a6d792d4afbcfdd034e4c10bdd3ba523e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load residues from an RTP file.  <a href="classForceField.html#a6d792d4afbcfdd034e4c10bdd3ba523e">More...</a><br /></td></tr>
<tr class="separator:a6d792d4afbcfdd034e4c10bdd3ba523e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memItemLeft" align="right" valign="top"><a id="a04cb5ddf90e2e0870e7fe5604b316c51" name="a04cb5ddf90e2e0870e7fe5604b316c51"></a>
const std::vector&lt; <a class="el" href="classResidue.html">Residue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidues</b> () const</td></tr>
<tr class="memdesc:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list with all the residues loaded into this Forcefield. <br /></td></tr>
<tr class="separator:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720bf8a957e4d00740c2d353b8be1181"><td class="memItemLeft" align="right" valign="top"><a id="a720bf8a957e4d00740c2d353b8be1181" name="a720bf8a957e4d00740c2d353b8be1181"></a>
const <a class="el" href="classResidue.html">Residue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidue</b> (const std::string &amp;rname) const</td></tr>
<tr class="memdesc:a720bf8a957e4d00740c2d353b8be1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classResidue.html">Residue</a> from those loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. <br /></td></tr>
<tr class="separator:a720bf8a957e4d00740c2d353b8be1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9902cf610a724e451d0f5d2a87934fa3"><td class="memItemLeft" align="right" valign="top"><a id="a9902cf610a724e451d0f5d2a87934fa3" name="a9902cf610a724e451d0f5d2a87934fa3"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategories</b> () const</td></tr>
<tr class="memdesc:a9902cf610a724e451d0f5d2a87934fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all Categories loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a9902cf610a724e451d0f5d2a87934fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c830622f775f42f2b8e38afb2f4c3"><td class="memItemLeft" align="right" valign="top"><a id="a942c830622f775f42f2b8e38afb2f4c3" name="a942c830622f775f42f2b8e38afb2f4c3"></a>
const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypes</b> () const</td></tr>
<tr class="memdesc:a942c830622f775f42f2b8e38afb2f4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the atom-types (as <a class="el" href="classAtom.html">Atom</a> object pointers) loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a942c830622f775f42f2b8e38afb2f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71608edab6564b721aa4b77739a82fc4"><td class="memItemLeft" align="right" valign="top"><a id="a71608edab6564b721aa4b77739a82fc4" name="a71608edab6564b721aa4b77739a82fc4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (<a class="el" href="classAtom.html">Atom</a> *a)</td></tr>
<tr class="memdesc:a71608edab6564b721aa4b77739a82fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a71608edab6564b721aa4b77739a82fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afad3eec7b365936072675c74e4d185"><td class="memItemLeft" align="right" valign="top"><a id="a8afad3eec7b365936072675c74e4d185" name="a8afad3eec7b365936072675c74e4d185"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8afad3eec7b365936072675c74e4d185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a8afad3eec7b365936072675c74e4d185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0393adb6d13dfa912934c4fce143a94"><td class="memItemLeft" align="right" valign="top"><a id="ae0393adb6d13dfa912934c4fce143a94" name="ae0393adb6d13dfa912934c4fce143a94"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getElectronegativity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae0393adb6d13dfa912934c4fce143a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get electronegativity data for a given element - experimental. If the data is not available, the user is prompted to enter it after which is is stored for that run. <br /></td></tr>
<tr class="separator:ae0393adb6d13dfa912934c4fce143a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad172233c0a72e65847a7c91145bb9ab9"><td class="memItemLeft" align="right" valign="top"><a id="ad172233c0a72e65847a7c91145bb9ab9" name="ad172233c0a72e65847a7c91145bb9ab9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadAdditionalAtomTypes</b> (const std::string &amp;ff_file)</td></tr>
<tr class="memdesc:ad172233c0a72e65847a7c91145bb9ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load additional atom-types - Useful when trying to add extra atom-types for specific usage (i.e. part of a molecule fragment). <br /></td></tr>
<tr class="separator:ad172233c0a72e65847a7c91145bb9ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa84f8e5f7d4737c25281ccf8e649911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#afa84f8e5f7d4737c25281ccf8e649911">loadCategories</a> (const std::string &amp;catf, bool emptyCat=true)</td></tr>
<tr class="memdesc:afa84f8e5f7d4737c25281ccf8e649911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load categories from an external file into this forcefield.  <a href="classForceField.html#afa84f8e5f7d4737c25281ccf8e649911">More...</a><br /></td></tr>
<tr class="separator:afa84f8e5f7d4737c25281ccf8e649911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741f547e37b13db02b1316d92b45c164"><td class="memItemLeft" align="right" valign="top"><a id="a741f547e37b13db02b1316d92b45c164" name="a741f547e37b13db02b1316d92b45c164"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadChargeGroups</b> (const std::string &amp;chgfile)</td></tr>
<tr class="memdesc:a741f547e37b13db02b1316d92b45c164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load formal charges from a data file. <br /></td></tr>
<tr class="separator:a741f547e37b13db02b1316d92b45c164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa1178ea7994c0b3429051feaaf9c7"><td class="memItemLeft" align="right" valign="top"><a id="a50aa1178ea7994c0b3429051feaaf9c7" name="a50aa1178ea7994c0b3429051feaaf9c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadSolvationWeights</b> (const std::string &amp;solvfile)</td></tr>
<tr class="memdesc:a50aa1178ea7994c0b3429051feaaf9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load solvation energy prediction weights from a file. <br /></td></tr>
<tr class="separator:a50aa1178ea7994c0b3429051feaaf9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd86ba2d60c42c52569c340ce812a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a4fd86ba2d60c42c52569c340ce812a72">loadRules</a> (const std::string &amp;fl, bool emptyRules=true)</td></tr>
<tr class="memdesc:a4fd86ba2d60c42c52569c340ce812a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load rules from a given file.  <a href="classForceField.html#a4fd86ba2d60c42c52569c340ce812a72">More...</a><br /></td></tr>
<tr class="separator:a4fd86ba2d60c42c52569c340ce812a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">getRules</a> () const</td></tr>
<tr class="memdesc:ac4e6c7a3139b39b1f286a00f53526f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all the rules loaded into this forcefield.  <a href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">More...</a><br /></td></tr>
<tr class="separator:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3af3130879593384a4faedf21d7fca"><td class="memItemLeft" align="right" valign="top"><a id="a4e3af3130879593384a4faedf21d7fca" name="a4e3af3130879593384a4faedf21d7fca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasRule</b> (const std::string &amp;tp) const</td></tr>
<tr class="memdesc:a4e3af3130879593384a4faedf21d7fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are any rules defined on a given atom-type. <br /></td></tr>
<tr class="separator:a4e3af3130879593384a4faedf21d7fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bfc00e94bac57310cc3a4778e11342"><td class="memItemLeft" align="right" valign="top"><a id="ab5bfc00e94bac57310cc3a4778e11342" name="ab5bfc00e94bac57310cc3a4778e11342"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ab5bfc00e94bac57310cc3a4778e11342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given <a class="el" href="classCategory.html">Category</a> is present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:ab5bfc00e94bac57310cc3a4778e11342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memItemLeft" align="right" valign="top"><a id="a5a30c5a7760b5c791c5b34f9bd133506" name="a5a30c5a7760b5c791c5b34f9bd133506"></a>
const <a class="el" href="classCategory.html">Category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a5a30c5a7760b5c791c5b34f9bd133506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the chosen <a class="el" href="classCategory.html">Category</a> by name if present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. If there is no <a class="el" href="classCategory.html">Category</a> with this name, <a class="el" href="classNoSuchCategoryException.html">NoSuchCategoryException</a> is thrown. <br /></td></tr>
<tr class="separator:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memItemLeft" align="right" valign="top"><a id="a365a885eb6f7bc1b154ac2e3c1a0e71e" name="a365a885eb6f7bc1b154ac2e3c1a0e71e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd) const</td></tr>
<tr class="memdesc:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined (See Rule::satisfies(Atom*,Molecule*,const ForceField*)) <br /></td></tr>
<tr class="separator:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7652c528231e7e76f85b4c0d54ccf249"><td class="memItemLeft" align="right" valign="top"><a id="a7652c528231e7e76f85b4c0d54ccf249" name="a7652c528231e7e76f85b4c0d54ccf249"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *n, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd) const</td></tr>
<tr class="memdesc:a7652c528231e7e76f85b4c0d54ccf249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined given that an extra bond is formed to the new atom 'n' supplied (See Rule::satisfies(Atom*,Atom*,Molecule*)) <br /></td></tr>
<tr class="separator:a7652c528231e7e76f85b4c0d54ccf249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e3f80e59286f915299e61341d078f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a388e3f80e59286f915299e61341d078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name.  <a href="classForceField.html#a388e3f80e59286f915299e61341d078f">More...</a><br /></td></tr>
<tr class="separator:a388e3f80e59286f915299e61341d078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memItemLeft" align="right" valign="top"><a id="aaa160c8cf0174cb4117d9eb1bc8ace54" name="aaa160c8cf0174cb4117d9eb1bc8ace54"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAtom(const std::string&amp;) but uses an <a class="el" href="classAtom.html">Atom</a> object pointer instead of a string to get the atom-type name. <br /></td></tr>
<tr class="separator:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memItemLeft" align="right" valign="top"><a id="a2be69fc1bd6346deab02dea6f67d7a45" name="a2be69fc1bd6346deab02dea6f67d7a45"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> () const</td></tr>
<tr class="memdesc:a2be69fc1bd6346deab02dea6f67d7a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded atom-types. <br /></td></tr>
<tr class="separator:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memItemLeft" align="right" valign="top"><a id="a8328f9fbf5155ffaebfc14543d59d82c" name="a8328f9fbf5155ffaebfc14543d59d82c"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> () const</td></tr>
<tr class="memdesc:a8328f9fbf5155ffaebfc14543d59d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded <b>non-hydrogen</b> atom-types. <br /></td></tr>
<tr class="separator:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01147c118b08eee9b7c2d138275c19"><td class="memItemLeft" align="right" valign="top"><a id="a8d01147c118b08eee9b7c2d138275c19" name="a8d01147c118b08eee9b7c2d138275c19"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a8d01147c118b08eee9b7c2d138275c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a2be69fc1bd6346deab02dea6f67d7a45" title="Randomly get a copy of any of the loaded atom-types.">getRandomAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a8d01147c118b08eee9b7c2d138275c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f60e9f58a6f6694e27398d50afa39d"><td class="memItemLeft" align="right" valign="top"><a id="a67f60e9f58a6f6694e27398d50afa39d" name="a67f60e9f58a6f6694e27398d50afa39d"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a67f60e9f58a6f6694e27398d50afa39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a8328f9fbf5155ffaebfc14543d59d82c" title="Randomly get a copy of any of the loaded non-hydrogen atom-types.">getRandomNonHAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a67f60e9f58a6f6694e27398d50afa39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memItemLeft" align="right" valign="top"><a id="ab799403bbacf06c7aa5215d8a4c9ccf9" name="ab799403bbacf06c7aa5215d8a4c9ccf9"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (const std::string &amp;s, double x, double y, double z) const</td></tr>
<tr class="memdesc:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an atom of a specific atom-type at a specified position. <br /></td></tr>
<tr class="separator:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memItemLeft" align="right" valign="top"><a id="a3c095b464ce6ba8f0eea33fb0c7ffa6b" name="a3c095b464ce6ba8f0eea33fb0c7ffa6b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getElementName</b> (const std::string &amp;el) const</td></tr>
<tr class="memdesc:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element name (symbol) corresponding to a given atom-type. <br /></td></tr>
<tr class="separator:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1831e6acc1949a3abd0a762235f145"><td class="memItemLeft" align="right" valign="top"><a id="abe1831e6acc1949a3abd0a762235f145" name="abe1831e6acc1949a3abd0a762235f145"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypesByElement</b> (const std::string &amp;el)</td></tr>
<tr class="memdesc:abe1831e6acc1949a3abd0a762235f145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all atom-types corresponding to a given element. <br /></td></tr>
<tr class="separator:abe1831e6acc1949a3abd0a762235f145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0676e821612c47f3675c790cac28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a95d0676e821612c47f3675c790cac28a">selectRandomBondableAtom</a> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *bias=nullptr) const</td></tr>
<tr class="memdesc:a95d0676e821612c47f3675c790cac28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random atom that can bond to this atom but bias the output.  <a href="classForceField.html#a95d0676e821612c47f3675c790cac28a">More...</a><br /></td></tr>
<tr class="separator:a95d0676e821612c47f3675c790cac28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab183018c1dce0c5c93e1dd36eccd57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#aab183018c1dce0c5c93e1dd36eccd57e">selectRandomBondableAtomTerminal</a> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *bias=nullptr) const</td></tr>
<tr class="memdesc:aab183018c1dce0c5c93e1dd36eccd57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random terminal atom that can bond to this atom but bias the output.  <a href="classForceField.html#aab183018c1dce0c5c93e1dd36eccd57e">More...</a><br /></td></tr>
<tr class="separator:aab183018c1dce0c5c93e1dd36eccd57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916b6f2de77e5c712e9e3404d7862a1a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">listAtomsByRule</a> (<a class="el" href="classAtom.html">Atom</a> *s, <a class="el" href="classMolecule.html">Molecule</a> *m, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a916b6f2de77e5c712e9e3404d7862a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Situationally list atoms that can bond to the selected atom.  <a href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">More...</a><br /></td></tr>
<tr class="separator:a916b6f2de77e5c712e9e3404d7862a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce8512467099140749410ca10298b0"><td class="memItemLeft" align="right" valign="top"><a id="aacce8512467099140749410ca10298b0" name="aacce8512467099140749410ca10298b0"></a>
std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>listAtomsByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:aacce8512467099140749410ca10298b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as listAtomsByRule(Atom*,Molecule*,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:aacce8512467099140749410ca10298b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1374c20d8953dac1cd300417aba041c5"><td class="memItemLeft" align="right" valign="top"><a id="a1374c20d8953dac1cd300417aba041c5" name="a1374c20d8953dac1cd300417aba041c5"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectAtomByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a1374c20d8953dac1cd300417aba041c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as selectAtomByRule(Atom*,Molecule*,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:a1374c20d8953dac1cd300417aba041c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629cd1dff57f199e0e836e00792101b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">listFragmentsByRule</a> (<a class="el" href="classAtom.html">Atom</a> *src, <a class="el" href="classMolecule.html">Molecule</a> *m, const FragmentSet &amp;frags, <a class="el" href="classAtom.html">Atom</a> *exa=nullptr, int devid=0) const</td></tr>
<tr class="memdesc:a629cd1dff57f199e0e836e00792101b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all possible a <b>fragments</b> that can bond to a given atom (following bonding rules).  <a href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">More...</a><br /></td></tr>
<tr class="separator:a629cd1dff57f199e0e836e00792101b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd448a8dfcb86280c02164fa14bc81"><td class="memItemLeft" align="right" valign="top"><a id="acfbd448a8dfcb86280c02164fa14bc81" name="acfbd448a8dfcb86280c02164fa14bc81"></a>
std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>listFragmentsByRule</b> (<a class="el" href="classAtom.html">Atom</a> *src, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, const FragmentSet &amp;frags, <a class="el" href="classAtom.html">Atom</a> *exa=nullptr, int devid=0) const</td></tr>
<tr class="memdesc:acfbd448a8dfcb86280c02164fa14bc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as listFragmentsByRule(Atom*,Molecule*,const FragmentSet&amp;,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:acfbd448a8dfcb86280c02164fa14bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b2cef43160cbdaf59142befd06f8cc"><td class="memItemLeft" align="right" valign="top"><a id="a31b2cef43160cbdaf59142befd06f8cc" name="a31b2cef43160cbdaf59142befd06f8cc"></a>
std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>selectFragmentByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, const FragmentSet &amp;fs, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a31b2cef43160cbdaf59142befd06f8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as selectFragmentByRule(Atom*,Molecule*,const FragmentSet&amp;,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:a31b2cef43160cbdaf59142befd06f8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">acceptNewBond</a> (<a class="el" href="classAtom.html">Atom</a> *src, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd, <a class="el" href="classAtom.html">Atom</a> *n) const</td></tr>
<tr class="memdesc:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions.  <a href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">More...</a><br /></td></tr>
<tr class="separator:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memItemLeft" align="right" valign="top"><a id="afb97cc6d011ec0f5d5b78a3f2bd0a94d" name="afb97cc6d011ec0f5d5b78a3f2bd0a94d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See contains(std::string) <br /></td></tr>
<tr class="separator:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memItemLeft" align="right" valign="top"><a id="a0c0ab714e289a47ea4a30cf6701ce6cd" name="a0c0ab714e289a47ea4a30cf6701ce6cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (std::string str) const</td></tr>
<tr class="memdesc:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checkes if this <a class="el" href="classForceField.html">ForceField</a> has an atom-type with the given name. <br /></td></tr>
<tr class="separator:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memItemLeft" align="right" valign="top"><a id="a40426986b9cd4c8fbabcb3cd0fb2ecb7" name="a40426986b9cd4c8fbabcb3cd0fb2ecb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> ()</td></tr>
<tr class="memdesc:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write valency, σ, and ε of all the atom-types to stdout. <br /></td></tr>
<tr class="separator:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:a11ef1ec5670fc1755a3ad4618d63d734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make.  <a href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">More...</a><br /></td></tr>
<tr class="separator:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ddc7dd89f688b86adba44834fc45a4"><td class="memItemLeft" align="right" valign="top"><a id="a32ddc7dd89f688b86adba44834fc45a4" name="a32ddc7dd89f688b86adba44834fc45a4"></a>
const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAllowedBonds</b> (const std::string &amp;temp) const</td></tr>
<tr class="memdesc:a32ddc7dd89f688b86adba44834fc45a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAllowedBonds(Atom*), but provides the atom-type by name (as std::string) <br /></td></tr>
<tr class="separator:a32ddc7dd89f688b86adba44834fc45a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fd23cd72bc2fb9037b744befae5180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a00fd23cd72bc2fb9037b744befae5180">loadLengths</a> (const std::string &amp;s, bool erase=true)</td></tr>
<tr class="memdesc:a00fd23cd72bc2fb9037b744befae5180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-length data from a given file.  <a href="classForceField.html#a00fd23cd72bc2fb9037b744befae5180">More...</a><br /></td></tr>
<tr class="separator:a00fd23cd72bc2fb9037b744befae5180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e91de8d02133714b409ad4374346314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a4e91de8d02133714b409ad4374346314">loadAngles</a> (const std::string &amp;s, bool erase=true)</td></tr>
<tr class="memdesc:a4e91de8d02133714b409ad4374346314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-angle data from a given file.  <a href="classForceField.html#a4e91de8d02133714b409ad4374346314">More...</a><br /></td></tr>
<tr class="separator:a4e91de8d02133714b409ad4374346314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2247bad6012ae2d0897abb532a072d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a2247bad6012ae2d0897abb532a072d47">loadDihedrals</a> (const std::string &amp;s, bool erase=true)</td></tr>
<tr class="memdesc:a2247bad6012ae2d0897abb532a072d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load dihedral data from a given file.  <a href="classForceField.html#a2247bad6012ae2d0897abb532a072d47">More...</a><br /></td></tr>
<tr class="separator:a2247bad6012ae2d0897abb532a072d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4871a728498d1cd28e5cfc2130b99a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a4871a728498d1cd28e5cfc2130b99a53">loadImpropers</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a4871a728498d1cd28e5cfc2130b99a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load improper dihedral data from a given file (not used in later versions of DeNovo)  <a href="classForceField.html#a4871a728498d1cd28e5cfc2130b99a53">More...</a><br /></td></tr>
<tr class="separator:a4871a728498d1cd28e5cfc2130b99a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7dd2e1378e1ef7532a5e8184fdb936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#aab7dd2e1378e1ef7532a5e8184fdb936">loadBondParameters</a> (std::string lengthfn=LengthDataFile, std::string anglefn=AngleDataFile, std::string dihedralfn=DihedralDataFile, std::string improperfn=ImproperDataFile, bool erase=true)</td></tr>
<tr class="memdesc:aab7dd2e1378e1ef7532a5e8184fdb936"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to load all parameters (bond-length,bond-angle,dihedral,and improper-dihedral). See documentation (PDF) for default filenames.  <a href="classForceField.html#aab7dd2e1378e1ef7532a5e8184fdb936">More...</a><br /></td></tr>
<tr class="separator:aab7dd2e1378e1ef7532a5e8184fdb936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memItemLeft" align="right" valign="top"><a id="a19cb372462ff31cda4096ae2d20ee1d4" name="a19cb372462ff31cda4096ae2d20ee1d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOneFourParameters</b> (const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a19cb372462ff31cda4096ae2d20ee1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load one-four interaction parameters from a given file. Later versions of DeNovo directly use the parameters from the atom-type data. <br /></td></tr>
<tr class="separator:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa1bfbe7d28409e5770952907a2de9"><td class="memItemLeft" align="right" valign="top"><a id="a02aa1bfbe7d28409e5770952907a2de9" name="a02aa1bfbe7d28409e5770952907a2de9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOtherInteractions</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a02aa1bfbe7d28409e5770952907a2de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load L-J parameters from a given file. Later versions of DeNovo use the <a class="el" href="classAtom.html">Atom</a> object for parameters directly. <br /></td></tr>
<tr class="separator:a02aa1bfbe7d28409e5770952907a2de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memItemLeft" align="right" valign="top"><a id="afcc0a1b1e130d9a590a8dcffa597859f" name="afcc0a1b1e130d9a590a8dcffa597859f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadNonbondedInteractions</b> (const std::string &amp;onefourfile=OneFourFile, const std::string &amp;otherfile=OtherInterFile)</td></tr>
<tr class="memdesc:afcc0a1b1e130d9a590a8dcffa597859f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 1-4 non-bonding potential parameters, as well as L-J potential parameters. <br /></td></tr>
<tr class="separator:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19cd0db1e679daf537e06ef3308f721"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">getBondLength</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool silent=false) const</td></tr>
<tr class="memdesc:ab19cd0db1e679daf537e06ef3308f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond length for the bond between two atom types.  <a href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">More...</a><br /></td></tr>
<tr class="separator:ab19cd0db1e679daf537e06ef3308f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b8d029b748fb56265d4ee5cce2873"><td class="memItemLeft" align="right" valign="top"><a id="a084b8d029b748fb56265d4ee5cce2873" name="a084b8d029b748fb56265d4ee5cce2873"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::string &amp;a1, const string &amp;a2, bool silent=false) const</td></tr>
<tr class="memdesc:a084b8d029b748fb56265d4ee5cce2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a084b8d029b748fb56265d4ee5cce2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af019ff49e9086043b31c27fa9fae11ae"><td class="memItemLeft" align="right" valign="top"><a id="af019ff49e9086043b31c27fa9fae11ae" name="af019ff49e9086043b31c27fa9fae11ae"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::vector&lt; std::string &gt; &amp;sv, bool silent=false) const</td></tr>
<tr class="memdesc:af019ff49e9086043b31c27fa9fae11ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string lists instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af019ff49e9086043b31c27fa9fae11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memItemLeft" align="right" valign="top"><a id="ad1b08a30e9e807ef4e7f52cd8cfc836e" name="ad1b08a30e9e807ef4e7f52cd8cfc836e"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::pair&lt; std::string, std::string &gt; &amp;atp, bool silent=false) const</td></tr>
<tr class="memdesc:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string pairs instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b06865581950f90f100bd04b139cf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a008b06865581950f90f100bd04b139cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types. -failsafe method.  <a href="classForceField.html#a008b06865581950f90f100bd04b139cf">More...</a><br /></td></tr>
<tr class="separator:a008b06865581950f90f100bd04b139cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memItemLeft" align="right" valign="top"><a id="aa3f2ba9fedbcb940d81f5854dfb75d21" name="aa3f2ba9fedbcb940d81f5854dfb75d21"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3) const</td></tr>
<tr class="memdesc:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memItemLeft" align="right" valign="top"><a id="a66f6acff5098b0c0165a3d4a70fa8d8a" name="a66f6acff5098b0c0165a3d4a70fa8d8a"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using a string list instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac293e6cde680b1ef64c9d337796be0a6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3) const</td></tr>
<tr class="memdesc:ac293e6cde680b1ef64c9d337796be0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types.  <a href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">More...</a><br /></td></tr>
<tr class="separator:ac293e6cde680b1ef64c9d337796be0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a54f2de7bdc1dc0b1be4060c3a8fde540">getAngleParamters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e27b4bf5bea870617379cdb657cefd7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4) const</td></tr>
<tr class="memdesc:a2e27b4bf5bea870617379cdb657cefd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method.  <a href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">More...</a><br /></td></tr>
<tr class="separator:a2e27b4bf5bea870617379cdb657cefd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4e9cfa168d0f0b906fc49782929d15"><td class="memItemLeft" align="right" valign="top"><a id="afd4e9cfa168d0f0b906fc49782929d15" name="afd4e9cfa168d0f0b906fc49782929d15"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralParametersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4) const</td></tr>
<tr class="memdesc:afd4e9cfa168d0f0b906fc49782929d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getDihedralParametersFailsafe(Atom*,Atom*,Atom*,Atom*) using a strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:afd4e9cfa168d0f0b906fc49782929d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle data for a set of four atom-types (in order of the connection chain)  <a href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">More...</a><br /></td></tr>
<tr class="separator:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a3bc80bfd10caa37d151f412d2cbe052b">getDihedralParameters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memItemLeft" align="right" valign="top"><a id="a546fe4a3aef3fa3928f918dd9ec490e9" name="a546fe4a3aef3fa3928f918dd9ec490e9"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly matches the atom-type names to the improper dihedral data and retrieves the angle. If not available <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. <br /></td></tr>
<tr class="separator:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memItemLeft" align="right" valign="top"><a id="a9c18ff07f6ff1e200f8aa706ab15cebb" name="a9c18ff07f6ff1e200f8aa706ab15cebb"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getImproperParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list. <br /></td></tr>
<tr class="separator:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memItemLeft" align="right" valign="top"><a id="a94ea10328f7d6e197a5d2b9e60d488f1" name="a94ea10328f7d6e197a5d2b9e60d488f1"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getOtherParameters</b> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the σ and ε values for a given atom-type. <br /></td></tr>
<tr class="separator:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c885b9892eb5c5f020f445bcb5853f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:a34c885b9892eb5c5f020f445bcb5853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the angle-strain potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">More...</a><br /></td></tr>
<tr class="separator:a34c885b9892eb5c5f020f445bcb5853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa188e56b9a3fb2b90fabe21f66882278"><td class="memItemLeft" align="right" valign="top"><a id="aa188e56b9a3fb2b90fabe21f66882278" name="aa188e56b9a3fb2b90fabe21f66882278"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateAngleEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, double th, double ub, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:aa188e56b9a3fb2b90fabe21f66882278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateAngleEnergy(Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa188e56b9a3fb2b90fabe21f66882278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dihedral potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">More...</a><br /></td></tr>
<tr class="separator:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e74dd7f3607c017f12a7410e35a4f"><td class="memItemLeft" align="right" valign="top"><a id="a169e74dd7f3607c017f12a7410e35a4f" name="a169e74dd7f3607c017f12a7410e35a4f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateDihedralEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, double ph, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a169e74dd7f3607c017f12a7410e35a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateDihedralEnergy(Atom*,Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a169e74dd7f3607c017f12a7410e35a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6feb2e505f33c5a7e51075b382f36642"><td class="memItemLeft" align="right" valign="top"><a id="a6feb2e505f33c5a7e51075b382f36642" name="a6feb2e505f33c5a7e51075b382f36642"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a6feb2e505f33c5a7e51075b382f36642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inproper dihedral energy. Not used in latest versions of DeNovo. Refer to links provided in documentation PDF. Throws <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> if data is not available. <br /></td></tr>
<tr class="separator:a6feb2e505f33c5a7e51075b382f36642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3c6c3f537052118bd081e739bfcc3"><td class="memItemLeft" align="right" valign="top"><a id="af0a3c6c3f537052118bd081e739bfcc3" name="af0a3c6c3f537052118bd081e739bfcc3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, const double &amp;q) const</td></tr>
<tr class="memdesc:af0a3c6c3f537052118bd081e739bfcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateImproperEnergy(Atom*,Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af0a3c6c3f537052118bd081e739bfcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8273c2e8667bc21edb7599c1210dda4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">ForceField</a> ()</td></tr>
<tr class="memdesc:a8273c2e8667bc21edb7599c1210dda4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters)  <a href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">More...</a><br /></td></tr>
<tr class="separator:a8273c2e8667bc21edb7599c1210dda4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50040e928edbb4d694f4f2f894debba7"><td class="memItemLeft" align="right" valign="top"><a id="a50040e928edbb4d694f4f2f894debba7" name="a50040e928edbb4d694f4f2f894debba7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceField</b> (const std::string &amp;ff_file)</td></tr>
<tr class="memdesc:a50040e928edbb4d694f4f2f894debba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format (see PDF documentation for format details) <br /></td></tr>
<tr class="separator:a50040e928edbb4d694f4f2f894debba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea81a4f90173d98b5d683f3508f936"><td class="memItemLeft" align="right" valign="top"><a id="aafea81a4f90173d98b5d683f3508f936" name="aafea81a4f90173d98b5d683f3508f936"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceField</b> (const std::string &amp;ff_file, const std::string &amp;catf)</td></tr>
<tr class="memdesc:aafea81a4f90173d98b5d683f3508f936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format, and categories from a categories file. (see PDF documentation for format details) <br /></td></tr>
<tr class="separator:aafea81a4f90173d98b5d683f3508f936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memItemLeft" align="right" valign="top"><a id="a04cb5ddf90e2e0870e7fe5604b316c51" name="a04cb5ddf90e2e0870e7fe5604b316c51"></a>
const std::vector&lt; <a class="el" href="classResidue.html">Residue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidues</b> () const</td></tr>
<tr class="memdesc:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list with all the residues loaded into this Forcefield. <br /></td></tr>
<tr class="separator:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720bf8a957e4d00740c2d353b8be1181"><td class="memItemLeft" align="right" valign="top"><a id="a720bf8a957e4d00740c2d353b8be1181" name="a720bf8a957e4d00740c2d353b8be1181"></a>
const <a class="el" href="classResidue.html">Residue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidue</b> (const std::string &amp;rname) const</td></tr>
<tr class="memdesc:a720bf8a957e4d00740c2d353b8be1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classResidue.html">Residue</a> from those loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. <br /></td></tr>
<tr class="separator:a720bf8a957e4d00740c2d353b8be1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9902cf610a724e451d0f5d2a87934fa3"><td class="memItemLeft" align="right" valign="top"><a id="a9902cf610a724e451d0f5d2a87934fa3" name="a9902cf610a724e451d0f5d2a87934fa3"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategories</b> () const</td></tr>
<tr class="memdesc:a9902cf610a724e451d0f5d2a87934fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all Categories loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a9902cf610a724e451d0f5d2a87934fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c830622f775f42f2b8e38afb2f4c3"><td class="memItemLeft" align="right" valign="top"><a id="a942c830622f775f42f2b8e38afb2f4c3" name="a942c830622f775f42f2b8e38afb2f4c3"></a>
const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypes</b> () const</td></tr>
<tr class="memdesc:a942c830622f775f42f2b8e38afb2f4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the atom-types (as <a class="el" href="classAtom.html">Atom</a> object pointers) loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a942c830622f775f42f2b8e38afb2f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71608edab6564b721aa4b77739a82fc4"><td class="memItemLeft" align="right" valign="top"><a id="a71608edab6564b721aa4b77739a82fc4" name="a71608edab6564b721aa4b77739a82fc4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (<a class="el" href="classAtom.html">Atom</a> *a)</td></tr>
<tr class="memdesc:a71608edab6564b721aa4b77739a82fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a71608edab6564b721aa4b77739a82fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afad3eec7b365936072675c74e4d185"><td class="memItemLeft" align="right" valign="top"><a id="a8afad3eec7b365936072675c74e4d185" name="a8afad3eec7b365936072675c74e4d185"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8afad3eec7b365936072675c74e4d185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a8afad3eec7b365936072675c74e4d185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0393adb6d13dfa912934c4fce143a94"><td class="memItemLeft" align="right" valign="top"><a id="ae0393adb6d13dfa912934c4fce143a94" name="ae0393adb6d13dfa912934c4fce143a94"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getElectronegativity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae0393adb6d13dfa912934c4fce143a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get electronegativity data for a given element - experimental. If the data is not available, the user is prompted to enter it after which is is stored for that run. <br /></td></tr>
<tr class="separator:ae0393adb6d13dfa912934c4fce143a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350fc55fa7f24176462228adeb4dd59d"><td class="memItemLeft" align="right" valign="top"><a id="a350fc55fa7f24176462228adeb4dd59d" name="a350fc55fa7f24176462228adeb4dd59d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadCategories</b> (const std::string &amp;catf)</td></tr>
<tr class="memdesc:a350fc55fa7f24176462228adeb4dd59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load categories from an external file into this forcefield. Categories can also be loaded when the <a class="el" href="classForceField.html">ForceField</a> object is created (See: <a class="el" href="classForceField.html#aafea81a4f90173d98b5d683f3508f936" title="Load the forcefield from the standard ffin format, and categories from a categories file....">ForceField(const std::string&amp;,const std::string&amp;)</a>) <br /></td></tr>
<tr class="separator:a350fc55fa7f24176462228adeb4dd59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741f547e37b13db02b1316d92b45c164"><td class="memItemLeft" align="right" valign="top"><a id="a741f547e37b13db02b1316d92b45c164" name="a741f547e37b13db02b1316d92b45c164"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadChargeGroups</b> (const std::string &amp;chgfile)</td></tr>
<tr class="memdesc:a741f547e37b13db02b1316d92b45c164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load formal charges from a data file. <br /></td></tr>
<tr class="separator:a741f547e37b13db02b1316d92b45c164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95480a4783499ac5ed4743e6c6ab871d"><td class="memItemLeft" align="right" valign="top"><a id="a95480a4783499ac5ed4743e6c6ab871d" name="a95480a4783499ac5ed4743e6c6ab871d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadRules</b> (const std::string &amp;fl)</td></tr>
<tr class="memdesc:a95480a4783499ac5ed4743e6c6ab871d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load rules from a given file. See the atom-type definition section of documentation PDF for more details on format. <br /></td></tr>
<tr class="separator:a95480a4783499ac5ed4743e6c6ab871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">getRules</a> () const</td></tr>
<tr class="memdesc:ac4e6c7a3139b39b1f286a00f53526f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all the rules loaded into this forcefield.  <a href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">More...</a><br /></td></tr>
<tr class="separator:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3af3130879593384a4faedf21d7fca"><td class="memItemLeft" align="right" valign="top"><a id="a4e3af3130879593384a4faedf21d7fca" name="a4e3af3130879593384a4faedf21d7fca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasRule</b> (const std::string &amp;tp) const</td></tr>
<tr class="memdesc:a4e3af3130879593384a4faedf21d7fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are any rules defined on a given atom-type. <br /></td></tr>
<tr class="separator:a4e3af3130879593384a4faedf21d7fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bfc00e94bac57310cc3a4778e11342"><td class="memItemLeft" align="right" valign="top"><a id="ab5bfc00e94bac57310cc3a4778e11342" name="ab5bfc00e94bac57310cc3a4778e11342"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ab5bfc00e94bac57310cc3a4778e11342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given <a class="el" href="classCategory.html">Category</a> is present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:ab5bfc00e94bac57310cc3a4778e11342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memItemLeft" align="right" valign="top"><a id="a5a30c5a7760b5c791c5b34f9bd133506" name="a5a30c5a7760b5c791c5b34f9bd133506"></a>
const <a class="el" href="classCategory.html">Category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a5a30c5a7760b5c791c5b34f9bd133506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the chosen <a class="el" href="classCategory.html">Category</a> by name if present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. If there is no <a class="el" href="classCategory.html">Category</a> with this name, <a class="el" href="classNoSuchCategoryException.html">NoSuchCategoryException</a> is thrown. <br /></td></tr>
<tr class="separator:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memItemLeft" align="right" valign="top"><a id="a365a885eb6f7bc1b154ac2e3c1a0e71e" name="a365a885eb6f7bc1b154ac2e3c1a0e71e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd) const</td></tr>
<tr class="memdesc:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined (See Rule::satisfies(Atom*,Molecule*,const ForceField*)) <br /></td></tr>
<tr class="separator:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7652c528231e7e76f85b4c0d54ccf249"><td class="memItemLeft" align="right" valign="top"><a id="a7652c528231e7e76f85b4c0d54ccf249" name="a7652c528231e7e76f85b4c0d54ccf249"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *n, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd) const</td></tr>
<tr class="memdesc:a7652c528231e7e76f85b4c0d54ccf249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined given that an extra bond is formed to the new atom 'n' supplied (See Rule::satisfies(Atom*,Atom*,Molecule*)) <br /></td></tr>
<tr class="separator:a7652c528231e7e76f85b4c0d54ccf249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e3f80e59286f915299e61341d078f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a388e3f80e59286f915299e61341d078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name.  <a href="classForceField.html#a388e3f80e59286f915299e61341d078f">More...</a><br /></td></tr>
<tr class="separator:a388e3f80e59286f915299e61341d078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memItemLeft" align="right" valign="top"><a id="aaa160c8cf0174cb4117d9eb1bc8ace54" name="aaa160c8cf0174cb4117d9eb1bc8ace54"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAtom(const std::string&amp;) but uses an <a class="el" href="classAtom.html">Atom</a> object pointer instead of a string to get the atom-type name. <br /></td></tr>
<tr class="separator:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memItemLeft" align="right" valign="top"><a id="a2be69fc1bd6346deab02dea6f67d7a45" name="a2be69fc1bd6346deab02dea6f67d7a45"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> () const</td></tr>
<tr class="memdesc:a2be69fc1bd6346deab02dea6f67d7a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded atom-types. <br /></td></tr>
<tr class="separator:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memItemLeft" align="right" valign="top"><a id="a8328f9fbf5155ffaebfc14543d59d82c" name="a8328f9fbf5155ffaebfc14543d59d82c"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> () const</td></tr>
<tr class="memdesc:a8328f9fbf5155ffaebfc14543d59d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded <b>non-hydrogen</b> atom-types. <br /></td></tr>
<tr class="separator:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01147c118b08eee9b7c2d138275c19"><td class="memItemLeft" align="right" valign="top"><a id="a8d01147c118b08eee9b7c2d138275c19" name="a8d01147c118b08eee9b7c2d138275c19"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a8d01147c118b08eee9b7c2d138275c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a2be69fc1bd6346deab02dea6f67d7a45" title="Randomly get a copy of any of the loaded atom-types.">getRandomAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a8d01147c118b08eee9b7c2d138275c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f60e9f58a6f6694e27398d50afa39d"><td class="memItemLeft" align="right" valign="top"><a id="a67f60e9f58a6f6694e27398d50afa39d" name="a67f60e9f58a6f6694e27398d50afa39d"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a67f60e9f58a6f6694e27398d50afa39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a8328f9fbf5155ffaebfc14543d59d82c" title="Randomly get a copy of any of the loaded non-hydrogen atom-types.">getRandomNonHAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a67f60e9f58a6f6694e27398d50afa39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memItemLeft" align="right" valign="top"><a id="ab799403bbacf06c7aa5215d8a4c9ccf9" name="ab799403bbacf06c7aa5215d8a4c9ccf9"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (const std::string &amp;s, double x, double y, double z) const</td></tr>
<tr class="memdesc:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an atom of a specific atom-type at a specified position. <br /></td></tr>
<tr class="separator:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memItemLeft" align="right" valign="top"><a id="a3c095b464ce6ba8f0eea33fb0c7ffa6b" name="a3c095b464ce6ba8f0eea33fb0c7ffa6b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getElementName</b> (const std::string &amp;el) const</td></tr>
<tr class="memdesc:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element name (symbol) corresponding to a given atom-type. <br /></td></tr>
<tr class="separator:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1831e6acc1949a3abd0a762235f145"><td class="memItemLeft" align="right" valign="top"><a id="abe1831e6acc1949a3abd0a762235f145" name="abe1831e6acc1949a3abd0a762235f145"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypesByElement</b> (const std::string &amp;el)</td></tr>
<tr class="memdesc:abe1831e6acc1949a3abd0a762235f145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all atom-types corresponding to a given element. <br /></td></tr>
<tr class="separator:abe1831e6acc1949a3abd0a762235f145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0676e821612c47f3675c790cac28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a95d0676e821612c47f3675c790cac28a">selectRandomBondableAtom</a> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *bias=nullptr) const</td></tr>
<tr class="memdesc:a95d0676e821612c47f3675c790cac28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random atom that can bond to this atom but bias the output.  <a href="classForceField.html#a95d0676e821612c47f3675c790cac28a">More...</a><br /></td></tr>
<tr class="separator:a95d0676e821612c47f3675c790cac28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab183018c1dce0c5c93e1dd36eccd57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#aab183018c1dce0c5c93e1dd36eccd57e">selectRandomBondableAtomTerminal</a> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *bias=nullptr) const</td></tr>
<tr class="memdesc:aab183018c1dce0c5c93e1dd36eccd57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random terminal atom that can bond to this atom but bias the output.  <a href="classForceField.html#aab183018c1dce0c5c93e1dd36eccd57e">More...</a><br /></td></tr>
<tr class="separator:aab183018c1dce0c5c93e1dd36eccd57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916b6f2de77e5c712e9e3404d7862a1a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">listAtomsByRule</a> (<a class="el" href="classAtom.html">Atom</a> *s, <a class="el" href="classMolecule.html">Molecule</a> *m, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a916b6f2de77e5c712e9e3404d7862a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Situationally list atoms that can bond to the selected atom.  <a href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">More...</a><br /></td></tr>
<tr class="separator:a916b6f2de77e5c712e9e3404d7862a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce8512467099140749410ca10298b0"><td class="memItemLeft" align="right" valign="top"><a id="aacce8512467099140749410ca10298b0" name="aacce8512467099140749410ca10298b0"></a>
std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>listAtomsByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:aacce8512467099140749410ca10298b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as listAtomsByRule(Atom*,Molecule*,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:aacce8512467099140749410ca10298b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1374c20d8953dac1cd300417aba041c5"><td class="memItemLeft" align="right" valign="top"><a id="a1374c20d8953dac1cd300417aba041c5" name="a1374c20d8953dac1cd300417aba041c5"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectAtomByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a1374c20d8953dac1cd300417aba041c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as selectAtomByRule(Atom*,Molecule*,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:a1374c20d8953dac1cd300417aba041c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629cd1dff57f199e0e836e00792101b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">listFragmentsByRule</a> (<a class="el" href="classAtom.html">Atom</a> *src, <a class="el" href="classMolecule.html">Molecule</a> *m, const FragmentSet &amp;frags, <a class="el" href="classAtom.html">Atom</a> *exa=nullptr, int devid=0) const</td></tr>
<tr class="memdesc:a629cd1dff57f199e0e836e00792101b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all possible a <b>fragments</b> that can bond to a given atom (following bonding rules).  <a href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">More...</a><br /></td></tr>
<tr class="separator:a629cd1dff57f199e0e836e00792101b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd448a8dfcb86280c02164fa14bc81"><td class="memItemLeft" align="right" valign="top"><a id="acfbd448a8dfcb86280c02164fa14bc81" name="acfbd448a8dfcb86280c02164fa14bc81"></a>
std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>listFragmentsByRule</b> (<a class="el" href="classAtom.html">Atom</a> *src, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, const FragmentSet &amp;frags, <a class="el" href="classAtom.html">Atom</a> *exa=nullptr, int devid=0) const</td></tr>
<tr class="memdesc:acfbd448a8dfcb86280c02164fa14bc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as listFragmentsByRule(Atom*,Molecule*,const FragmentSet&amp;,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:acfbd448a8dfcb86280c02164fa14bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b2cef43160cbdaf59142befd06f8cc"><td class="memItemLeft" align="right" valign="top"><a id="a31b2cef43160cbdaf59142befd06f8cc" name="a31b2cef43160cbdaf59142befd06f8cc"></a>
std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>selectFragmentByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, const FragmentSet &amp;fs, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a31b2cef43160cbdaf59142befd06f8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as selectFragmentByRule(Atom*,Molecule*,const FragmentSet&amp;,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:a31b2cef43160cbdaf59142befd06f8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">acceptNewBond</a> (<a class="el" href="classAtom.html">Atom</a> *src, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd, <a class="el" href="classAtom.html">Atom</a> *n) const</td></tr>
<tr class="memdesc:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions.  <a href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">More...</a><br /></td></tr>
<tr class="separator:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memItemLeft" align="right" valign="top"><a id="afb97cc6d011ec0f5d5b78a3f2bd0a94d" name="afb97cc6d011ec0f5d5b78a3f2bd0a94d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See contains(std::string) <br /></td></tr>
<tr class="separator:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memItemLeft" align="right" valign="top"><a id="a0c0ab714e289a47ea4a30cf6701ce6cd" name="a0c0ab714e289a47ea4a30cf6701ce6cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (std::string str) const</td></tr>
<tr class="memdesc:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checkes if this <a class="el" href="classForceField.html">ForceField</a> has an atom-type with the given name. <br /></td></tr>
<tr class="separator:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memItemLeft" align="right" valign="top"><a id="a40426986b9cd4c8fbabcb3cd0fb2ecb7" name="a40426986b9cd4c8fbabcb3cd0fb2ecb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> ()</td></tr>
<tr class="memdesc:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write valency, σ, and ε of all the atom-types to stdout. <br /></td></tr>
<tr class="separator:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:a11ef1ec5670fc1755a3ad4618d63d734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make.  <a href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">More...</a><br /></td></tr>
<tr class="separator:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ddc7dd89f688b86adba44834fc45a4"><td class="memItemLeft" align="right" valign="top"><a id="a32ddc7dd89f688b86adba44834fc45a4" name="a32ddc7dd89f688b86adba44834fc45a4"></a>
const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAllowedBonds</b> (const std::string &amp;temp) const</td></tr>
<tr class="memdesc:a32ddc7dd89f688b86adba44834fc45a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAllowedBonds(Atom*), but provides the atom-type by name (as std::string) <br /></td></tr>
<tr class="separator:a32ddc7dd89f688b86adba44834fc45a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5244bfbdfed05f3dd715a0a0356400"><td class="memItemLeft" align="right" valign="top"><a id="a4d5244bfbdfed05f3dd715a0a0356400" name="a4d5244bfbdfed05f3dd715a0a0356400"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadLengths</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a4d5244bfbdfed05f3dd715a0a0356400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-length data from a given file. <br /></td></tr>
<tr class="separator:a4d5244bfbdfed05f3dd715a0a0356400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c607a224f64dae5fd2ba9500c7a889"><td class="memItemLeft" align="right" valign="top"><a id="a56c607a224f64dae5fd2ba9500c7a889" name="a56c607a224f64dae5fd2ba9500c7a889"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadAngles</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a56c607a224f64dae5fd2ba9500c7a889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-angle data from a given file. <br /></td></tr>
<tr class="separator:a56c607a224f64dae5fd2ba9500c7a889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9339a06dc0064de241a3ddc03db712d"><td class="memItemLeft" align="right" valign="top"><a id="ae9339a06dc0064de241a3ddc03db712d" name="ae9339a06dc0064de241a3ddc03db712d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadDihedrals</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae9339a06dc0064de241a3ddc03db712d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load dihedral data from a given file. <br /></td></tr>
<tr class="separator:ae9339a06dc0064de241a3ddc03db712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4871a728498d1cd28e5cfc2130b99a53"><td class="memItemLeft" align="right" valign="top"><a id="a4871a728498d1cd28e5cfc2130b99a53" name="a4871a728498d1cd28e5cfc2130b99a53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadImpropers</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a4871a728498d1cd28e5cfc2130b99a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load improper dihedral data from a given file (not used in later versions of DeNovo) <br /></td></tr>
<tr class="separator:a4871a728498d1cd28e5cfc2130b99a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30de07cb95485f78dc1ae64eec9562"><td class="memItemLeft" align="right" valign="top"><a id="a3a30de07cb95485f78dc1ae64eec9562" name="a3a30de07cb95485f78dc1ae64eec9562"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadBondParameters</b> (std::string lengthfn=LengthDataFile, std::string anglefn=AngleDataFile, std::string dihedralfn=DihedralDataFile, std::string improperfn=ImproperDataFile)</td></tr>
<tr class="memdesc:a3a30de07cb95485f78dc1ae64eec9562"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to load all parameters (bond-length,bond-angle,dihedral,and improper-dihedral). See documentation (PDF) for default filenames. <br /></td></tr>
<tr class="separator:a3a30de07cb95485f78dc1ae64eec9562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memItemLeft" align="right" valign="top"><a id="a19cb372462ff31cda4096ae2d20ee1d4" name="a19cb372462ff31cda4096ae2d20ee1d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOneFourParameters</b> (const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a19cb372462ff31cda4096ae2d20ee1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load one-four interaction parameters from a given file. Later versions of DeNovo directly use the parameters from the atom-type data. <br /></td></tr>
<tr class="separator:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa1bfbe7d28409e5770952907a2de9"><td class="memItemLeft" align="right" valign="top"><a id="a02aa1bfbe7d28409e5770952907a2de9" name="a02aa1bfbe7d28409e5770952907a2de9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOtherInteractions</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a02aa1bfbe7d28409e5770952907a2de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load L-J parameters from a given file. Later versions of DeNovo use the <a class="el" href="classAtom.html">Atom</a> object for parameters directly. <br /></td></tr>
<tr class="separator:a02aa1bfbe7d28409e5770952907a2de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memItemLeft" align="right" valign="top"><a id="afcc0a1b1e130d9a590a8dcffa597859f" name="afcc0a1b1e130d9a590a8dcffa597859f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadNonbondedInteractions</b> (const std::string &amp;onefourfile=OneFourFile, const std::string &amp;otherfile=OtherInterFile)</td></tr>
<tr class="memdesc:afcc0a1b1e130d9a590a8dcffa597859f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 1-4 non-bonding potential parameters, as well as L-J potential parameters. <br /></td></tr>
<tr class="separator:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19cd0db1e679daf537e06ef3308f721"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">getBondLength</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool silent=false) const</td></tr>
<tr class="memdesc:ab19cd0db1e679daf537e06ef3308f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond length for the bond between two atom types.  <a href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">More...</a><br /></td></tr>
<tr class="separator:ab19cd0db1e679daf537e06ef3308f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b8d029b748fb56265d4ee5cce2873"><td class="memItemLeft" align="right" valign="top"><a id="a084b8d029b748fb56265d4ee5cce2873" name="a084b8d029b748fb56265d4ee5cce2873"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::string &amp;a1, const string &amp;a2, bool silent=false) const</td></tr>
<tr class="memdesc:a084b8d029b748fb56265d4ee5cce2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a084b8d029b748fb56265d4ee5cce2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af019ff49e9086043b31c27fa9fae11ae"><td class="memItemLeft" align="right" valign="top"><a id="af019ff49e9086043b31c27fa9fae11ae" name="af019ff49e9086043b31c27fa9fae11ae"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::vector&lt; std::string &gt; &amp;sv, bool silent=false) const</td></tr>
<tr class="memdesc:af019ff49e9086043b31c27fa9fae11ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string lists instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af019ff49e9086043b31c27fa9fae11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memItemLeft" align="right" valign="top"><a id="ad1b08a30e9e807ef4e7f52cd8cfc836e" name="ad1b08a30e9e807ef4e7f52cd8cfc836e"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::pair&lt; std::string, std::string &gt; &amp;atp, bool silent=false) const</td></tr>
<tr class="memdesc:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string pairs instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b06865581950f90f100bd04b139cf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a008b06865581950f90f100bd04b139cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types. -failsafe method.  <a href="classForceField.html#a008b06865581950f90f100bd04b139cf">More...</a><br /></td></tr>
<tr class="separator:a008b06865581950f90f100bd04b139cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memItemLeft" align="right" valign="top"><a id="aa3f2ba9fedbcb940d81f5854dfb75d21" name="aa3f2ba9fedbcb940d81f5854dfb75d21"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3) const</td></tr>
<tr class="memdesc:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memItemLeft" align="right" valign="top"><a id="a66f6acff5098b0c0165a3d4a70fa8d8a" name="a66f6acff5098b0c0165a3d4a70fa8d8a"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using a string list instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac293e6cde680b1ef64c9d337796be0a6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3) const</td></tr>
<tr class="memdesc:ac293e6cde680b1ef64c9d337796be0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types.  <a href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">More...</a><br /></td></tr>
<tr class="separator:ac293e6cde680b1ef64c9d337796be0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a54f2de7bdc1dc0b1be4060c3a8fde540">getAngleParamters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e27b4bf5bea870617379cdb657cefd7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4) const</td></tr>
<tr class="memdesc:a2e27b4bf5bea870617379cdb657cefd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method.  <a href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">More...</a><br /></td></tr>
<tr class="separator:a2e27b4bf5bea870617379cdb657cefd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4e9cfa168d0f0b906fc49782929d15"><td class="memItemLeft" align="right" valign="top"><a id="afd4e9cfa168d0f0b906fc49782929d15" name="afd4e9cfa168d0f0b906fc49782929d15"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralParametersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4) const</td></tr>
<tr class="memdesc:afd4e9cfa168d0f0b906fc49782929d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getDihedralParametersFailsafe(Atom*,Atom*,Atom*,Atom*) using a strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:afd4e9cfa168d0f0b906fc49782929d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle data for a set of four atom-types (in order of the connection chain)  <a href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">More...</a><br /></td></tr>
<tr class="separator:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a3bc80bfd10caa37d151f412d2cbe052b">getDihedralParameters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memItemLeft" align="right" valign="top"><a id="a546fe4a3aef3fa3928f918dd9ec490e9" name="a546fe4a3aef3fa3928f918dd9ec490e9"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly matches the atom-type names to the improper dihedral data and retrieves the angle. If not available <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. <br /></td></tr>
<tr class="separator:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memItemLeft" align="right" valign="top"><a id="a9c18ff07f6ff1e200f8aa706ab15cebb" name="a9c18ff07f6ff1e200f8aa706ab15cebb"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getImproperParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list. <br /></td></tr>
<tr class="separator:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memItemLeft" align="right" valign="top"><a id="a94ea10328f7d6e197a5d2b9e60d488f1" name="a94ea10328f7d6e197a5d2b9e60d488f1"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getOtherParameters</b> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the σ and ε values for a given atom-type. <br /></td></tr>
<tr class="separator:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c885b9892eb5c5f020f445bcb5853f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:a34c885b9892eb5c5f020f445bcb5853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the angle-strain potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">More...</a><br /></td></tr>
<tr class="separator:a34c885b9892eb5c5f020f445bcb5853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa188e56b9a3fb2b90fabe21f66882278"><td class="memItemLeft" align="right" valign="top"><a id="aa188e56b9a3fb2b90fabe21f66882278" name="aa188e56b9a3fb2b90fabe21f66882278"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateAngleEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, double th, double ub, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:aa188e56b9a3fb2b90fabe21f66882278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateAngleEnergy(Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa188e56b9a3fb2b90fabe21f66882278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dihedral potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">More...</a><br /></td></tr>
<tr class="separator:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e74dd7f3607c017f12a7410e35a4f"><td class="memItemLeft" align="right" valign="top"><a id="a169e74dd7f3607c017f12a7410e35a4f" name="a169e74dd7f3607c017f12a7410e35a4f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateDihedralEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, double ph, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a169e74dd7f3607c017f12a7410e35a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateDihedralEnergy(Atom*,Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a169e74dd7f3607c017f12a7410e35a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6feb2e505f33c5a7e51075b382f36642"><td class="memItemLeft" align="right" valign="top"><a id="a6feb2e505f33c5a7e51075b382f36642" name="a6feb2e505f33c5a7e51075b382f36642"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a6feb2e505f33c5a7e51075b382f36642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inproper dihedral energy. Not used in latest versions of DeNovo. Refer to links provided in documentation PDF. Throws <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> if data is not available. <br /></td></tr>
<tr class="separator:a6feb2e505f33c5a7e51075b382f36642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3c6c3f537052118bd081e739bfcc3"><td class="memItemLeft" align="right" valign="top"><a id="af0a3c6c3f537052118bd081e739bfcc3" name="af0a3c6c3f537052118bd081e739bfcc3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, const double &amp;q) const</td></tr>
<tr class="memdesc:af0a3c6c3f537052118bd081e739bfcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateImproperEnergy(Atom*,Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af0a3c6c3f537052118bd081e739bfcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8273c2e8667bc21edb7599c1210dda4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">ForceField</a> ()</td></tr>
<tr class="memdesc:a8273c2e8667bc21edb7599c1210dda4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters)  <a href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">More...</a><br /></td></tr>
<tr class="separator:a8273c2e8667bc21edb7599c1210dda4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50040e928edbb4d694f4f2f894debba7"><td class="memItemLeft" align="right" valign="top"><a id="a50040e928edbb4d694f4f2f894debba7" name="a50040e928edbb4d694f4f2f894debba7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceField</b> (const std::string &amp;ff_file)</td></tr>
<tr class="memdesc:a50040e928edbb4d694f4f2f894debba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format (see PDF documentation for format details) <br /></td></tr>
<tr class="separator:a50040e928edbb4d694f4f2f894debba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea81a4f90173d98b5d683f3508f936"><td class="memItemLeft" align="right" valign="top"><a id="aafea81a4f90173d98b5d683f3508f936" name="aafea81a4f90173d98b5d683f3508f936"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceField</b> (const std::string &amp;ff_file, const std::string &amp;catf)</td></tr>
<tr class="memdesc:aafea81a4f90173d98b5d683f3508f936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format, and categories from a categories file. (see PDF documentation for format details) <br /></td></tr>
<tr class="separator:aafea81a4f90173d98b5d683f3508f936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memItemLeft" align="right" valign="top"><a id="a04cb5ddf90e2e0870e7fe5604b316c51" name="a04cb5ddf90e2e0870e7fe5604b316c51"></a>
const std::vector&lt; <a class="el" href="classResidue.html">Residue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidues</b> () const</td></tr>
<tr class="memdesc:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list with all the residues loaded into this Forcefield. <br /></td></tr>
<tr class="separator:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720bf8a957e4d00740c2d353b8be1181"><td class="memItemLeft" align="right" valign="top"><a id="a720bf8a957e4d00740c2d353b8be1181" name="a720bf8a957e4d00740c2d353b8be1181"></a>
const <a class="el" href="classResidue.html">Residue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidue</b> (const std::string &amp;rname) const</td></tr>
<tr class="memdesc:a720bf8a957e4d00740c2d353b8be1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classResidue.html">Residue</a> from those loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. <br /></td></tr>
<tr class="separator:a720bf8a957e4d00740c2d353b8be1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9902cf610a724e451d0f5d2a87934fa3"><td class="memItemLeft" align="right" valign="top"><a id="a9902cf610a724e451d0f5d2a87934fa3" name="a9902cf610a724e451d0f5d2a87934fa3"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategories</b> () const</td></tr>
<tr class="memdesc:a9902cf610a724e451d0f5d2a87934fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all Categories loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a9902cf610a724e451d0f5d2a87934fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c830622f775f42f2b8e38afb2f4c3"><td class="memItemLeft" align="right" valign="top"><a id="a942c830622f775f42f2b8e38afb2f4c3" name="a942c830622f775f42f2b8e38afb2f4c3"></a>
const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypes</b> () const</td></tr>
<tr class="memdesc:a942c830622f775f42f2b8e38afb2f4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the atom-types (as <a class="el" href="classAtom.html">Atom</a> object pointers) loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a942c830622f775f42f2b8e38afb2f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71608edab6564b721aa4b77739a82fc4"><td class="memItemLeft" align="right" valign="top"><a id="a71608edab6564b721aa4b77739a82fc4" name="a71608edab6564b721aa4b77739a82fc4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (<a class="el" href="classAtom.html">Atom</a> *a)</td></tr>
<tr class="memdesc:a71608edab6564b721aa4b77739a82fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a71608edab6564b721aa4b77739a82fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afad3eec7b365936072675c74e4d185"><td class="memItemLeft" align="right" valign="top"><a id="a8afad3eec7b365936072675c74e4d185" name="a8afad3eec7b365936072675c74e4d185"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8afad3eec7b365936072675c74e4d185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a8afad3eec7b365936072675c74e4d185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0393adb6d13dfa912934c4fce143a94"><td class="memItemLeft" align="right" valign="top"><a id="ae0393adb6d13dfa912934c4fce143a94" name="ae0393adb6d13dfa912934c4fce143a94"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getElectronegativity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae0393adb6d13dfa912934c4fce143a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get electronegativity data for a given element - experimental. If the data is not available, the user is prompted to enter it after which is is stored for that run. <br /></td></tr>
<tr class="separator:ae0393adb6d13dfa912934c4fce143a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350fc55fa7f24176462228adeb4dd59d"><td class="memItemLeft" align="right" valign="top"><a id="a350fc55fa7f24176462228adeb4dd59d" name="a350fc55fa7f24176462228adeb4dd59d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadCategories</b> (const std::string &amp;catf)</td></tr>
<tr class="memdesc:a350fc55fa7f24176462228adeb4dd59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load categories from an external file into this forcefield. Categories can also be loaded when the <a class="el" href="classForceField.html">ForceField</a> object is created (See: <a class="el" href="classForceField.html#aafea81a4f90173d98b5d683f3508f936" title="Load the forcefield from the standard ffin format, and categories from a categories file....">ForceField(const std::string&amp;,const std::string&amp;)</a>) <br /></td></tr>
<tr class="separator:a350fc55fa7f24176462228adeb4dd59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95480a4783499ac5ed4743e6c6ab871d"><td class="memItemLeft" align="right" valign="top"><a id="a95480a4783499ac5ed4743e6c6ab871d" name="a95480a4783499ac5ed4743e6c6ab871d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadRules</b> (const std::string &amp;fl)</td></tr>
<tr class="memdesc:a95480a4783499ac5ed4743e6c6ab871d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load rules from a given file. See the atom-type definition section of documentation PDF for more details on format. <br /></td></tr>
<tr class="separator:a95480a4783499ac5ed4743e6c6ab871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">getRules</a> () const</td></tr>
<tr class="memdesc:ac4e6c7a3139b39b1f286a00f53526f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all the rules loaded into this forcefield.  <a href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">More...</a><br /></td></tr>
<tr class="separator:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bfc00e94bac57310cc3a4778e11342"><td class="memItemLeft" align="right" valign="top"><a id="ab5bfc00e94bac57310cc3a4778e11342" name="ab5bfc00e94bac57310cc3a4778e11342"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ab5bfc00e94bac57310cc3a4778e11342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given <a class="el" href="classCategory.html">Category</a> is present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:ab5bfc00e94bac57310cc3a4778e11342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memItemLeft" align="right" valign="top"><a id="a5a30c5a7760b5c791c5b34f9bd133506" name="a5a30c5a7760b5c791c5b34f9bd133506"></a>
const <a class="el" href="classCategory.html">Category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a5a30c5a7760b5c791c5b34f9bd133506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the chosen <a class="el" href="classCategory.html">Category</a> by name if present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. If there is no <a class="el" href="classCategory.html">Category</a> with this name, <a class="el" href="classNoSuchCategoryException.html">NoSuchCategoryException</a> is thrown. <br /></td></tr>
<tr class="separator:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memItemLeft" align="right" valign="top"><a id="a365a885eb6f7bc1b154ac2e3c1a0e71e" name="a365a885eb6f7bc1b154ac2e3c1a0e71e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd) const</td></tr>
<tr class="memdesc:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined (See Rule::satisfies(Atom*,Molecule*,const ForceField*)) <br /></td></tr>
<tr class="separator:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7652c528231e7e76f85b4c0d54ccf249"><td class="memItemLeft" align="right" valign="top"><a id="a7652c528231e7e76f85b4c0d54ccf249" name="a7652c528231e7e76f85b4c0d54ccf249"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *n, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd) const</td></tr>
<tr class="memdesc:a7652c528231e7e76f85b4c0d54ccf249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined given that an extra bond is formed to the new atom 'n' supplied (See Rule::satisfies(Atom*,Atom*,Molecule*)) <br /></td></tr>
<tr class="separator:a7652c528231e7e76f85b4c0d54ccf249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e3f80e59286f915299e61341d078f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a388e3f80e59286f915299e61341d078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name.  <a href="classForceField.html#a388e3f80e59286f915299e61341d078f">More...</a><br /></td></tr>
<tr class="separator:a388e3f80e59286f915299e61341d078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memItemLeft" align="right" valign="top"><a id="aaa160c8cf0174cb4117d9eb1bc8ace54" name="aaa160c8cf0174cb4117d9eb1bc8ace54"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAtom(const std::string&amp;) but uses an <a class="el" href="classAtom.html">Atom</a> object pointer instead of a string to get the atom-type name. <br /></td></tr>
<tr class="separator:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memItemLeft" align="right" valign="top"><a id="a3c095b464ce6ba8f0eea33fb0c7ffa6b" name="a3c095b464ce6ba8f0eea33fb0c7ffa6b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getElementName</b> (const std::string &amp;el) const</td></tr>
<tr class="memdesc:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element name (symbol) corresponding to a given atom-type. <br /></td></tr>
<tr class="separator:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memItemLeft" align="right" valign="top"><a id="a2be69fc1bd6346deab02dea6f67d7a45" name="a2be69fc1bd6346deab02dea6f67d7a45"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> () const</td></tr>
<tr class="memdesc:a2be69fc1bd6346deab02dea6f67d7a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded atom-types. <br /></td></tr>
<tr class="separator:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memItemLeft" align="right" valign="top"><a id="a8328f9fbf5155ffaebfc14543d59d82c" name="a8328f9fbf5155ffaebfc14543d59d82c"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> () const</td></tr>
<tr class="memdesc:a8328f9fbf5155ffaebfc14543d59d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded <b>non-hydrogen</b> atom-types. <br /></td></tr>
<tr class="separator:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01147c118b08eee9b7c2d138275c19"><td class="memItemLeft" align="right" valign="top"><a id="a8d01147c118b08eee9b7c2d138275c19" name="a8d01147c118b08eee9b7c2d138275c19"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a8d01147c118b08eee9b7c2d138275c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a2be69fc1bd6346deab02dea6f67d7a45" title="Randomly get a copy of any of the loaded atom-types.">getRandomAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a8d01147c118b08eee9b7c2d138275c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f60e9f58a6f6694e27398d50afa39d"><td class="memItemLeft" align="right" valign="top"><a id="a67f60e9f58a6f6694e27398d50afa39d" name="a67f60e9f58a6f6694e27398d50afa39d"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a67f60e9f58a6f6694e27398d50afa39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a8328f9fbf5155ffaebfc14543d59d82c" title="Randomly get a copy of any of the loaded non-hydrogen atom-types.">getRandomNonHAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a67f60e9f58a6f6694e27398d50afa39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memItemLeft" align="right" valign="top"><a id="ab799403bbacf06c7aa5215d8a4c9ccf9" name="ab799403bbacf06c7aa5215d8a4c9ccf9"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (const std::string &amp;s, double x, double y, double z) const</td></tr>
<tr class="memdesc:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an atom of a specific atom-type at a specified position. <br /></td></tr>
<tr class="separator:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0676e821612c47f3675c790cac28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a95d0676e821612c47f3675c790cac28a">selectRandomBondableAtom</a> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *bias=nullptr) const</td></tr>
<tr class="memdesc:a95d0676e821612c47f3675c790cac28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random atom that can bond to this atom but bias the output.  <a href="classForceField.html#a95d0676e821612c47f3675c790cac28a">More...</a><br /></td></tr>
<tr class="separator:a95d0676e821612c47f3675c790cac28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314a55483177e20397b04e185b37b2ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a314a55483177e20397b04e185b37b2ed">selectAtomByRule</a> (<a class="el" href="classAtom.html">Atom</a> *s, <a class="el" href="classMolecule.html">Molecule</a> *m, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a314a55483177e20397b04e185b37b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Situationally choose an atom that can bond to the selected atom.  <a href="classForceField.html#a314a55483177e20397b04e185b37b2ed">More...</a><br /></td></tr>
<tr class="separator:a314a55483177e20397b04e185b37b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1374c20d8953dac1cd300417aba041c5"><td class="memItemLeft" align="right" valign="top"><a id="a1374c20d8953dac1cd300417aba041c5" name="a1374c20d8953dac1cd300417aba041c5"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectAtomByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a1374c20d8953dac1cd300417aba041c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as selectAtomByRule(Atom*,Molecule*,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:a1374c20d8953dac1cd300417aba041c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">acceptNewBond</a> (<a class="el" href="classAtom.html">Atom</a> *src, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd, <a class="el" href="classAtom.html">Atom</a> *n) const</td></tr>
<tr class="memdesc:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions.  <a href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">More...</a><br /></td></tr>
<tr class="separator:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memItemLeft" align="right" valign="top"><a id="afb97cc6d011ec0f5d5b78a3f2bd0a94d" name="afb97cc6d011ec0f5d5b78a3f2bd0a94d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See contains(std::string) <br /></td></tr>
<tr class="separator:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memItemLeft" align="right" valign="top"><a id="a0c0ab714e289a47ea4a30cf6701ce6cd" name="a0c0ab714e289a47ea4a30cf6701ce6cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (std::string str) const</td></tr>
<tr class="memdesc:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checkes if this <a class="el" href="classForceField.html">ForceField</a> has an atom-type with the given name. <br /></td></tr>
<tr class="separator:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memItemLeft" align="right" valign="top"><a id="a40426986b9cd4c8fbabcb3cd0fb2ecb7" name="a40426986b9cd4c8fbabcb3cd0fb2ecb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> ()</td></tr>
<tr class="memdesc:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write valency, σ, and ε of all the atom-types to stdout. <br /></td></tr>
<tr class="separator:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:a11ef1ec5670fc1755a3ad4618d63d734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make.  <a href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">More...</a><br /></td></tr>
<tr class="separator:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ddc7dd89f688b86adba44834fc45a4"><td class="memItemLeft" align="right" valign="top"><a id="a32ddc7dd89f688b86adba44834fc45a4" name="a32ddc7dd89f688b86adba44834fc45a4"></a>
const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAllowedBonds</b> (const std::string &amp;temp) const</td></tr>
<tr class="memdesc:a32ddc7dd89f688b86adba44834fc45a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAllowedBonds(Atom*), but provides the atom-type by name (as std::string) <br /></td></tr>
<tr class="separator:a32ddc7dd89f688b86adba44834fc45a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5244bfbdfed05f3dd715a0a0356400"><td class="memItemLeft" align="right" valign="top"><a id="a4d5244bfbdfed05f3dd715a0a0356400" name="a4d5244bfbdfed05f3dd715a0a0356400"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadLengths</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a4d5244bfbdfed05f3dd715a0a0356400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-length data from a given file. <br /></td></tr>
<tr class="separator:a4d5244bfbdfed05f3dd715a0a0356400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c607a224f64dae5fd2ba9500c7a889"><td class="memItemLeft" align="right" valign="top"><a id="a56c607a224f64dae5fd2ba9500c7a889" name="a56c607a224f64dae5fd2ba9500c7a889"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadAngles</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a56c607a224f64dae5fd2ba9500c7a889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-angle data from a given file. <br /></td></tr>
<tr class="separator:a56c607a224f64dae5fd2ba9500c7a889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9339a06dc0064de241a3ddc03db712d"><td class="memItemLeft" align="right" valign="top"><a id="ae9339a06dc0064de241a3ddc03db712d" name="ae9339a06dc0064de241a3ddc03db712d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadDihedrals</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae9339a06dc0064de241a3ddc03db712d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load dihedral data from a given file. <br /></td></tr>
<tr class="separator:ae9339a06dc0064de241a3ddc03db712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4871a728498d1cd28e5cfc2130b99a53"><td class="memItemLeft" align="right" valign="top"><a id="a4871a728498d1cd28e5cfc2130b99a53" name="a4871a728498d1cd28e5cfc2130b99a53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadImpropers</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a4871a728498d1cd28e5cfc2130b99a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load improper dihedral data from a given file (not used in later versions of DeNovo) <br /></td></tr>
<tr class="separator:a4871a728498d1cd28e5cfc2130b99a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30de07cb95485f78dc1ae64eec9562"><td class="memItemLeft" align="right" valign="top"><a id="a3a30de07cb95485f78dc1ae64eec9562" name="a3a30de07cb95485f78dc1ae64eec9562"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadBondParameters</b> (std::string lengthfn=LengthDataFile, std::string anglefn=AngleDataFile, std::string dihedralfn=DihedralDataFile, std::string improperfn=ImproperDataFile)</td></tr>
<tr class="memdesc:a3a30de07cb95485f78dc1ae64eec9562"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to load all parameters (bond-length,bond-angle,dihedral,and improper-dihedral). See documentation (PDF) for default filenames. <br /></td></tr>
<tr class="separator:a3a30de07cb95485f78dc1ae64eec9562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memItemLeft" align="right" valign="top"><a id="a19cb372462ff31cda4096ae2d20ee1d4" name="a19cb372462ff31cda4096ae2d20ee1d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOneFourParameters</b> (const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a19cb372462ff31cda4096ae2d20ee1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load one-four interaction parameters from a given file. Later versions of DeNovo directly use the parameters from the atom-type data. <br /></td></tr>
<tr class="separator:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa1bfbe7d28409e5770952907a2de9"><td class="memItemLeft" align="right" valign="top"><a id="a02aa1bfbe7d28409e5770952907a2de9" name="a02aa1bfbe7d28409e5770952907a2de9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOtherInteractions</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a02aa1bfbe7d28409e5770952907a2de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load L-J parameters from a given file. Later versions of DeNovo use the <a class="el" href="classAtom.html">Atom</a> object for parameters directly. <br /></td></tr>
<tr class="separator:a02aa1bfbe7d28409e5770952907a2de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memItemLeft" align="right" valign="top"><a id="afcc0a1b1e130d9a590a8dcffa597859f" name="afcc0a1b1e130d9a590a8dcffa597859f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadNonbondedInteractions</b> (const std::string &amp;onefourfile=OneFourFile, const std::string &amp;otherfile=OtherInterFile)</td></tr>
<tr class="memdesc:afcc0a1b1e130d9a590a8dcffa597859f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 1-4 non-bonding potential parameters, as well as L-J potential parameters. <br /></td></tr>
<tr class="separator:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19cd0db1e679daf537e06ef3308f721"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">getBondLength</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool silent=false) const</td></tr>
<tr class="memdesc:ab19cd0db1e679daf537e06ef3308f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond length for the bond between two atom types.  <a href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">More...</a><br /></td></tr>
<tr class="separator:ab19cd0db1e679daf537e06ef3308f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b8d029b748fb56265d4ee5cce2873"><td class="memItemLeft" align="right" valign="top"><a id="a084b8d029b748fb56265d4ee5cce2873" name="a084b8d029b748fb56265d4ee5cce2873"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::string &amp;a1, const string &amp;a2, bool silent=false) const</td></tr>
<tr class="memdesc:a084b8d029b748fb56265d4ee5cce2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a084b8d029b748fb56265d4ee5cce2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af019ff49e9086043b31c27fa9fae11ae"><td class="memItemLeft" align="right" valign="top"><a id="af019ff49e9086043b31c27fa9fae11ae" name="af019ff49e9086043b31c27fa9fae11ae"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::vector&lt; std::string &gt; &amp;sv, bool silent=false) const</td></tr>
<tr class="memdesc:af019ff49e9086043b31c27fa9fae11ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string lists instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af019ff49e9086043b31c27fa9fae11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memItemLeft" align="right" valign="top"><a id="ad1b08a30e9e807ef4e7f52cd8cfc836e" name="ad1b08a30e9e807ef4e7f52cd8cfc836e"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::pair&lt; std::string, std::string &gt; &amp;atp, bool silent=false) const</td></tr>
<tr class="memdesc:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string pairs instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b06865581950f90f100bd04b139cf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a008b06865581950f90f100bd04b139cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types. -failsafe method.  <a href="classForceField.html#a008b06865581950f90f100bd04b139cf">More...</a><br /></td></tr>
<tr class="separator:a008b06865581950f90f100bd04b139cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memItemLeft" align="right" valign="top"><a id="aa3f2ba9fedbcb940d81f5854dfb75d21" name="aa3f2ba9fedbcb940d81f5854dfb75d21"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3) const</td></tr>
<tr class="memdesc:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memItemLeft" align="right" valign="top"><a id="a66f6acff5098b0c0165a3d4a70fa8d8a" name="a66f6acff5098b0c0165a3d4a70fa8d8a"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using a string list instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac293e6cde680b1ef64c9d337796be0a6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3) const</td></tr>
<tr class="memdesc:ac293e6cde680b1ef64c9d337796be0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types.  <a href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">More...</a><br /></td></tr>
<tr class="separator:ac293e6cde680b1ef64c9d337796be0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a54f2de7bdc1dc0b1be4060c3a8fde540">getAngleParamters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e27b4bf5bea870617379cdb657cefd7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4) const</td></tr>
<tr class="memdesc:a2e27b4bf5bea870617379cdb657cefd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method.  <a href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">More...</a><br /></td></tr>
<tr class="separator:a2e27b4bf5bea870617379cdb657cefd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4e9cfa168d0f0b906fc49782929d15"><td class="memItemLeft" align="right" valign="top"><a id="afd4e9cfa168d0f0b906fc49782929d15" name="afd4e9cfa168d0f0b906fc49782929d15"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralParametersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4) const</td></tr>
<tr class="memdesc:afd4e9cfa168d0f0b906fc49782929d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getDihedralParametersFailsafe(Atom*,Atom*,Atom*,Atom*) using a strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:afd4e9cfa168d0f0b906fc49782929d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle data for a set of four atom-types (in order of the connection chain)  <a href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">More...</a><br /></td></tr>
<tr class="separator:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a3bc80bfd10caa37d151f412d2cbe052b">getDihedralParameters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memItemLeft" align="right" valign="top"><a id="a546fe4a3aef3fa3928f918dd9ec490e9" name="a546fe4a3aef3fa3928f918dd9ec490e9"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly matches the atom-type names to the improper dihedral data and retrieves the angle. If not available <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. <br /></td></tr>
<tr class="separator:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memItemLeft" align="right" valign="top"><a id="a9c18ff07f6ff1e200f8aa706ab15cebb" name="a9c18ff07f6ff1e200f8aa706ab15cebb"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getImproperParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list. <br /></td></tr>
<tr class="separator:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5948ff98fc67ffe81aba25fb06b1926"><td class="memItemLeft" align="right" valign="top"><a id="af5948ff98fc67ffe81aba25fb06b1926" name="af5948ff98fc67ffe81aba25fb06b1926"></a>
const std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParametersFailsafe</b> (const std::vector&lt; std::string &gt; &amp;ats, int nb, int mv) const</td></tr>
<tr class="memdesc:af5948ff98fc67ffe81aba25fb06b1926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for the given atom-set combination in the improper database. If not found, return default values based on hybridization. <br /></td></tr>
<tr class="separator:af5948ff98fc67ffe81aba25fb06b1926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memItemLeft" align="right" valign="top"><a id="a94ea10328f7d6e197a5d2b9e60d488f1" name="a94ea10328f7d6e197a5d2b9e60d488f1"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getOtherParameters</b> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the σ and ε values for a given atom-type. <br /></td></tr>
<tr class="separator:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c885b9892eb5c5f020f445bcb5853f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:a34c885b9892eb5c5f020f445bcb5853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the angle-strain potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">More...</a><br /></td></tr>
<tr class="separator:a34c885b9892eb5c5f020f445bcb5853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa188e56b9a3fb2b90fabe21f66882278"><td class="memItemLeft" align="right" valign="top"><a id="aa188e56b9a3fb2b90fabe21f66882278" name="aa188e56b9a3fb2b90fabe21f66882278"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateAngleEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, double th, double ub, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:aa188e56b9a3fb2b90fabe21f66882278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateAngleEnergy(Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa188e56b9a3fb2b90fabe21f66882278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dihedral potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">More...</a><br /></td></tr>
<tr class="separator:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e74dd7f3607c017f12a7410e35a4f"><td class="memItemLeft" align="right" valign="top"><a id="a169e74dd7f3607c017f12a7410e35a4f" name="a169e74dd7f3607c017f12a7410e35a4f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateDihedralEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, double ph, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a169e74dd7f3607c017f12a7410e35a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateDihedralEnergy(Atom*,Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a169e74dd7f3607c017f12a7410e35a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6feb2e505f33c5a7e51075b382f36642"><td class="memItemLeft" align="right" valign="top"><a id="a6feb2e505f33c5a7e51075b382f36642" name="a6feb2e505f33c5a7e51075b382f36642"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a6feb2e505f33c5a7e51075b382f36642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inproper dihedral energy. Not used in latest versions of DeNovo. Refer to links provided in documentation PDF. Throws <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> if data is not available. <br /></td></tr>
<tr class="separator:a6feb2e505f33c5a7e51075b382f36642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3c6c3f537052118bd081e739bfcc3"><td class="memItemLeft" align="right" valign="top"><a id="af0a3c6c3f537052118bd081e739bfcc3" name="af0a3c6c3f537052118bd081e739bfcc3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, const double &amp;q) const</td></tr>
<tr class="memdesc:af0a3c6c3f537052118bd081e739bfcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateImproperEnergy(Atom*,Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af0a3c6c3f537052118bd081e739bfcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8273c2e8667bc21edb7599c1210dda4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">ForceField</a> ()</td></tr>
<tr class="memdesc:a8273c2e8667bc21edb7599c1210dda4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters)  <a href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">More...</a><br /></td></tr>
<tr class="separator:a8273c2e8667bc21edb7599c1210dda4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50040e928edbb4d694f4f2f894debba7"><td class="memItemLeft" align="right" valign="top"><a id="a50040e928edbb4d694f4f2f894debba7" name="a50040e928edbb4d694f4f2f894debba7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceField</b> (const std::string &amp;ff_file)</td></tr>
<tr class="memdesc:a50040e928edbb4d694f4f2f894debba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format (see PDF documentation for format details) <br /></td></tr>
<tr class="separator:a50040e928edbb4d694f4f2f894debba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea81a4f90173d98b5d683f3508f936"><td class="memItemLeft" align="right" valign="top"><a id="aafea81a4f90173d98b5d683f3508f936" name="aafea81a4f90173d98b5d683f3508f936"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceField</b> (const std::string &amp;ff_file, const std::string &amp;catf)</td></tr>
<tr class="memdesc:aafea81a4f90173d98b5d683f3508f936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the forcefield from the standard ffin format, and categories from a categories file. (see PDF documentation for format details) <br /></td></tr>
<tr class="separator:aafea81a4f90173d98b5d683f3508f936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memItemLeft" align="right" valign="top"><a id="a04cb5ddf90e2e0870e7fe5604b316c51" name="a04cb5ddf90e2e0870e7fe5604b316c51"></a>
const std::vector&lt; <a class="el" href="classResidue.html">Residue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidues</b> () const</td></tr>
<tr class="memdesc:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list with all the residues loaded into this Forcefield. <br /></td></tr>
<tr class="separator:a04cb5ddf90e2e0870e7fe5604b316c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720bf8a957e4d00740c2d353b8be1181"><td class="memItemLeft" align="right" valign="top"><a id="a720bf8a957e4d00740c2d353b8be1181" name="a720bf8a957e4d00740c2d353b8be1181"></a>
const <a class="el" href="classResidue.html">Residue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getResidue</b> (const std::string &amp;rname) const</td></tr>
<tr class="memdesc:a720bf8a957e4d00740c2d353b8be1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classResidue.html">Residue</a> from those loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. <br /></td></tr>
<tr class="separator:a720bf8a957e4d00740c2d353b8be1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9902cf610a724e451d0f5d2a87934fa3"><td class="memItemLeft" align="right" valign="top"><a id="a9902cf610a724e451d0f5d2a87934fa3" name="a9902cf610a724e451d0f5d2a87934fa3"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategories</b> () const</td></tr>
<tr class="memdesc:a9902cf610a724e451d0f5d2a87934fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all Categories loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a9902cf610a724e451d0f5d2a87934fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c830622f775f42f2b8e38afb2f4c3"><td class="memItemLeft" align="right" valign="top"><a id="a942c830622f775f42f2b8e38afb2f4c3" name="a942c830622f775f42f2b8e38afb2f4c3"></a>
const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypes</b> () const</td></tr>
<tr class="memdesc:a942c830622f775f42f2b8e38afb2f4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the atom-types (as <a class="el" href="classAtom.html">Atom</a> object pointers) loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:a942c830622f775f42f2b8e38afb2f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71608edab6564b721aa4b77739a82fc4"><td class="memItemLeft" align="right" valign="top"><a id="a71608edab6564b721aa4b77739a82fc4" name="a71608edab6564b721aa4b77739a82fc4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (<a class="el" href="classAtom.html">Atom</a> *a)</td></tr>
<tr class="memdesc:a71608edab6564b721aa4b77739a82fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a71608edab6564b721aa4b77739a82fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afad3eec7b365936072675c74e4d185"><td class="memItemLeft" align="right" valign="top"><a id="a8afad3eec7b365936072675c74e4d185" name="a8afad3eec7b365936072675c74e4d185"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultConnectivity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8afad3eec7b365936072675c74e4d185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defaualt connectivity (not from forcefield data) for a given element. <br /></td></tr>
<tr class="separator:a8afad3eec7b365936072675c74e4d185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0393adb6d13dfa912934c4fce143a94"><td class="memItemLeft" align="right" valign="top"><a id="ae0393adb6d13dfa912934c4fce143a94" name="ae0393adb6d13dfa912934c4fce143a94"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getElectronegativity</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae0393adb6d13dfa912934c4fce143a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get electronegativity data for a given element - experimental. If the data is not available, the user is prompted to enter it after which is is stored for that run. <br /></td></tr>
<tr class="separator:ae0393adb6d13dfa912934c4fce143a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350fc55fa7f24176462228adeb4dd59d"><td class="memItemLeft" align="right" valign="top"><a id="a350fc55fa7f24176462228adeb4dd59d" name="a350fc55fa7f24176462228adeb4dd59d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadCategories</b> (const std::string &amp;catf)</td></tr>
<tr class="memdesc:a350fc55fa7f24176462228adeb4dd59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load categories from an external file into this forcefield. Categories can also be loaded when the <a class="el" href="classForceField.html">ForceField</a> object is created (See: <a class="el" href="classForceField.html#aafea81a4f90173d98b5d683f3508f936" title="Load the forcefield from the standard ffin format, and categories from a categories file....">ForceField(const std::string&amp;,const std::string&amp;)</a>) <br /></td></tr>
<tr class="separator:a350fc55fa7f24176462228adeb4dd59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741f547e37b13db02b1316d92b45c164"><td class="memItemLeft" align="right" valign="top"><a id="a741f547e37b13db02b1316d92b45c164" name="a741f547e37b13db02b1316d92b45c164"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadChargeGroups</b> (const std::string &amp;chgfile)</td></tr>
<tr class="memdesc:a741f547e37b13db02b1316d92b45c164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load formal charges from a data file. <br /></td></tr>
<tr class="separator:a741f547e37b13db02b1316d92b45c164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95480a4783499ac5ed4743e6c6ab871d"><td class="memItemLeft" align="right" valign="top"><a id="a95480a4783499ac5ed4743e6c6ab871d" name="a95480a4783499ac5ed4743e6c6ab871d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadRules</b> (const std::string &amp;fl)</td></tr>
<tr class="memdesc:a95480a4783499ac5ed4743e6c6ab871d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load rules from a given file. See the atom-type definition section of documentation PDF for more details on format. <br /></td></tr>
<tr class="separator:a95480a4783499ac5ed4743e6c6ab871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">getRules</a> () const</td></tr>
<tr class="memdesc:ac4e6c7a3139b39b1f286a00f53526f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of all the rules loaded into this forcefield.  <a href="classForceField.html#ac4e6c7a3139b39b1f286a00f53526f57">More...</a><br /></td></tr>
<tr class="separator:ac4e6c7a3139b39b1f286a00f53526f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3af3130879593384a4faedf21d7fca"><td class="memItemLeft" align="right" valign="top"><a id="a4e3af3130879593384a4faedf21d7fca" name="a4e3af3130879593384a4faedf21d7fca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasRule</b> (const std::string &amp;tp) const</td></tr>
<tr class="memdesc:a4e3af3130879593384a4faedf21d7fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are any rules defined on a given atom-type. <br /></td></tr>
<tr class="separator:a4e3af3130879593384a4faedf21d7fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bfc00e94bac57310cc3a4778e11342"><td class="memItemLeft" align="right" valign="top"><a id="ab5bfc00e94bac57310cc3a4778e11342" name="ab5bfc00e94bac57310cc3a4778e11342"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ab5bfc00e94bac57310cc3a4778e11342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given <a class="el" href="classCategory.html">Category</a> is present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. <br /></td></tr>
<tr class="separator:ab5bfc00e94bac57310cc3a4778e11342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memItemLeft" align="right" valign="top"><a id="a5a30c5a7760b5c791c5b34f9bd133506" name="a5a30c5a7760b5c791c5b34f9bd133506"></a>
const <a class="el" href="classCategory.html">Category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCategory</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a5a30c5a7760b5c791c5b34f9bd133506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the chosen <a class="el" href="classCategory.html">Category</a> by name if present in the list loaded into this <a class="el" href="classForceField.html">ForceField</a>. If there is no <a class="el" href="classCategory.html">Category</a> with this name, <a class="el" href="classNoSuchCategoryException.html">NoSuchCategoryException</a> is thrown. <br /></td></tr>
<tr class="separator:a5a30c5a7760b5c791c5b34f9bd133506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memItemLeft" align="right" valign="top"><a id="a365a885eb6f7bc1b154ac2e3c1a0e71e" name="a365a885eb6f7bc1b154ac2e3c1a0e71e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd) const</td></tr>
<tr class="memdesc:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined (See Rule::satisfies(Atom*,Molecule*,const ForceField*)) <br /></td></tr>
<tr class="separator:a365a885eb6f7bc1b154ac2e3c1a0e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7652c528231e7e76f85b4c0d54ccf249"><td class="memItemLeft" align="right" valign="top"><a id="a7652c528231e7e76f85b4c0d54ccf249" name="a7652c528231e7e76f85b4c0d54ccf249"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSatisfied</b> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *n, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd) const</td></tr>
<tr class="memdesc:a7652c528231e7e76f85b4c0d54ccf249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> to check if an atom (with the bonds supplied) satisfies all atom-type rules as defined given that an extra bond is formed to the new atom 'n' supplied (See Rule::satisfies(Atom*,Atom*,Molecule*)) <br /></td></tr>
<tr class="separator:a7652c528231e7e76f85b4c0d54ccf249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e3f80e59286f915299e61341d078f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a388e3f80e59286f915299e61341d078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name.  <a href="classForceField.html#a388e3f80e59286f915299e61341d078f">More...</a><br /></td></tr>
<tr class="separator:a388e3f80e59286f915299e61341d078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memItemLeft" align="right" valign="top"><a id="aaa160c8cf0174cb4117d9eb1bc8ace54" name="aaa160c8cf0174cb4117d9eb1bc8ace54"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAtom(const std::string&amp;) but uses an <a class="el" href="classAtom.html">Atom</a> object pointer instead of a string to get the atom-type name. <br /></td></tr>
<tr class="separator:aaa160c8cf0174cb4117d9eb1bc8ace54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memItemLeft" align="right" valign="top"><a id="a2be69fc1bd6346deab02dea6f67d7a45" name="a2be69fc1bd6346deab02dea6f67d7a45"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> () const</td></tr>
<tr class="memdesc:a2be69fc1bd6346deab02dea6f67d7a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded atom-types. <br /></td></tr>
<tr class="separator:a2be69fc1bd6346deab02dea6f67d7a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memItemLeft" align="right" valign="top"><a id="a8328f9fbf5155ffaebfc14543d59d82c" name="a8328f9fbf5155ffaebfc14543d59d82c"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> () const</td></tr>
<tr class="memdesc:a8328f9fbf5155ffaebfc14543d59d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly get a copy of any of the loaded <b>non-hydrogen</b> atom-types. <br /></td></tr>
<tr class="separator:a8328f9fbf5155ffaebfc14543d59d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01147c118b08eee9b7c2d138275c19"><td class="memItemLeft" align="right" valign="top"><a id="a8d01147c118b08eee9b7c2d138275c19" name="a8d01147c118b08eee9b7c2d138275c19"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a8d01147c118b08eee9b7c2d138275c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a2be69fc1bd6346deab02dea6f67d7a45" title="Randomly get a copy of any of the loaded atom-types.">getRandomAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a8d01147c118b08eee9b7c2d138275c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f60e9f58a6f6694e27398d50afa39d"><td class="memItemLeft" align="right" valign="top"><a id="a67f60e9f58a6f6694e27398d50afa39d" name="a67f60e9f58a6f6694e27398d50afa39d"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomNonHAtomByType</b> (double x, double y, double z) const</td></tr>
<tr class="memdesc:a67f60e9f58a6f6694e27398d50afa39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classForceField.html#a8328f9fbf5155ffaebfc14543d59d82c" title="Randomly get a copy of any of the loaded non-hydrogen atom-types.">getRandomNonHAtomByType()</a> except that it also assignes the position to the atom at creation-time. <br /></td></tr>
<tr class="separator:a67f60e9f58a6f6694e27398d50afa39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memItemLeft" align="right" valign="top"><a id="ab799403bbacf06c7aa5215d8a4c9ccf9" name="ab799403bbacf06c7aa5215d8a4c9ccf9"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (const std::string &amp;s, double x, double y, double z) const</td></tr>
<tr class="memdesc:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an atom of a specific atom-type at a specified position. <br /></td></tr>
<tr class="separator:ab799403bbacf06c7aa5215d8a4c9ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memItemLeft" align="right" valign="top"><a id="a3c095b464ce6ba8f0eea33fb0c7ffa6b" name="a3c095b464ce6ba8f0eea33fb0c7ffa6b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getElementName</b> (const std::string &amp;el) const</td></tr>
<tr class="memdesc:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element name (symbol) corresponding to a given atom-type. <br /></td></tr>
<tr class="separator:a3c095b464ce6ba8f0eea33fb0c7ffa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1831e6acc1949a3abd0a762235f145"><td class="memItemLeft" align="right" valign="top"><a id="abe1831e6acc1949a3abd0a762235f145" name="abe1831e6acc1949a3abd0a762235f145"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getAtomTypesByElement</b> (const std::string &amp;el)</td></tr>
<tr class="memdesc:abe1831e6acc1949a3abd0a762235f145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all atom-types corresponding to a given element. <br /></td></tr>
<tr class="separator:abe1831e6acc1949a3abd0a762235f145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0676e821612c47f3675c790cac28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a95d0676e821612c47f3675c790cac28a">selectRandomBondableAtom</a> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *bias=nullptr) const</td></tr>
<tr class="memdesc:a95d0676e821612c47f3675c790cac28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random atom that can bond to this atom but bias the output.  <a href="classForceField.html#a95d0676e821612c47f3675c790cac28a">More...</a><br /></td></tr>
<tr class="separator:a95d0676e821612c47f3675c790cac28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab183018c1dce0c5c93e1dd36eccd57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#aab183018c1dce0c5c93e1dd36eccd57e">selectRandomBondableAtomTerminal</a> (<a class="el" href="classAtom.html">Atom</a> *a, <a class="el" href="classAtom.html">Atom</a> *bias=nullptr) const</td></tr>
<tr class="memdesc:aab183018c1dce0c5c93e1dd36eccd57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random terminal atom that can bond to this atom but bias the output.  <a href="classForceField.html#aab183018c1dce0c5c93e1dd36eccd57e">More...</a><br /></td></tr>
<tr class="separator:aab183018c1dce0c5c93e1dd36eccd57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916b6f2de77e5c712e9e3404d7862a1a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">listAtomsByRule</a> (<a class="el" href="classAtom.html">Atom</a> *s, <a class="el" href="classMolecule.html">Molecule</a> *m, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a916b6f2de77e5c712e9e3404d7862a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Situationally list atoms that can bond to the selected atom.  <a href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">More...</a><br /></td></tr>
<tr class="separator:a916b6f2de77e5c712e9e3404d7862a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce8512467099140749410ca10298b0"><td class="memItemLeft" align="right" valign="top"><a id="aacce8512467099140749410ca10298b0" name="aacce8512467099140749410ca10298b0"></a>
std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>listAtomsByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:aacce8512467099140749410ca10298b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as listAtomsByRule(Atom*,Molecule*,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:aacce8512467099140749410ca10298b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1374c20d8953dac1cd300417aba041c5"><td class="memItemLeft" align="right" valign="top"><a id="a1374c20d8953dac1cd300417aba041c5" name="a1374c20d8953dac1cd300417aba041c5"></a>
<a class="el" href="classAtom.html">Atom</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>selectAtomByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a1374c20d8953dac1cd300417aba041c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as selectAtomByRule(Atom*,Molecule*,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:a1374c20d8953dac1cd300417aba041c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629cd1dff57f199e0e836e00792101b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">listFragmentsByRule</a> (<a class="el" href="classAtom.html">Atom</a> *src, <a class="el" href="classMolecule.html">Molecule</a> *m, const FragmentSet &amp;frags, <a class="el" href="classAtom.html">Atom</a> *exa=nullptr, int devid=0) const</td></tr>
<tr class="memdesc:a629cd1dff57f199e0e836e00792101b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all possible a <b>fragments</b> that can bond to a given atom (following bonding rules).  <a href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">More...</a><br /></td></tr>
<tr class="separator:a629cd1dff57f199e0e836e00792101b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd448a8dfcb86280c02164fa14bc81"><td class="memItemLeft" align="right" valign="top"><a id="acfbd448a8dfcb86280c02164fa14bc81" name="acfbd448a8dfcb86280c02164fa14bc81"></a>
std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>listFragmentsByRule</b> (<a class="el" href="classAtom.html">Atom</a> *src, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, const FragmentSet &amp;frags, <a class="el" href="classAtom.html">Atom</a> *exa=nullptr, int devid=0) const</td></tr>
<tr class="memdesc:acfbd448a8dfcb86280c02164fa14bc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as listFragmentsByRule(Atom*,Molecule*,const FragmentSet&amp;,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:acfbd448a8dfcb86280c02164fa14bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b2cef43160cbdaf59142befd06f8cc"><td class="memItemLeft" align="right" valign="top"><a id="a31b2cef43160cbdaf59142befd06f8cc" name="a31b2cef43160cbdaf59142befd06f8cc"></a>
std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>selectFragmentByRule</b> (<a class="el" href="classAtom.html">Atom</a> *s, const std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &amp;bnd, const FragmentSet &amp;fs, <a class="el" href="classAtom.html">Atom</a> *temp=nullptr) const</td></tr>
<tr class="memdesc:a31b2cef43160cbdaf59142befd06f8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as selectFragmentByRule(Atom*,Molecule*,const FragmentSet&amp;,Atom*), but directly uses the list of bonded atoms instead of collecting them from the <a class="el" href="classMolecule.html">Molecule</a> object. <br /></td></tr>
<tr class="separator:a31b2cef43160cbdaf59142befd06f8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">acceptNewBond</a> (<a class="el" href="classAtom.html">Atom</a> *src, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; bnd, <a class="el" href="classAtom.html">Atom</a> *n) const</td></tr>
<tr class="memdesc:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions.  <a href="classForceField.html#a189f02b2df1f09bba1beae4bc3aa72cf">More...</a><br /></td></tr>
<tr class="separator:a189f02b2df1f09bba1beae4bc3aa72cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memItemLeft" align="right" valign="top"><a id="afb97cc6d011ec0f5d5b78a3f2bd0a94d" name="afb97cc6d011ec0f5d5b78a3f2bd0a94d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See contains(std::string) <br /></td></tr>
<tr class="separator:afb97cc6d011ec0f5d5b78a3f2bd0a94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memItemLeft" align="right" valign="top"><a id="a0c0ab714e289a47ea4a30cf6701ce6cd" name="a0c0ab714e289a47ea4a30cf6701ce6cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (std::string str) const</td></tr>
<tr class="memdesc:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checkes if this <a class="el" href="classForceField.html">ForceField</a> has an atom-type with the given name. <br /></td></tr>
<tr class="separator:a0c0ab714e289a47ea4a30cf6701ce6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memItemLeft" align="right" valign="top"><a id="a40426986b9cd4c8fbabcb3cd0fb2ecb7" name="a40426986b9cd4c8fbabcb3cd0fb2ecb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> ()</td></tr>
<tr class="memdesc:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write valency, σ, and ε of all the atom-types to stdout. <br /></td></tr>
<tr class="separator:a40426986b9cd4c8fbabcb3cd0fb2ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a> (<a class="el" href="classAtom.html">Atom</a> *a) const</td></tr>
<tr class="memdesc:a11ef1ec5670fc1755a3ad4618d63d734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make.  <a href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">More...</a><br /></td></tr>
<tr class="separator:a11ef1ec5670fc1755a3ad4618d63d734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ddc7dd89f688b86adba44834fc45a4"><td class="memItemLeft" align="right" valign="top"><a id="a32ddc7dd89f688b86adba44834fc45a4" name="a32ddc7dd89f688b86adba44834fc45a4"></a>
const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAllowedBonds</b> (const std::string &amp;temp) const</td></tr>
<tr class="memdesc:a32ddc7dd89f688b86adba44834fc45a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAllowedBonds(Atom*), but provides the atom-type by name (as std::string) <br /></td></tr>
<tr class="separator:a32ddc7dd89f688b86adba44834fc45a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5244bfbdfed05f3dd715a0a0356400"><td class="memItemLeft" align="right" valign="top"><a id="a4d5244bfbdfed05f3dd715a0a0356400" name="a4d5244bfbdfed05f3dd715a0a0356400"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadLengths</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a4d5244bfbdfed05f3dd715a0a0356400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-length data from a given file. <br /></td></tr>
<tr class="separator:a4d5244bfbdfed05f3dd715a0a0356400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c607a224f64dae5fd2ba9500c7a889"><td class="memItemLeft" align="right" valign="top"><a id="a56c607a224f64dae5fd2ba9500c7a889" name="a56c607a224f64dae5fd2ba9500c7a889"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadAngles</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a56c607a224f64dae5fd2ba9500c7a889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load bond-angle data from a given file. <br /></td></tr>
<tr class="separator:a56c607a224f64dae5fd2ba9500c7a889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9339a06dc0064de241a3ddc03db712d"><td class="memItemLeft" align="right" valign="top"><a id="ae9339a06dc0064de241a3ddc03db712d" name="ae9339a06dc0064de241a3ddc03db712d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadDihedrals</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ae9339a06dc0064de241a3ddc03db712d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load dihedral data from a given file. <br /></td></tr>
<tr class="separator:ae9339a06dc0064de241a3ddc03db712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4871a728498d1cd28e5cfc2130b99a53"><td class="memItemLeft" align="right" valign="top"><a id="a4871a728498d1cd28e5cfc2130b99a53" name="a4871a728498d1cd28e5cfc2130b99a53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadImpropers</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a4871a728498d1cd28e5cfc2130b99a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load improper dihedral data from a given file (not used in later versions of DeNovo) <br /></td></tr>
<tr class="separator:a4871a728498d1cd28e5cfc2130b99a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30de07cb95485f78dc1ae64eec9562"><td class="memItemLeft" align="right" valign="top"><a id="a3a30de07cb95485f78dc1ae64eec9562" name="a3a30de07cb95485f78dc1ae64eec9562"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadBondParameters</b> (std::string lengthfn=LengthDataFile, std::string anglefn=AngleDataFile, std::string dihedralfn=DihedralDataFile, std::string improperfn=ImproperDataFile)</td></tr>
<tr class="memdesc:a3a30de07cb95485f78dc1ae64eec9562"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to load all parameters (bond-length,bond-angle,dihedral,and improper-dihedral). See documentation (PDF) for default filenames. <br /></td></tr>
<tr class="separator:a3a30de07cb95485f78dc1ae64eec9562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memItemLeft" align="right" valign="top"><a id="a19cb372462ff31cda4096ae2d20ee1d4" name="a19cb372462ff31cda4096ae2d20ee1d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOneFourParameters</b> (const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a19cb372462ff31cda4096ae2d20ee1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load one-four interaction parameters from a given file. Later versions of DeNovo directly use the parameters from the atom-type data. <br /></td></tr>
<tr class="separator:a19cb372462ff31cda4096ae2d20ee1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa1bfbe7d28409e5770952907a2de9"><td class="memItemLeft" align="right" valign="top"><a id="a02aa1bfbe7d28409e5770952907a2de9" name="a02aa1bfbe7d28409e5770952907a2de9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadOtherInteractions</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a02aa1bfbe7d28409e5770952907a2de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load L-J parameters from a given file. Later versions of DeNovo use the <a class="el" href="classAtom.html">Atom</a> object for parameters directly. <br /></td></tr>
<tr class="separator:a02aa1bfbe7d28409e5770952907a2de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memItemLeft" align="right" valign="top"><a id="afcc0a1b1e130d9a590a8dcffa597859f" name="afcc0a1b1e130d9a590a8dcffa597859f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loadNonbondedInteractions</b> (const std::string &amp;onefourfile=OneFourFile, const std::string &amp;otherfile=OtherInterFile)</td></tr>
<tr class="memdesc:afcc0a1b1e130d9a590a8dcffa597859f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 1-4 non-bonding potential parameters, as well as L-J potential parameters. <br /></td></tr>
<tr class="separator:afcc0a1b1e130d9a590a8dcffa597859f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19cd0db1e679daf537e06ef3308f721"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">getBondLength</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool silent=false) const</td></tr>
<tr class="memdesc:ab19cd0db1e679daf537e06ef3308f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond length for the bond between two atom types.  <a href="classForceField.html#ab19cd0db1e679daf537e06ef3308f721">More...</a><br /></td></tr>
<tr class="separator:ab19cd0db1e679daf537e06ef3308f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b8d029b748fb56265d4ee5cce2873"><td class="memItemLeft" align="right" valign="top"><a id="a084b8d029b748fb56265d4ee5cce2873" name="a084b8d029b748fb56265d4ee5cce2873"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::string &amp;a1, const string &amp;a2, bool silent=false) const</td></tr>
<tr class="memdesc:a084b8d029b748fb56265d4ee5cce2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a084b8d029b748fb56265d4ee5cce2873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af019ff49e9086043b31c27fa9fae11ae"><td class="memItemLeft" align="right" valign="top"><a id="af019ff49e9086043b31c27fa9fae11ae" name="af019ff49e9086043b31c27fa9fae11ae"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::vector&lt; std::string &gt; &amp;sv, bool silent=false) const</td></tr>
<tr class="memdesc:af019ff49e9086043b31c27fa9fae11ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string lists instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af019ff49e9086043b31c27fa9fae11ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memItemLeft" align="right" valign="top"><a id="ad1b08a30e9e807ef4e7f52cd8cfc836e" name="ad1b08a30e9e807ef4e7f52cd8cfc836e"></a>
std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLengthParameters</b> (const std::pair&lt; std::string, std::string &gt; &amp;atp, bool silent=false) const</td></tr>
<tr class="memdesc:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getLengthParameters(Atom*,Atom*,bool) using string pairs instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:ad1b08a30e9e807ef4e7f52cd8cfc836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b06865581950f90f100bd04b139cf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a008b06865581950f90f100bd04b139cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types. -failsafe method.  <a href="classForceField.html#a008b06865581950f90f100bd04b139cf">More...</a><br /></td></tr>
<tr class="separator:a008b06865581950f90f100bd04b139cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memItemLeft" align="right" valign="top"><a id="aa3f2ba9fedbcb940d81f5854dfb75d21" name="aa3f2ba9fedbcb940d81f5854dfb75d21"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3) const</td></tr>
<tr class="memdesc:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa3f2ba9fedbcb940d81f5854dfb75d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memItemLeft" align="right" valign="top"><a id="a66f6acff5098b0c0165a3d4a70fa8d8a" name="a66f6acff5098b0c0165a3d4a70fa8d8a"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getAngleParamtersFailsafe</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getAngleParamtersFailsafe(Atom*,Atom*,Atom*) using a string list instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a66f6acff5098b0c0165a3d4a70fa8d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac293e6cde680b1ef64c9d337796be0a6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3) const</td></tr>
<tr class="memdesc:ac293e6cde680b1ef64c9d337796be0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bond angle for the angle between three atom types.  <a href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">More...</a><br /></td></tr>
<tr class="separator:ac293e6cde680b1ef64c9d337796be0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a54f2de7bdc1dc0b1be4060c3a8fde540">getAngleParamters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a54f2de7bdc1dc0b1be4060c3a8fde540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e27b4bf5bea870617379cdb657cefd7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4) const</td></tr>
<tr class="memdesc:a2e27b4bf5bea870617379cdb657cefd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method.  <a href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">More...</a><br /></td></tr>
<tr class="separator:a2e27b4bf5bea870617379cdb657cefd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4e9cfa168d0f0b906fc49782929d15"><td class="memItemLeft" align="right" valign="top"><a id="afd4e9cfa168d0f0b906fc49782929d15" name="afd4e9cfa168d0f0b906fc49782929d15"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDihedralParametersFailsafe</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4) const</td></tr>
<tr class="memdesc:afd4e9cfa168d0f0b906fc49782929d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getDihedralParametersFailsafe(Atom*,Atom*,Atom*,Atom*) using a strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:afd4e9cfa168d0f0b906fc49782929d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dihedral angle data for a set of four atom-types (in order of the connection chain)  <a href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">More...</a><br /></td></tr>
<tr class="separator:a6e2fcbe7169f95e62fc8e528dfa6ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a3bc80bfd10caa37d151f412d2cbe052b">getDihedralParameters</a> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="separator:a3bc80bfd10caa37d151f412d2cbe052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memItemLeft" align="right" valign="top"><a id="a546fe4a3aef3fa3928f918dd9ec490e9" name="a546fe4a3aef3fa3928f918dd9ec490e9"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</td></tr>
<tr class="memdesc:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly matches the atom-type names to the improper dihedral data and retrieves the angle. If not available <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. <br /></td></tr>
<tr class="separator:a546fe4a3aef3fa3928f918dd9ec490e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memItemLeft" align="right" valign="top"><a id="a9c18ff07f6ff1e200f8aa706ab15cebb" name="a9c18ff07f6ff1e200f8aa706ab15cebb"></a>
const std::pair&lt; double, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getImproperParameters</b> (const std::vector&lt; std::string &gt; &amp;ats) const</td></tr>
<tr class="memdesc:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for getImproperParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list. <br /></td></tr>
<tr class="separator:a9c18ff07f6ff1e200f8aa706ab15cebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memItemLeft" align="right" valign="top"><a id="a94ea10328f7d6e197a5d2b9e60d488f1" name="a94ea10328f7d6e197a5d2b9e60d488f1"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getOtherParameters</b> (const std::string &amp;s) const</td></tr>
<tr class="memdesc:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the σ and ε values for a given atom-type. <br /></td></tr>
<tr class="separator:a94ea10328f7d6e197a5d2b9e60d488f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c885b9892eb5c5f020f445bcb5853f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:a34c885b9892eb5c5f020f445bcb5853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the angle-strain potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">More...</a><br /></td></tr>
<tr class="separator:a34c885b9892eb5c5f020f445bcb5853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa188e56b9a3fb2b90fabe21f66882278"><td class="memItemLeft" align="right" valign="top"><a id="aa188e56b9a3fb2b90fabe21f66882278" name="aa188e56b9a3fb2b90fabe21f66882278"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateAngleEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, double th, double ub, bool rigid=false, double acut=THETACUT) const</td></tr>
<tr class="memdesc:aa188e56b9a3fb2b90fabe21f66882278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateAngleEnergy(Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:aa188e56b9a3fb2b90fabe21f66882278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a> (<a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3, <a class="el" href="classAtom.html">Atom</a> *a4, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dihedral potential energy (see documentation in PDF for the exact function)  <a href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">More...</a><br /></td></tr>
<tr class="separator:a1a8f2bdf6052a057b32c3e37ccc1e2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e74dd7f3607c017f12a7410e35a4f"><td class="memItemLeft" align="right" valign="top"><a id="a169e74dd7f3607c017f12a7410e35a4f" name="a169e74dd7f3607c017f12a7410e35a4f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateDihedralEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, double ph, bool rigid=false, double acut=DIHEDTHETACUT) const</td></tr>
<tr class="memdesc:a169e74dd7f3607c017f12a7410e35a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateDihedralEnergy(Atom*,Atom*,Atom*,Atom*,bool,double) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:a169e74dd7f3607c017f12a7410e35a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6feb2e505f33c5a7e51075b382f36642"><td class="memItemLeft" align="right" valign="top"><a id="a6feb2e505f33c5a7e51075b382f36642" name="a6feb2e505f33c5a7e51075b382f36642"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (<a class="el" href="classAtom.html">Atom</a> *a0, <a class="el" href="classAtom.html">Atom</a> *a1, <a class="el" href="classAtom.html">Atom</a> *a2, <a class="el" href="classAtom.html">Atom</a> *a3) const</td></tr>
<tr class="memdesc:a6feb2e505f33c5a7e51075b382f36642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate inproper dihedral energy. Not used in latest versions of DeNovo. Refer to links provided in documentation PDF. Throws <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> if data is not available. <br /></td></tr>
<tr class="separator:a6feb2e505f33c5a7e51075b382f36642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3c6c3f537052118bd081e739bfcc3"><td class="memItemLeft" align="right" valign="top"><a id="af0a3c6c3f537052118bd081e739bfcc3" name="af0a3c6c3f537052118bd081e739bfcc3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateImproperEnergy</b> (const std::string &amp;s1, const std::string &amp;s2, const std::string &amp;s3, const std::string &amp;s4, const double &amp;q) const</td></tr>
<tr class="memdesc:af0a3c6c3f537052118bd081e739bfcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate method for calculateImproperEnergy(Atom*,Atom*,Atom*,Atom*) using strings instead of <a class="el" href="classAtom.html">Atom</a> pointers. <br /></td></tr>
<tr class="separator:af0a3c6c3f537052118bd081e739bfcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0b53370d39b444980839b0b6181ee0cf"><td class="memItemLeft" align="right" valign="top"><a id="a0b53370d39b444980839b0b6181ee0cf" name="a0b53370d39b444980839b0b6181ee0cf"></a>
static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>expandMultiplicity</b> (double v, int m)</td></tr>
<tr class="memdesc:a0b53370d39b444980839b0b6181ee0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand dihedral multiplicity to explicitly write down the allowed dihedrals. See algorithm PDF (the dihedrals section, and attached links) for more details. <br /></td></tr>
<tr class="separator:a0b53370d39b444980839b0b6181ee0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53370d39b444980839b0b6181ee0cf"><td class="memItemLeft" align="right" valign="top"><a id="a0b53370d39b444980839b0b6181ee0cf" name="a0b53370d39b444980839b0b6181ee0cf"></a>
static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>expandMultiplicity</b> (double v, int m)</td></tr>
<tr class="memdesc:a0b53370d39b444980839b0b6181ee0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand dihedral multiplicity to explicitly write down the allowed dihedrals. See algorithm PDF (the dihedrals section, and attached links) for more details. <br /></td></tr>
<tr class="separator:a0b53370d39b444980839b0b6181ee0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53370d39b444980839b0b6181ee0cf"><td class="memItemLeft" align="right" valign="top"><a id="a0b53370d39b444980839b0b6181ee0cf" name="a0b53370d39b444980839b0b6181ee0cf"></a>
static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>expandMultiplicity</b> (double v, int m)</td></tr>
<tr class="memdesc:a0b53370d39b444980839b0b6181ee0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand dihedral multiplicity to explicitly write down the allowed dihedrals. See algorithm PDF (the dihedrals section, and attached links) for more details. <br /></td></tr>
<tr class="separator:a0b53370d39b444980839b0b6181ee0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53370d39b444980839b0b6181ee0cf"><td class="memItemLeft" align="right" valign="top"><a id="a0b53370d39b444980839b0b6181ee0cf" name="a0b53370d39b444980839b0b6181ee0cf"></a>
static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>expandMultiplicity</b> (double v, int m)</td></tr>
<tr class="memdesc:a0b53370d39b444980839b0b6181ee0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand dihedral multiplicity to explicitly write down the allowed dihedrals. See algorithm PDF (the dihedrals section, and attached links) for more details. <br /></td></tr>
<tr class="separator:a0b53370d39b444980839b0b6181ee0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af96ba6f982c2595b5b10199f8595f78b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#af96ba6f982c2595b5b10199f8595f78b">length_parameters</a></td></tr>
<tr class="separator:af96ba6f982c2595b5b10199f8595f78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae198b91b5ffc6278887ae798837d45e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; vector_s, vector_d &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a></td></tr>
<tr class="separator:ae198b91b5ffc6278887ae798837d45e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d02343fc1649e13677701899841679"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; vector_s, vector_d &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a></td></tr>
<tr class="separator:aa1d02343fc1649e13677701899841679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e5e64ad6163c41904507e7dac0803"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; vector_s, pair_dd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#af14e5e64ad6163c41904507e7dac0803">improper_parameters</a></td></tr>
<tr class="separator:af14e5e64ad6163c41904507e7dac0803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e6ae752fd0f03399f1f8cfdfff12f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a90e6ae752fd0f03399f1f8cfdfff12f7">atombondmap</a></td></tr>
<tr class="separator:a90e6ae752fd0f03399f1f8cfdfff12f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b05b6e971278625ec83106dc70cc1f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; pair_ss, pair_dd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a5b05b6e971278625ec83106dc70cc1f7">one_four_interactions</a></td></tr>
<tr class="separator:a5b05b6e971278625ec83106dc70cc1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b597eadca31d11346a53b49c3eb4d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, vector_d &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a19b597eadca31d11346a53b49c3eb4d4">other_interactions</a></td></tr>
<tr class="separator:a19b597eadca31d11346a53b49c3eb4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2d43f27c2cbca56da3deb919cd401d99"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a></td></tr>
<tr class="separator:a2d43f27c2cbca56da3deb919cd401d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5aeed0193bd434dbae1ed6f457a6c75"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classCategory.html">Category</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#ae5aeed0193bd434dbae1ed6f457a6c75">categories</a></td></tr>
<tr class="separator:ae5aeed0193bd434dbae1ed6f457a6c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca2da8607b87bcc0c089614a548c4fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::vector&lt; <a class="el" href="classchemtools_1_1Rule.html">chemtools::Rule</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a></td></tr>
<tr class="separator:a7ca2da8607b87bcc0c089614a548c4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f1592a6daf0ce6ed413cb936424787"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classResidue.html">Residue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a27f1592a6daf0ce6ed413cb936424787">residues</a></td></tr>
<tr class="separator:a27f1592a6daf0ce6ed413cb936424787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0c7a249011a551ed43d3abd6db2d0b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; char, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#a1c0c7a249011a551ed43d3abd6db2d0b">electronegativities</a></td></tr>
<tr class="separator:a1c0c7a249011a551ed43d3abd6db2d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af752c7414672539b59ab0815b0ca50cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; char, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a></td></tr>
<tr class="separator:af752c7414672539b59ab0815b0ca50cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This is the <a class="el" href="classForceField.html">ForceField</a> class which contains all the force-field releated parameters, such as bond-lengths, angles, dihedrals, etc. It also contains the atom-type definition rules, and user-defined categories.<br  />
 This class provides all the functions to quickly access this data by storing it in an organized format.<br  />
 Various forcefields can be loaded into DeNovo if required parameters are available. Special cases where this is not true include the "empty" forcefield and the <a class="el" href="classIncompleteForceField.html">IncompleteForceField</a><br  />
 <br  />
See the documentation PDF for details about various forcefield parameters and the way they are stored and loaded, and the different forcefields like the "empty" forcefield and the "CHARMM-27" forcefield </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00317">317</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8273c2e8667bc21edb7599c1210dda4a" name="a8273c2e8667bc21edb7599c1210dda4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8273c2e8667bc21edb7599c1210dda4a">&#9670;&nbsp;</a></span>ForceField() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForceField::ForceField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters) </p>
<p >An empty constructor which loads no parameters except default values for standard elements (such as 4 for carbon, 3 for nitrogen, etc.). It is to be called by subclass which loads the actual atom-types (such as <a class="el" href="classIncompleteForceField.html">IncompleteForceField</a>). Ensure that any class that is derived from <a class="el" href="classForceField.html">ForceField</a> and uses this constructor defines the atom-types (with proper force-field energy parameters - σ,ε,q) </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00342">342</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span>    {</div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span>        <span class="keywordflow">if</span>(!<a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.size())</div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span>        {</div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;C&#39;</span>,4));</div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;N&#39;</span>,3));</div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;O&#39;</span>,2));</div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;H&#39;</span>,1));</div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;F&#39;</span>,1));</div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;I&#39;</span>,1));</div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;P&#39;</span>,5));</div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span>            <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;S&#39;</span>,6));</div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span>        }</div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span>    }</div>
<div class="ttc" id="aclassForceField_html_af752c7414672539b59ab0815b0ca50cd"><div class="ttname"><a href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">ForceField::defaultconnectivities</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; char, int &gt; &gt; defaultconnectivities</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00325">forcefield.hpp:325</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a50040e928edbb4d694f4f2f894debba7" name="a50040e928edbb4d694f4f2f894debba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50040e928edbb4d694f4f2f894debba7">&#9670;&nbsp;</a></span>ForceField() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForceField::ForceField </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ff_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the forcefield from the standard ffin format (see PDF documentation for format details) </p>
<p >This function completely loads <b>all the required</b> parameters for the atom-types by reading data from the file. If this wasn't your requirement, or if data is not available, check the <a class="el" href="classIncompleteForceField.html">IncompleteForceField</a> class.<br  />
 This function uses the <a class="el" href="classForceField.html#ad172233c0a72e65847a7c91145bb9ab9" title="Load additional atom-types - Useful when trying to add extra atom-types for specific usage (i....">ForceField::loadAdditionalAtomTypes()</a> functionality. </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00361">361</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span>                                       :<a class="code hl_function" href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">ForceField</a>()</div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span>  {</div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span>    <a class="code hl_variable" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a>=std::vector&lt;Atom*&gt;();</div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span>        cout &lt;&lt; <span class="stringliteral">&quot;Loading Forcefield from: &quot;</span>&lt;&lt;ff_file&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span>    <a class="code hl_function" href="classForceField.html#ad172233c0a72e65847a7c91145bb9ab9">loadAdditionalAtomTypes</a>(ff_file);</div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span>    cout &lt;&lt;<span class="stringliteral">&quot;ForceField loaded! &quot;</span>&lt;&lt;<a class="code hl_variable" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a>.size()&lt;&lt;<span class="stringliteral">&quot; atom types available and have all necessary parameters.\n&quot;</span>;</div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span>  }</div>
<div class="ttc" id="aclassForceField_html_a2d43f27c2cbca56da3deb919cd401d99"><div class="ttname"><a href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">ForceField::atom_types</a></div><div class="ttdeci">std::vector&lt; Atom * &gt; atom_types</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00320">forcefield.hpp:320</a></div></div>
<div class="ttc" id="aclassForceField_html_a8273c2e8667bc21edb7599c1210dda4a"><div class="ttname"><a href="classForceField.html#a8273c2e8667bc21edb7599c1210dda4a">ForceField::ForceField</a></div><div class="ttdeci">ForceField()</div><div class="ttdoc">Blank constructor for ForceField (does not load any force-field parameters)</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00342">forcefield.hpp:342</a></div></div>
<div class="ttc" id="aclassForceField_html_ad172233c0a72e65847a7c91145bb9ab9"><div class="ttname"><a href="classForceField.html#ad172233c0a72e65847a7c91145bb9ab9">ForceField::loadAdditionalAtomTypes</a></div><div class="ttdeci">void loadAdditionalAtomTypes(const std::string &amp;ff_file)</div><div class="ttdoc">Load additional atom-types - Useful when trying to add extra atom-types for specific usage (i....</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00413">forcefield.hpp:413</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8273c2e8667bc21edb7599c1210dda4a" name="a8273c2e8667bc21edb7599c1210dda4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8273c2e8667bc21edb7599c1210dda4a">&#9670;&nbsp;</a></span>ForceField() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForceField::ForceField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters) </p>
<p >An empty constructor which loads no parameters except default values for standard elements (such as 4 for carbon, 3 for nitrogen, etc.). It is to be called by subclass which loads the actual atom-types (such as <a class="el" href="classIncompleteForceField.html">IncompleteForceField</a>). Ensure that any class that is derived from <a class="el" href="classForceField.html">ForceField</a> and uses this constructor defines the atom-types (with proper force-field energy parameters - σ,ε,q) </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00331">331</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>    {</div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;C&#39;</span>,4));</div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;N&#39;</span>,3));</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;O&#39;</span>,2));</div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;H&#39;</span>,1));</div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;F&#39;</span>,1));</div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;I&#39;</span>,1));</div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;P&#39;</span>,5));</div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;S&#39;</span>,6));</div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8273c2e8667bc21edb7599c1210dda4a" name="a8273c2e8667bc21edb7599c1210dda4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8273c2e8667bc21edb7599c1210dda4a">&#9670;&nbsp;</a></span>ForceField() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForceField::ForceField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters) </p>
<p >An empty constructor which loads no parameters except default values for standard elements (such as 4 for carbon, 3 for nitrogen, etc.). It is to be called by subclass which loads the actual atom-types (such as <a class="el" href="classIncompleteForceField.html">IncompleteForceField</a>). Ensure that any class that is derived from <a class="el" href="classForceField.html">ForceField</a> and uses this constructor defines the atom-types (with proper force-field energy parameters - σ,ε,q) </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00325">325</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span>    {</div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;C&#39;</span>,4));</div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;N&#39;</span>,3));</div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;O&#39;</span>,2));</div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;H&#39;</span>,1));</div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;F&#39;</span>,1));</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;I&#39;</span>,1));</div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;P&#39;</span>,5));</div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;S&#39;</span>,6));</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8273c2e8667bc21edb7599c1210dda4a" name="a8273c2e8667bc21edb7599c1210dda4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8273c2e8667bc21edb7599c1210dda4a">&#9670;&nbsp;</a></span>ForceField() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ForceField::ForceField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blank constructor for <a class="el" href="classForceField.html">ForceField</a> (does not load any force-field parameters) </p>
<p >An empty constructor which loads no parameters except default values for standard elements (such as 4 for carbon, 3 for nitrogen, etc.). It is to be called by subclass which loads the actual atom-types (such as <a class="el" href="classIncompleteForceField.html">IncompleteForceField</a>). Ensure that any class that is derived from <a class="el" href="classForceField.html">ForceField</a> and uses this constructor defines the atom-types (with proper force-field energy parameters - σ,ε,q) </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00329">329</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span>    {</div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;C&#39;</span>,4));</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;N&#39;</span>,3));</div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;O&#39;</span>,2));</div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;H&#39;</span>,1));</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;F&#39;</span>,1));</div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;I&#39;</span>,1));</div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;P&#39;</span>,5));</div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span>        <a class="code hl_variable" href="classForceField.html#af752c7414672539b59ab0815b0ca50cd">defaultconnectivities</a>.push_back(make_pair(<span class="charliteral">&#39;S&#39;</span>,6));</div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a189f02b2df1f09bba1beae4bc3aa72cf" name="a189f02b2df1f09bba1beae4bc3aa72cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189f02b2df1f09bba1beae4bc3aa72cf">&#9670;&nbsp;</a></span>acceptNewBond() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ForceField::acceptNewBond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions. </p>
<p >This function is similar to selectAtomByRule(), except instead of providing the atom to be chosen, it checks if the chosen atom satisfies the required definitions.<br  />
 It is used when checking for cyclization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source atom on which the check must be performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bnd</td><td>The list of all atoms already bonded to src </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The new atom being trialled for bonding to src </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00742">742</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span>    {</div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span>        <span class="keywordflow">if</span>(!<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>.size()) cout &lt;&lt; <span class="stringliteral">&quot;WARN: Ruleset not loaded?\n&quot;</span>;</div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span>        std::vector&lt;chemtools::Rule&gt; ruleset;</div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span>        <span class="keywordflow">try</span></div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span>        {</div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span>            ruleset=findByKey(<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>,src-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());</div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span>            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;ruleset.size();i++)</div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span>            {</div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span>                <span class="keywordflow">if</span>(ruleset[i].satisfies(src,n,bnd)) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span>                <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span>            }</div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span>        }</div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span>        <span class="keywordflow">catch</span>(<a class="code hl_class" href="classElementNotFoundException.html">ElementNotFoundException</a> ex) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}</div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span>    }</div>
<div class="ttc" id="aclassAtom_html_a189def3b8bade8507d49cfd7de881178"><div class="ttname"><a href="classAtom.html#a189def3b8bade8507d49cfd7de881178">Atom::toString</a></div><div class="ttdeci">const std::string &amp; toString() const</div><div class="ttdoc">Gives the atom name for this atom.</div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00110">Atom.hpp:110</a></div></div>
<div class="ttc" id="aclassElementNotFoundException_html"><div class="ttname"><a href="classElementNotFoundException.html">ElementNotFoundException</a></div><div class="ttdef"><b>Definition:</b> <a href="commons_8h_source.html#l00021">commons.h:21</a></div></div>
<div class="ttc" id="aclassForceField_html_a7ca2da8607b87bcc0c089614a548c4fa"><div class="ttname"><a href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">ForceField::rules</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; std::string, std::vector&lt; chemtools::Rule &gt; &gt; &gt; rules</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00322">forcefield.hpp:322</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a189f02b2df1f09bba1beae4bc3aa72cf" name="a189f02b2df1f09bba1beae4bc3aa72cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189f02b2df1f09bba1beae4bc3aa72cf">&#9670;&nbsp;</a></span>acceptNewBond() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ForceField::acceptNewBond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions. </p>
<p >This function is similar to selectAtomByRule(), except instead of providing the atom to be chosen, it checks if the chosen atom satisfies the required definitions.<br  />
 It is used when checking for cyclization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source atom on which the check must be performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bnd</td><td>The list of all atoms already bonded to src </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The new atom being trialled for bonding to src </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00675">675</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span>    {</div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span>        <span class="keywordflow">if</span>(!<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>.size()) cout &lt;&lt; <span class="stringliteral">&quot;WARN: Ruleset not loaded?\n&quot;</span>;</div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span>        std::vector&lt;chemtools::Rule&gt; ruleset;</div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span>        <span class="keywordflow">try</span></div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span>        {</div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span>            ruleset=findByKey(<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>,src-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());</div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span>            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;ruleset.size();i++)</div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span>            {</div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span>                <span class="keywordflow">if</span>(ruleset[i].satisfies(src,n,bnd)) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span>                <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span>            }</div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span>        }</div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span>        <span class="keywordflow">catch</span>(<a class="code hl_class" href="classElementNotFoundException.html">ElementNotFoundException</a> ex) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}</div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a189f02b2df1f09bba1beae4bc3aa72cf" name="a189f02b2df1f09bba1beae4bc3aa72cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189f02b2df1f09bba1beae4bc3aa72cf">&#9670;&nbsp;</a></span>acceptNewBond() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ForceField::acceptNewBond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions. </p>
<p >This function is similar to selectAtomByRule(), except instead of providing the atom to be chosen, it checks if the chosen atom satisfies the required definitions.<br  />
 It is used when checking for cyclization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source atom on which the check must be performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bnd</td><td>The list of all atoms already bonded to src </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The new atom being trialled for bonding to src </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00579">579</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span>    {</div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span>        <span class="keywordflow">if</span>(!<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>.size()) cout &lt;&lt; <span class="stringliteral">&quot;WARN: Ruleset not loaded?\n&quot;</span>;</div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span>        std::vector&lt;chemtools::Rule&gt; ruleset;</div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span>        <span class="keywordflow">try</span></div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span>        {</div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span>            ruleset=findByKey(<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>,src-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());</div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;ruleset.size();i++)</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span>            {</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span>                <span class="keywordflow">if</span>(ruleset[i].satisfies(src,n,bnd)) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span>                <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span>            }</div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span>        }</div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span>        <span class="keywordflow">catch</span>(<a class="code hl_class" href="classElementNotFoundException.html">ElementNotFoundException</a> ex) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}</div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a189f02b2df1f09bba1beae4bc3aa72cf" name="a189f02b2df1f09bba1beae4bc3aa72cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189f02b2df1f09bba1beae4bc3aa72cf">&#9670;&nbsp;</a></span>acceptNewBond() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ForceField::acceptNewBond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt;&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether accepting a particular atom to bond to a source atom is allowed accornding to atom-type definitions. </p>
<p >This function is similar to selectAtomByRule(), except instead of providing the atom to be chosen, it checks if the chosen atom satisfies the required definitions.<br  />
 It is used when checking for cyclization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source atom on which the check must be performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bnd</td><td>The list of all atoms already bonded to src </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The new atom being trialled for bonding to src </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00673">673</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span>    {</div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span>        <span class="keywordflow">if</span>(!<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>.size()) cout &lt;&lt; <span class="stringliteral">&quot;WARN: Ruleset not loaded?\n&quot;</span>;</div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span>        std::vector&lt;chemtools::Rule&gt; ruleset;</div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span>        <span class="keywordflow">try</span></div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span>        {</div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span>            ruleset=findByKey(<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>,src-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());</div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span>            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;ruleset.size();i++)</div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span>            {</div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span>                <span class="keywordflow">if</span>(ruleset[i].satisfies(src,n,bnd)) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span>                <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span>            }</div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span>        }</div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span>        <span class="keywordflow">catch</span>(<a class="code hl_class" href="classElementNotFoundException.html">ElementNotFoundException</a> ex) {<span class="keywordflow">return</span> <span class="keyword">true</span>;}</div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34c885b9892eb5c5f020f445bcb5853f" name="a34c885b9892eb5c5f020f445bcb5853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c885b9892eb5c5f020f445bcb5853f">&#9670;&nbsp;</a></span>calculateAngleEnergy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateAngleEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>THETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the angle-strain potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from angle parameters (including Urey-Bradley contribution - See PDF)<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The angle tolerance value. The default tolerance is THETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l01028">1028</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l01029" name="l01029"></a><span class="lineno"> 1029</span>  {</div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span>        <span class="keywordtype">double</span> cv=(((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())))/(sqrt(pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2))*sqrt(pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2)));</div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span>        <span class="keywordtype">double</span> th=0;</div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"> 1032</span>        <span class="keywordflow">if</span>(cv&gt;=1) th=0;</div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(cv&lt;=-1) th=PI;</div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span>    <span class="keywordflow">else</span> th=acos(cv);</div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a>(a0-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),th,a2-&gt;<a class="code hl_function" href="classAtom.html#afcdbf1522c343bb461c566416305aab6">distanceFrom</a>(a0),rigid,acut);</div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span>  }</div>
<div class="ttc" id="aclassAtom_html_a0b7e17f3d4bf6503ff0b5b675074d978"><div class="ttname"><a href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">Atom::seek_z</a></div><div class="ttdeci">double seek_z() const</div><div class="ttdoc">Get the z-coordinate from the atom's position.</div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00373">Atom.hpp:373</a></div></div>
<div class="ttc" id="aclassAtom_html_a237a6c7661dd39f9b781072f7e298813"><div class="ttname"><a href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">Atom::seek_y</a></div><div class="ttdeci">double seek_y() const</div><div class="ttdoc">Get the y-coordinate from the atom's position.</div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00372">Atom.hpp:372</a></div></div>
<div class="ttc" id="aclassAtom_html_a58eafe0667e284c2439a640445d5ead1"><div class="ttname"><a href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">Atom::seek_x</a></div><div class="ttdeci">double seek_x() const</div><div class="ttdoc">Get the x-coordinate from the atom's position.</div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00371">Atom.hpp:371</a></div></div>
<div class="ttc" id="aclassAtom_html_afcdbf1522c343bb461c566416305aab6"><div class="ttname"><a href="classAtom.html#afcdbf1522c343bb461c566416305aab6">Atom::distanceFrom</a></div><div class="ttdeci">double distanceFrom(const Atom *a2) const</div><div class="ttdoc">Evaluates the distance from &quot;this&quot; atom to another.</div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00388">Atom.hpp:388</a></div></div>
<div class="ttc" id="aclassForceField_html_a34c885b9892eb5c5f020f445bcb5853f"><div class="ttname"><a href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">ForceField::calculateAngleEnergy</a></div><div class="ttdeci">double calculateAngleEnergy(Atom *a0, Atom *a1, Atom *a2, bool rigid=false, double acut=THETACUT) const</div><div class="ttdoc">Calculate the angle-strain potential energy (see documentation in PDF for the exact function)</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l01028">forcefield.hpp:1028</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a34c885b9892eb5c5f020f445bcb5853f" name="a34c885b9892eb5c5f020f445bcb5853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c885b9892eb5c5f020f445bcb5853f">&#9670;&nbsp;</a></span>calculateAngleEnergy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateAngleEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>THETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the angle-strain potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from angle parameters (including Urey-Bradley contribution - See PDF)<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The angle tolerance value. The default tolerance is THETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00940">940</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span>  {</div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span>    <span class="keywordtype">double</span> th=acos((((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())))/(sqrt(pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2))*sqrt(pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2))));</div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a>(a0-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),th,a2-&gt;<a class="code hl_function" href="classAtom.html#afcdbf1522c343bb461c566416305aab6">distanceFrom</a>(a0),rigid,acut);</div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34c885b9892eb5c5f020f445bcb5853f" name="a34c885b9892eb5c5f020f445bcb5853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c885b9892eb5c5f020f445bcb5853f">&#9670;&nbsp;</a></span>calculateAngleEnergy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateAngleEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>THETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the angle-strain potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from angle parameters (including Urey-Bradley contribution - See PDF)<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The angle tolerance value. The default tolerance is THETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00844">844</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span>  {</div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span>    <span class="keywordtype">double</span> th=acos((((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())))/(sqrt(pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2))*sqrt(pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2))));</div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a>(a0-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),th,a2-&gt;<a class="code hl_function" href="classAtom.html#afcdbf1522c343bb461c566416305aab6">distanceFrom</a>(a0),rigid,acut);</div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34c885b9892eb5c5f020f445bcb5853f" name="a34c885b9892eb5c5f020f445bcb5853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c885b9892eb5c5f020f445bcb5853f">&#9670;&nbsp;</a></span>calculateAngleEnergy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateAngleEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>THETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the angle-strain potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from angle parameters (including Urey-Bradley contribution - See PDF)<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The angle tolerance value. The default tolerance is THETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00938">938</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span>  {</div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span>    <span class="keywordtype">double</span> th=acos((((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>()))+((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>()))*((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())))/(sqrt(pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a0-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2))*sqrt(pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a58eafe0667e284c2439a640445d5ead1">seek_x</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a237a6c7661dd39f9b781072f7e298813">seek_y</a>())),2)+pow(((a2-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())-(a1-&gt;<a class="code hl_function" href="classAtom.html#a0b7e17f3d4bf6503ff0b5b675074d978">seek_z</a>())),2))));</div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a34c885b9892eb5c5f020f445bcb5853f">calculateAngleEnergy</a>(a0-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),th,a2-&gt;<a class="code hl_function" href="classAtom.html#afcdbf1522c343bb461c566416305aab6">distanceFrom</a>(a0),rigid,acut);</div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a8f2bdf6052a057b32c3e37ccc1e2f7" name="a1a8f2bdf6052a057b32c3e37ccc1e2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8f2bdf6052a057b32c3e37ccc1e2f7">&#9670;&nbsp;</a></span>calculateDihedralEnergy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateDihedralEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>DIHEDTHETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dihedral potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from dihedral parameters.<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the dihedral angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The dihedral tolerance value. The default tolerance is DIHEDTHETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l01056">1056</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span>  {</div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span>    <span class="keywordtype">double</span> phi=<a class="code hl_function" href="namespacequickgeom.html#a3a172b92f8eee792705499c271696954">quickgeom::dihedralBetween</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a2),a2-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a3),a3-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a4));</div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"> 1059</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),phi,rigid,acut);</div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"> 1060</span>  }</div>
<div class="ttc" id="aclassAtom_html_a40e4a43205a24f5e64ea0d27994a3efb"><div class="ttname"><a href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">Atom::bondVectorTo</a></div><div class="ttdeci">Eigen::Vector3d bondVectorTo(Atom *a) const</div><div class="ttdoc">Get a vector from this atom to 'a'.</div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00390">Atom.hpp:390</a></div></div>
<div class="ttc" id="aclassForceField_html_a1a8f2bdf6052a057b32c3e37ccc1e2f7"><div class="ttname"><a href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">ForceField::calculateDihedralEnergy</a></div><div class="ttdeci">double calculateDihedralEnergy(Atom *a1, Atom *a2, Atom *a3, Atom *a4, bool rigid=false, double acut=DIHEDTHETACUT) const</div><div class="ttdoc">Calculate the dihedral potential energy (see documentation in PDF for the exact function)</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l01056">forcefield.hpp:1056</a></div></div>
<div class="ttc" id="anamespacequickgeom_html_a3a172b92f8eee792705499c271696954"><div class="ttname"><a href="namespacequickgeom.html#a3a172b92f8eee792705499c271696954">quickgeom::dihedralBetween</a></div><div class="ttdeci">static double dihedralBetween(const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2, const Eigen::Vector3d &amp;v3)</div><div class="ttdoc">Given three bond vectors, calculate the dihedral angle they make.</div><div class="ttdef"><b>Definition:</b> <a href="commons_8h_source.html#l00517">commons.h:517</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a8f2bdf6052a057b32c3e37ccc1e2f7" name="a1a8f2bdf6052a057b32c3e37ccc1e2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8f2bdf6052a057b32c3e37ccc1e2f7">&#9670;&nbsp;</a></span>calculateDihedralEnergy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateDihedralEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>DIHEDTHETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dihedral potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from dihedral parameters.<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the dihedral angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The dihedral tolerance value. The default tolerance is DIHEDTHETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00964">964</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span>  {</div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>    <span class="keywordtype">double</span> phi=<a class="code hl_function" href="namespacequickgeom.html#a3a172b92f8eee792705499c271696954">quickgeom::dihedralBetween</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a2),a2-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a3),a3-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a4));</div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),phi,rigid,acut);</div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a8f2bdf6052a057b32c3e37ccc1e2f7" name="a1a8f2bdf6052a057b32c3e37ccc1e2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8f2bdf6052a057b32c3e37ccc1e2f7">&#9670;&nbsp;</a></span>calculateDihedralEnergy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateDihedralEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>DIHEDTHETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dihedral potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from dihedral parameters.<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the dihedral angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The dihedral tolerance value. The default tolerance is DIHEDTHETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00869">869</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span>  {</div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span>    <span class="keywordtype">double</span> phi=<a class="code hl_function" href="namespacequickgeom.html#a3a172b92f8eee792705499c271696954">quickgeom::dihedralBetween</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a2),a2-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a3),a3-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a4));</div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),phi,rigid,acut);</div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a8f2bdf6052a057b32c3e37ccc1e2f7" name="a1a8f2bdf6052a057b32c3e37ccc1e2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8f2bdf6052a057b32c3e37ccc1e2f7">&#9670;&nbsp;</a></span>calculateDihedralEnergy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::calculateDihedralEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rigid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acut</em> = <code>DIHEDTHETACUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dihedral potential energy (see documentation in PDF for the exact function) </p>
<p >Calculates the net energy from dihedral parameters.<br  />
This method can also be used as a boolean tolerance (with the help of the "rigid" flag) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rigid</td><td>A boolean flag. If set to true, instead of calculating the energy, the function checks if the dihedral angle value falls within a tolerance limit (acut) of the expected value. If yes, the energy is taken to be zero, otherwise it's ∞ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acut</td><td>The dihedral tolerance value. The default tolerance is DIHEDTHETACUT </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00962">962</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span>  {</div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span>    <span class="keywordtype">double</span> phi=<a class="code hl_function" href="namespacequickgeom.html#a3a172b92f8eee792705499c271696954">quickgeom::dihedralBetween</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a2),a2-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a3),a3-&gt;<a class="code hl_function" href="classAtom.html#a40e4a43205a24f5e64ea0d27994a3efb">bondVectorTo</a>(a4));</div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a1a8f2bdf6052a057b32c3e37ccc1e2f7">calculateDihedralEnergy</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),phi,rigid,acut);</div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11ef1ec5670fc1755a3ad4618d63d734" name="a11ef1ec5670fc1755a3ad4618d63d734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ef1ec5670fc1755a3ad4618d63d734">&#9670;&nbsp;</a></span>getAllowedBonds() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp; ForceField::getAllowedBonds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make. </p>
<p >Note that this is different from selectAtomByRule() which considers the atoms bonded to the source atom.<br  />
This function only provides a list of all possible bonds that this atom-type can have </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00786">786</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a-&gt;toString());}</div>
<div class="ttc" id="aclassForceField_html_a11ef1ec5670fc1755a3ad4618d63d734"><div class="ttname"><a href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">ForceField::getAllowedBonds</a></div><div class="ttdeci">const std::vector&lt; BondData &gt; &amp; getAllowedBonds(Atom *a) const</div><div class="ttdoc">Get a list of all the bonds (as BondData objects) that this atom is allowed to make.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00786">forcefield.hpp:786</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a11ef1ec5670fc1755a3ad4618d63d734" name="a11ef1ec5670fc1755a3ad4618d63d734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ef1ec5670fc1755a3ad4618d63d734">&#9670;&nbsp;</a></span>getAllowedBonds() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp; ForceField::getAllowedBonds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make. </p>
<p >Note that this is different from selectAtomByRule() which considers the atoms bonded to the source atom.<br  />
This function only provides a list of all possible bonds that this atom-type can have </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00719">719</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a-&gt;toString());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11ef1ec5670fc1755a3ad4618d63d734" name="a11ef1ec5670fc1755a3ad4618d63d734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ef1ec5670fc1755a3ad4618d63d734">&#9670;&nbsp;</a></span>getAllowedBonds() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp; ForceField::getAllowedBonds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make. </p>
<p >Note that this is different from selectAtomByRule() which considers the atoms bonded to the source atom.<br  />
This function only provides a list of all possible bonds that this atom-type can have </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00623">623</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a-&gt;toString());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11ef1ec5670fc1755a3ad4618d63d734" name="a11ef1ec5670fc1755a3ad4618d63d734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ef1ec5670fc1755a3ad4618d63d734">&#9670;&nbsp;</a></span>getAllowedBonds() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &amp; ForceField::getAllowedBonds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all the bonds (as <a class="el" href="classBondData.html">BondData</a> objects) that this atom is allowed to make. </p>
<p >Note that this is different from selectAtomByRule() which considers the atoms bonded to the source atom.<br  />
This function only provides a list of all possible bonds that this atom-type can have </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00717">717</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a-&gt;toString());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac293e6cde680b1ef64c9d337796be0a6" name="ac293e6cde680b1ef64c9d337796be0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac293e6cde680b1ef64c9d337796be0a6">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. </p>
<p >Searches the angle data for a <b>direct match</b> only (no template matching). If angle data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00905">905</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span>  {</div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3);</div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a>(atl);</div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span>  }</div>
<div class="ttc" id="aclassForceField_html_ac293e6cde680b1ef64c9d337796be0a6"><div class="ttname"><a href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">ForceField::getAngleParamters</a></div><div class="ttdeci">const std::vector&lt; double &gt; &amp; getAngleParamters(const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3) const</div><div class="ttdoc">Get the bond angle for the angle between three atom types.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00905">forcefield.hpp:905</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac293e6cde680b1ef64c9d337796be0a6" name="ac293e6cde680b1ef64c9d337796be0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac293e6cde680b1ef64c9d337796be0a6">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. </p>
<p >Searches the angle data for a <b>direct match</b> only (no template matching). If angle data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00817">817</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span>  {</div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3);</div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a>(atl);</div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac293e6cde680b1ef64c9d337796be0a6" name="ac293e6cde680b1ef64c9d337796be0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac293e6cde680b1ef64c9d337796be0a6">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. </p>
<p >Searches the angle data for a <b>direct match</b> only (no template matching). If angle data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00721">721</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span>  {</div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3);</div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a>(atl);</div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac293e6cde680b1ef64c9d337796be0a6" name="ac293e6cde680b1ef64c9d337796be0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac293e6cde680b1ef64c9d337796be0a6">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. </p>
<p >Searches the angle data for a <b>direct match</b> only (no template matching). If angle data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00815">815</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span>  {</div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3);</div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#ac293e6cde680b1ef64c9d337796be0a6">getAngleParamters</a>(atl);</div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a54f2de7bdc1dc0b1be4060c3a8fde540" name="a54f2de7bdc1dc0b1be4060c3a8fde540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f2de7bdc1dc0b1be4060c3a8fde540">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getAngleParamters(const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00911">911</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span>  {</div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span>    std::vector&lt;double&gt; par; <span class="comment">//th0,cth,ub0,cub</span></div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span>    <span class="keywordtype">int</span> lev=4;</div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span>    std::vector&lt;std::string&gt; fb1,fb2,fb3;</div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>) {<span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats)) {<span class="keywordflow">return</span> (get&lt;1&gt;(a));}}</div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span>    <span class="comment">/*if(par.size()) return par;</span></div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span><span class="comment">    else {if(fallback) return getAngleParamters(&quot;C&quot;,&quot;C&quot;,&quot;C&quot;,false); else throw DataNotAvailableException();} //Get defaults and save later*/</span></div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span>  }</div>
<div class="ttc" id="aclassDataNotAvailableException_html"><div class="ttname"><a href="classDataNotAvailableException.html">DataNotAvailableException</a></div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00013">forcefield.hpp:13</a></div></div>
<div class="ttc" id="aclassForceField_html_ae198b91b5ffc6278887ae798837d45e8"><div class="ttname"><a href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">ForceField::angle_parameters</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; vector_s, vector_d &gt; &gt; angle_parameters</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00328">forcefield.hpp:328</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a54f2de7bdc1dc0b1be4060c3a8fde540" name="a54f2de7bdc1dc0b1be4060c3a8fde540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f2de7bdc1dc0b1be4060c3a8fde540">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getAngleParamters(const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00823">823</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span>  {</div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span>    std::vector&lt;double&gt; par; <span class="comment">//th0,cth,ub0,cub</span></div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span>    <span class="keywordtype">int</span> lev=4;</div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span>    std::vector&lt;std::string&gt; fb1,fb2,fb3;</div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>) {<span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats)) {<span class="keywordflow">return</span> (get&lt;1&gt;(a));}}</div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span>    <span class="comment">/*if(par.size()) return par;</span></div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span><span class="comment">    else {if(fallback) return getAngleParamters(&quot;C&quot;,&quot;C&quot;,&quot;C&quot;,false); else throw DataNotAvailableException();} //Get defaults and save later*/</span></div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a54f2de7bdc1dc0b1be4060c3a8fde540" name="a54f2de7bdc1dc0b1be4060c3a8fde540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f2de7bdc1dc0b1be4060c3a8fde540">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getAngleParamters(const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00727">727</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span>  {</div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span>    std::vector&lt;double&gt; par; <span class="comment">//th0,cth,ub0,cub</span></div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span>    <span class="keywordtype">int</span> lev=4;</div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span>    std::vector&lt;std::string&gt; fb1,fb2,fb3;</div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>) {<span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats)) {<span class="keywordflow">return</span> (get&lt;1&gt;(a));}}</div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span>    <span class="comment">/*if(par.size()) return par;</span></div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span><span class="comment">    else {if(fallback) return getAngleParamters(&quot;C&quot;,&quot;C&quot;,&quot;C&quot;,false); else throw DataNotAvailableException();} //Get defaults and save later*/</span></div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a54f2de7bdc1dc0b1be4060c3a8fde540" name="a54f2de7bdc1dc0b1be4060c3a8fde540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f2de7bdc1dc0b1be4060c3a8fde540">&#9670;&nbsp;</a></span>getAngleParamters() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getAngleParamters(const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00821">821</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span>  {</div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span>    std::vector&lt;double&gt; par; <span class="comment">//th0,cth,ub0,cub</span></div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span>    <span class="keywordtype">int</span> lev=4;</div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span>    std::vector&lt;std::string&gt; fb1,fb2,fb3;</div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>) {<span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats)) {<span class="keywordflow">return</span> (get&lt;1&gt;(a));}}</div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span>    <span class="comment">/*if(par.size()) return par;</span></div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span><span class="comment">    else {if(fallback) return getAngleParamters(&quot;C&quot;,&quot;C&quot;,&quot;C&quot;,false); else throw DataNotAvailableException();} //Get defaults and save later*/</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a008b06865581950f90f100bd04b139cf" name="a008b06865581950f90f100bd04b139cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b06865581950f90f100bd04b139cf">&#9670;&nbsp;</a></span>getAngleParamtersFailsafe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamtersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. -failsafe method. </p>
<p >Searches the angle data loaded into this force-field to find angle parameters for a given triplet of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00881">881</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
<div class="ttc" id="aclassForceField_html_a008b06865581950f90f100bd04b139cf"><div class="ttname"><a href="classForceField.html#a008b06865581950f90f100bd04b139cf">ForceField::getAngleParamtersFailsafe</a></div><div class="ttdeci">const std::vector&lt; double &gt; &amp; getAngleParamtersFailsafe(Atom *a1, Atom *a2, Atom *a3) const</div><div class="ttdoc">Get the bond angle for the angle between three atom types. -failsafe method.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00881">forcefield.hpp:881</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a008b06865581950f90f100bd04b139cf" name="a008b06865581950f90f100bd04b139cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b06865581950f90f100bd04b139cf">&#9670;&nbsp;</a></span>getAngleParamtersFailsafe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamtersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. -failsafe method. </p>
<p >Searches the angle data loaded into this force-field to find angle parameters for a given triplet of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00793">793</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a008b06865581950f90f100bd04b139cf" name="a008b06865581950f90f100bd04b139cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b06865581950f90f100bd04b139cf">&#9670;&nbsp;</a></span>getAngleParamtersFailsafe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamtersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. -failsafe method. </p>
<p >Searches the angle data loaded into this force-field to find angle parameters for a given triplet of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00697">697</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a008b06865581950f90f100bd04b139cf" name="a008b06865581950f90f100bd04b139cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b06865581950f90f100bd04b139cf">&#9670;&nbsp;</a></span>getAngleParamtersFailsafe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getAngleParamtersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond angle for the angle between three atom types. -failsafe method. </p>
<p >Searches the angle data loaded into this force-field to find angle parameters for a given triplet of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00791">791</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a008b06865581950f90f100bd04b139cf">getAngleParamtersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a388e3f80e59286f915299e61341d078f" name="a388e3f80e59286f915299e61341d078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388e3f80e59286f915299e61341d078f">&#9670;&nbsp;</a></span>getAtom() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::getAtom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. </p>
<p >Returns a copy of the atom by name loaded with all force-field parameters. If no atom with such a name is loaded into the <a class="el" href="classForceField.html">ForceField</a>, a nullptr is returned <br  />
When using DeNovo with a well-parameterized Force-field, it is recommended that you use this method from a loaded "ForceField" object rather than directly using the <a class="el" href="classAtom.html">Atom</a> class' constructor. </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00540">540</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span>  {</div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span>    <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>* p : <a class="code hl_variable" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a>) {<span class="keywordflow">if</span>(p-&gt;toString()==s) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code hl_class" href="classAtom.html">Atom</a>(*p);}</div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span>  }</div>
<div class="ttc" id="aclassAtom_html"><div class="ttname"><a href="classAtom.html">Atom</a></div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00039">Atom.hpp:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a388e3f80e59286f915299e61341d078f" name="a388e3f80e59286f915299e61341d078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388e3f80e59286f915299e61341d078f">&#9670;&nbsp;</a></span>getAtom() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::getAtom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. </p>
<p >Returns a copy of the atom by name loaded with all force-field parameters. If no atom with such a name is loaded into the <a class="el" href="classForceField.html">ForceField</a>, a nullptr is returned <br  />
When using DeNovo with a well-parameterized Force-field, it is recommended that you use this method from a loaded "ForceField" object rather than directly using the <a class="el" href="classAtom.html">Atom</a> class' constructor. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00493">493</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span>  {</div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span>    <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>* p : <a class="code hl_variable" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a>) {<span class="keywordflow">if</span>(p-&gt;toString()==s) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code hl_class" href="classAtom.html">Atom</a>(*p);}</div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a388e3f80e59286f915299e61341d078f" name="a388e3f80e59286f915299e61341d078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388e3f80e59286f915299e61341d078f">&#9670;&nbsp;</a></span>getAtom() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::getAtom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. </p>
<p >Returns a copy of the atom by name loaded with all force-field parameters. If no atom with such a name is loaded into the <a class="el" href="classForceField.html">ForceField</a>, a nullptr is returned <br  />
When using DeNovo with a well-parameterized Force-field, it is recommended that you use this method from a loaded "ForceField" object rather than directly using the <a class="el" href="classAtom.html">Atom</a> class' constructor. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00461">461</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span>  {</div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span>    <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>* p : <a class="code hl_variable" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a>) {<span class="keywordflow">if</span>(p-&gt;toString()==s) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code hl_class" href="classAtom.html">Atom</a>(*p);}</div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a388e3f80e59286f915299e61341d078f" name="a388e3f80e59286f915299e61341d078f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388e3f80e59286f915299e61341d078f">&#9670;&nbsp;</a></span>getAtom() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::getAtom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of an atom-type loaded into this <a class="el" href="classForceField.html">ForceField</a> by name. </p>
<p >Returns a copy of the atom by name loaded with all force-field parameters. If no atom with such a name is loaded into the <a class="el" href="classForceField.html">ForceField</a>, a nullptr is returned <br  />
When using DeNovo with a well-parameterized Force-field, it is recommended that you use this method from a loaded "ForceField" object rather than directly using the <a class="el" href="classAtom.html">Atom</a> class' constructor. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00491">491</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span>  {</div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span>    <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>* p : <a class="code hl_variable" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a>) {<span class="keywordflow">if</span>(p-&gt;toString()==s) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code hl_class" href="classAtom.html">Atom</a>(*p);}</div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab19cd0db1e679daf537e06ef3308f721" name="ab19cd0db1e679daf537e06ef3308f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19cd0db1e679daf537e06ef3308f721">&#9670;&nbsp;</a></span>getBondLength() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::getBondLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond length for the bond between two atom types. </p>
<p >Searches the bond data loaded into this force-field to find bond parameters for a given pair of atom types.<br  />
 If it is not found (these two atom-types do not have a bond parameter), it will print an error message (unless silent mode is turned on), and throw a <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00856">856</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span>{<span class="keywordflow">return</span> get&lt;0&gt;(<a class="code hl_function" href="classForceField.html#a084b8d029b748fb56265d4ee5cce2873">getLengthParameters</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),silent));}</div>
<div class="ttc" id="aclassForceField_html_a084b8d029b748fb56265d4ee5cce2873"><div class="ttname"><a href="classForceField.html#a084b8d029b748fb56265d4ee5cce2873">ForceField::getLengthParameters</a></div><div class="ttdeci">std::pair&lt; double, double &gt; getLengthParameters(const std::string &amp;a1, const string &amp;a2, bool silent=false) const</div><div class="ttdoc">Alternate method for getLengthParameters(Atom*,Atom*,bool) using strings instead of Atom pointers.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00858">forcefield.hpp:858</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab19cd0db1e679daf537e06ef3308f721" name="ab19cd0db1e679daf537e06ef3308f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19cd0db1e679daf537e06ef3308f721">&#9670;&nbsp;</a></span>getBondLength() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::getBondLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond length for the bond between two atom types. </p>
<p >Searches the bond data loaded into this force-field to find bond parameters for a given pair of atom types.<br  />
 If it is not found (these two atom-types do not have a bond parameter), it will print an error message (unless silent mode is turned on), and throw a <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00768">768</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span>{<span class="keywordflow">return</span> get&lt;0&gt;(<a class="code hl_function" href="classForceField.html#a084b8d029b748fb56265d4ee5cce2873">getLengthParameters</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),silent));}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab19cd0db1e679daf537e06ef3308f721" name="ab19cd0db1e679daf537e06ef3308f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19cd0db1e679daf537e06ef3308f721">&#9670;&nbsp;</a></span>getBondLength() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::getBondLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond length for the bond between two atom types. </p>
<p >Searches the bond data loaded into this force-field to find bond parameters for a given pair of atom types.<br  />
 If it is not found (these two atom-types do not have a bond parameter), it will print an error message (unless silent mode is turned on), and throw a <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00672">672</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span>{<span class="keywordflow">return</span> get&lt;0&gt;(<a class="code hl_function" href="classForceField.html#a084b8d029b748fb56265d4ee5cce2873">getLengthParameters</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),silent));}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab19cd0db1e679daf537e06ef3308f721" name="ab19cd0db1e679daf537e06ef3308f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19cd0db1e679daf537e06ef3308f721">&#9670;&nbsp;</a></span>getBondLength() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ForceField::getBondLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bond length for the bond between two atom types. </p>
<p >Searches the bond data loaded into this force-field to find bond parameters for a given pair of atom types.<br  />
 If it is not found (these two atom-types do not have a bond parameter), it will print an error message (unless silent mode is turned on), and throw a <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00766">766</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span>{<span class="keywordflow">return</span> get&lt;0&gt;(<a class="code hl_function" href="classForceField.html#a084b8d029b748fb56265d4ee5cce2873">getLengthParameters</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),silent));}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e2fcbe7169f95e62fc8e528dfa6ca7a" name="a6e2fcbe7169f95e62fc8e528dfa6ca7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2fcbe7169f95e62fc8e528dfa6ca7a">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle data for a set of four atom-types (in order of the connection chain) </p>
<p >Searches the dihedral data for a <b>direct match</b> only (no template matching). If dihedral data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00949">949</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span>  {</div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3); atl.push_back(a4);</div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a>(atl); <span class="comment">//,fallback);</span></div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span>    <span class="comment">//return getDihedralParameters(atl);</span></div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span>  }</div>
<div class="ttc" id="aclassForceField_html_a6e2fcbe7169f95e62fc8e528dfa6ca7a"><div class="ttname"><a href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">ForceField::getDihedralParameters</a></div><div class="ttdeci">const std::vector&lt; double &gt; &amp; getDihedralParameters(const std::string &amp;a1, const std::string &amp;a2, const std::string &amp;a3, const std::string &amp;a4) const</div><div class="ttdoc">Get the dihedral angle data for a set of four atom-types (in order of the connection chain)</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00949">forcefield.hpp:949</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e2fcbe7169f95e62fc8e528dfa6ca7a" name="a6e2fcbe7169f95e62fc8e528dfa6ca7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2fcbe7169f95e62fc8e528dfa6ca7a">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle data for a set of four atom-types (in order of the connection chain) </p>
<p >Searches the dihedral data for a <b>direct match</b> only (no template matching). If dihedral data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00861">861</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span>  {</div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3); atl.push_back(a4);</div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a>(atl); <span class="comment">//,fallback);</span></div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span>    <span class="comment">//return getDihedralParameters(atl);</span></div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e2fcbe7169f95e62fc8e528dfa6ca7a" name="a6e2fcbe7169f95e62fc8e528dfa6ca7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2fcbe7169f95e62fc8e528dfa6ca7a">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle data for a set of four atom-types (in order of the connection chain) </p>
<p >Searches the dihedral data for a <b>direct match</b> only (no template matching). If dihedral data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00765">765</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span>  {</div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3); atl.push_back(a4);</div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a>(atl); <span class="comment">//,fallback);</span></div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span>    <span class="comment">//return getDihedralParameters(atl);</span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e2fcbe7169f95e62fc8e528dfa6ca7a" name="a6e2fcbe7169f95e62fc8e528dfa6ca7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2fcbe7169f95e62fc8e528dfa6ca7a">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle data for a set of four atom-types (in order of the connection chain) </p>
<p >Searches the dihedral data for a <b>direct match</b> only (no template matching). If dihedral data is not found, <a class="el" href="classDataNotAvailableException.html">DataNotAvailableException</a> is thrown. </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00859">859</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span>  {</div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span>    std::vector&lt;std::string&gt; atl; atl.push_back(a1);  atl.push_back(a2); atl.push_back(a3); atl.push_back(a4);</div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a6e2fcbe7169f95e62fc8e528dfa6ca7a">getDihedralParameters</a>(atl); <span class="comment">//,fallback);</span></div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span>    <span class="comment">//return getDihedralParameters(atl);</span></div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bc80bfd10caa37d151f412d2cbe052b" name="a3bc80bfd10caa37d151f412d2cbe052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc80bfd10caa37d151f412d2cbe052b">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getDihedralParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00956">956</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span>  {</div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>)</div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span>    {</div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span>      <span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats))</div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span>        <span class="keywordflow">return</span> (get&lt;1&gt;(a));</div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span>    }</div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span>    <span class="comment">//cout &lt;&lt; &quot;Dihedral parameters are not available for dihedral with:\t&quot;;</span></div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span>    <span class="comment">//for(const std::string&amp; s : ats) {cout &lt;&lt;s&lt;&lt;&quot; &quot;;}</span></div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>  }</div>
<div class="ttc" id="aclassForceField_html_aa1d02343fc1649e13677701899841679"><div class="ttname"><a href="classForceField.html#aa1d02343fc1649e13677701899841679">ForceField::dihedral_parameters</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; vector_s, vector_d &gt; &gt; dihedral_parameters</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00329">forcefield.hpp:329</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bc80bfd10caa37d151f412d2cbe052b" name="a3bc80bfd10caa37d151f412d2cbe052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc80bfd10caa37d151f412d2cbe052b">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getDihedralParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00868">868</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span>  {</div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>)</div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span>    {</div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span>      <span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats))</div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span>        <span class="keywordflow">return</span> (get&lt;1&gt;(a));</div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span>    }</div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span>    <span class="comment">//cout &lt;&lt; &quot;Dihedral parameters are not available for dihedral with:\t&quot;;</span></div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span>    <span class="comment">//for(const std::string&amp; s : ats) {cout &lt;&lt;s&lt;&lt;&quot; &quot;;}</span></div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bc80bfd10caa37d151f412d2cbe052b" name="a3bc80bfd10caa37d151f412d2cbe052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc80bfd10caa37d151f412d2cbe052b">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getDihedralParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00772">772</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span>  {</div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>)</div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span>    {</div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span>      <span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats))</div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span>        <span class="keywordflow">return</span> (get&lt;1&gt;(a));</div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span>    }</div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span>    <span class="comment">//cout &lt;&lt; &quot;Dihedral parameters are not available for dihedral with:\t&quot;;</span></div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span>    <span class="comment">//for(const std::string&amp; s : ats) {cout &lt;&lt;s&lt;&lt;&quot; &quot;;}</span></div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3bc80bfd10caa37d151f412d2cbe052b" name="a3bc80bfd10caa37d151f412d2cbe052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc80bfd10caa37d151f412d2cbe052b">&#9670;&nbsp;</a></span>getDihedralParameters() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParameters </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Alternate method for getDihedralParameters(const std::string&amp;,const std::string&amp;,const std::string&amp;,const std::string&amp;) with all strings in a single list </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00866">866</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span>  {</div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>)</div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span>    {</div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span>      <span class="keywordflow">if</span>(matches&lt;std::string&gt;((get&lt;0&gt;(a)),ats))</div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span>        <span class="keywordflow">return</span> (get&lt;1&gt;(a));</div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span>    }</div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span>    <span class="comment">//cout &lt;&lt; &quot;Dihedral parameters are not available for dihedral with:\t&quot;;</span></div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span>    <span class="comment">//for(const std::string&amp; s : ats) {cout &lt;&lt;s&lt;&lt;&quot; &quot;;}</span></div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span>    <span class="keywordflow">throw</span> <a class="code hl_class" href="classDataNotAvailableException.html">DataNotAvailableException</a>();</div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e27b4bf5bea870617379cdb657cefd7" name="a2e27b4bf5bea870617379cdb657cefd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e27b4bf5bea870617379cdb657cefd7">&#9670;&nbsp;</a></span>getDihedralParametersFailsafe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParametersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method. </p>
<p >Searches the dihedral data loaded into this force-field to find dihedral parameters for a given set of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00926">926</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
<div class="ttc" id="aclassForceField_html_a2e27b4bf5bea870617379cdb657cefd7"><div class="ttname"><a href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">ForceField::getDihedralParametersFailsafe</a></div><div class="ttdeci">const std::vector&lt; double &gt; &amp; getDihedralParametersFailsafe(Atom *a1, Atom *a2, Atom *a3, Atom *a4) const</div><div class="ttdoc">Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00926">forcefield.hpp:926</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e27b4bf5bea870617379cdb657cefd7" name="a2e27b4bf5bea870617379cdb657cefd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e27b4bf5bea870617379cdb657cefd7">&#9670;&nbsp;</a></span>getDihedralParametersFailsafe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParametersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method. </p>
<p >Searches the dihedral data loaded into this force-field to find dihedral parameters for a given set of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00838">838</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e27b4bf5bea870617379cdb657cefd7" name="a2e27b4bf5bea870617379cdb657cefd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e27b4bf5bea870617379cdb657cefd7">&#9670;&nbsp;</a></span>getDihedralParametersFailsafe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParametersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method. </p>
<p >Searches the dihedral data loaded into this force-field to find dihedral parameters for a given set of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00742">742</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e27b4bf5bea870617379cdb657cefd7" name="a2e27b4bf5bea870617379cdb657cefd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e27b4bf5bea870617379cdb657cefd7">&#9670;&nbsp;</a></span>getDihedralParametersFailsafe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; ForceField::getDihedralParametersFailsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dihedral angle for a set of four atoms (in order of the chain). -failsafe method. </p>
<p >Searches the dihedral data loaded into this force-field to find dihedral parameters for a given set of atom types. It also checks if any templates match the request (see input files section of documentation PDF)<br  />
 If it is not found, it will print a warning message (stating that data could not be found), and will resort to a default value (instead of throwing an exception - which is why this method has "failsafe" in the name). </p>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00836">836</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a2e27b4bf5bea870617379cdb657cefd7">getDihedralParametersFailsafe</a>(a1-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a3-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>(),a4-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4e6c7a3139b39b1f286a00f53526f57" name="ac4e6c7a3139b39b1f286a00f53526f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6c7a3139b39b1f286a00f53526f57">&#9670;&nbsp;</a></span>getRules() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; ForceField::getRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of all the rules loaded into this forcefield. </p>
<p >All the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> are returned by atom-type. </p><dl class="section return"><dt>Returns</dt><dd>A set of pairs of atom-type names and the set of rules imposed on it (std::vector&lt;std::pair&lt;std::string,std::vector&lt;chemtools::Rule&gt;&gt;&gt;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00488">488</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span>{<span class="keywordflow">return</span> <a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4e6c7a3139b39b1f286a00f53526f57" name="ac4e6c7a3139b39b1f286a00f53526f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6c7a3139b39b1f286a00f53526f57">&#9670;&nbsp;</a></span>getRules() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; ForceField::getRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of all the rules loaded into this forcefield. </p>
<p >All the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> are returned by atom-type. </p><dl class="section return"><dt>Returns</dt><dd>A set of pairs of atom-type names and the set of rules imposed on it (std::vector&lt;std::pair&lt;std::string,std::vector&lt;chemtools::Rule&gt;&gt;&gt;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00441">441</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span>{<span class="keywordflow">return</span> <a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4e6c7a3139b39b1f286a00f53526f57" name="ac4e6c7a3139b39b1f286a00f53526f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6c7a3139b39b1f286a00f53526f57">&#9670;&nbsp;</a></span>getRules() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; ForceField::getRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of all the rules loaded into this forcefield. </p>
<p >All the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> are returned by atom-type. </p><dl class="section return"><dt>Returns</dt><dd>A set of pairs of atom-type names and the set of rules imposed on it (std::vector&lt;std::pair&lt;std::string,std::vector&lt;chemtools::Rule&gt;&gt;&gt;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00420">420</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span>{<span class="keywordflow">return</span> <a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4e6c7a3139b39b1f286a00f53526f57" name="ac4e6c7a3139b39b1f286a00f53526f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6c7a3139b39b1f286a00f53526f57">&#9670;&nbsp;</a></span>getRules() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; ForceField::getRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of all the rules loaded into this forcefield. </p>
<p >All the rules loaded into this <a class="el" href="classForceField.html">ForceField</a> are returned by atom-type. </p><dl class="section return"><dt>Returns</dt><dd>A set of pairs of atom-type names and the set of rules imposed on it (std::vector&lt;std::pair&lt;std::string,std::vector&lt;chemtools::Rule&gt;&gt;&gt;) </dd></dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00439">439</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span>{<span class="keywordflow">return</span> <a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a916b6f2de77e5c712e9e3404d7862a1a" name="a916b6f2de77e5c712e9e3404d7862a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916b6f2de77e5c712e9e3404d7862a1a">&#9670;&nbsp;</a></span>listAtomsByRule() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; ForceField::listAtomsByRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMolecule.html">Molecule</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>temp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Situationally list atoms that can bond to the selected atom. </p>
<p >Get a list of the loaded atom-types such that they can bond to the source atom (see params).<br  />
 This function ensures that after adding this bond, the no atom-type definitions are violated. No checks are made to ensure that all the rules can still be satisfied after this stage. It is assumed that the rules are sane enough to allow the atom-type to satisfy them </p>

<p class="definition">Definition at line <a class="el" href="Molecule_8hpp_source.html#l04863">4863</a> of file <a class="el" href="Molecule_8hpp_source.html">Molecule.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l04863" name="l04863"></a><span class="lineno"> 4863</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">listAtomsByRule</a>(a,m-&gt;getBondedAtoms(a),exa);}</div>
<div class="ttc" id="aclassForceField_html_a916b6f2de77e5c712e9e3404d7862a1a"><div class="ttname"><a href="classForceField.html#a916b6f2de77e5c712e9e3404d7862a1a">ForceField::listAtomsByRule</a></div><div class="ttdeci">std::vector&lt; Atom * &gt; listAtomsByRule(Atom *s, Molecule *m, Atom *temp=nullptr) const</div><div class="ttdoc">Situationally list atoms that can bond to the selected atom.</div><div class="ttdef"><b>Definition:</b> <a href="Molecule_8hpp_source.html#l04863">Molecule.hpp:4863</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a916b6f2de77e5c712e9e3404d7862a1a" name="a916b6f2de77e5c712e9e3404d7862a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916b6f2de77e5c712e9e3404d7862a1a">&#9670;&nbsp;</a></span>listAtomsByRule() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; ForceField::listAtomsByRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMolecule.html">Molecule</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>temp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Situationally list atoms that can bond to the selected atom. </p>
<p >Get a list of the loaded atom-types such that they can bond to the source atom (see params).<br  />
 This function ensures that after adding this bond, the no atom-type definitions are violated. No checks are made to ensure that all the rules can still be satisfied after this stage. It is assumed that the rules are sane enough to allow the atom-type to satisfy them </p>

</div>
</div>
<a id="a916b6f2de77e5c712e9e3404d7862a1a" name="a916b6f2de77e5c712e9e3404d7862a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916b6f2de77e5c712e9e3404d7862a1a">&#9670;&nbsp;</a></span>listAtomsByRule() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; ForceField::listAtomsByRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMolecule.html">Molecule</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>temp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Situationally list atoms that can bond to the selected atom. </p>
<p >Get a list of the loaded atom-types such that they can bond to the source atom (see params).<br  />
 This function ensures that after adding this bond, the no atom-type definitions are violated. No checks are made to ensure that all the rules can still be satisfied after this stage. It is assumed that the rules are sane enough to allow the atom-type to satisfy them </p>

</div>
</div>
<a id="a629cd1dff57f199e0e836e00792101b1" name="a629cd1dff57f199e0e836e00792101b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629cd1dff57f199e0e836e00792101b1">&#9670;&nbsp;</a></span>listFragmentsByRule() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt; ForceField::listFragmentsByRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMolecule.html">Molecule</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FragmentSet &amp;&#160;</td>
          <td class="paramname"><em>frags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>exa</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all possible a <b>fragments</b> that can bond to a given atom (following bonding rules). </p>
<p >The output also contains the target atom and its "support" (two atoms connected to it) </p>

<p class="definition">Definition at line <a class="el" href="Molecule_8hpp_source.html#l04864">4864</a> of file <a class="el" href="Molecule_8hpp_source.html">Molecule.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l04864" name="l04864"></a><span class="lineno"> 4864</span>{<span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">listFragmentsByRule</a>(src,m-&gt;getBondedAtoms(src),frags,exa,devid);}</div>
<div class="ttc" id="aclassForceField_html_a629cd1dff57f199e0e836e00792101b1"><div class="ttname"><a href="classForceField.html#a629cd1dff57f199e0e836e00792101b1">ForceField::listFragmentsByRule</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; MolecularFragment *, std::pair&lt; Atom *, std::vector&lt; Atom * &gt; &gt; &gt; &gt; listFragmentsByRule(Atom *src, Molecule *m, const FragmentSet &amp;frags, Atom *exa=nullptr, int devid=0) const</div><div class="ttdoc">List all possible a fragments that can bond to a given atom (following bonding rules).</div><div class="ttdef"><b>Definition:</b> <a href="Molecule_8hpp_source.html#l04864">Molecule.hpp:4864</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a629cd1dff57f199e0e836e00792101b1" name="a629cd1dff57f199e0e836e00792101b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629cd1dff57f199e0e836e00792101b1">&#9670;&nbsp;</a></span>listFragmentsByRule() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt; ForceField::listFragmentsByRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMolecule.html">Molecule</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FragmentSet &amp;&#160;</td>
          <td class="paramname"><em>frags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>exa</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all possible a <b>fragments</b> that can bond to a given atom (following bonding rules). </p>
<p >The output also contains the target atom and its "support" (two atoms connected to it) </p>

</div>
</div>
<a id="a629cd1dff57f199e0e836e00792101b1" name="a629cd1dff57f199e0e836e00792101b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629cd1dff57f199e0e836e00792101b1">&#9670;&nbsp;</a></span>listFragmentsByRule() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classMolecularFragment.html">MolecularFragment</a> *, std::pair&lt; <a class="el" href="classAtom.html">Atom</a> *, std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; &gt; &gt; &gt; ForceField::listFragmentsByRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMolecule.html">Molecule</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FragmentSet &amp;&#160;</td>
          <td class="paramname"><em>frags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>exa</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all possible a <b>fragments</b> that can bond to a given atom (following bonding rules). </p>
<p >The output also contains the target atom and its "support" (two atoms connected to it) </p>

</div>
</div>
<a id="a4e91de8d02133714b409ad4374346314" name="a4e91de8d02133714b409ad4374346314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e91de8d02133714b409ad4374346314">&#9670;&nbsp;</a></span>loadAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadAngles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>erase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load bond-angle data from a given file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Filename to load from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">erase</td><td>Erase any pre-existing data (Default: Yes) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l01394">1394</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l01395" name="l01395"></a><span class="lineno"> 1395</span>{</div>
<div class="line"><a id="l01396" name="l01396"></a><span class="lineno"> 1396</span>    cout &lt;&lt; <span class="stringliteral">&quot;Loading angles from: &quot;</span>&lt;&lt;filename&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l01397" name="l01397"></a><span class="lineno"> 1397</span>    <span class="keywordflow">if</span>(erase) <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>=std::vector&lt;std::pair&lt;vector_s,vector_d&gt;&gt;();</div>
<div class="line"><a id="l01398" name="l01398"></a><span class="lineno"> 1398</span>    ifstream f;</div>
<div class="line"><a id="l01399" name="l01399"></a><span class="lineno"> 1399</span>    f.open(filename,ios::in);</div>
<div class="line"><a id="l01400" name="l01400"></a><span class="lineno"> 1400</span>    std::string first,second,third;</div>
<div class="line"><a id="l01401" name="l01401"></a><span class="lineno"> 1401</span>    <span class="keywordtype">double</span> p1,p2,p3,p4;</div>
<div class="line"><a id="l01402" name="l01402"></a><span class="lineno"> 1402</span>    <span class="keywordtype">int</span> k=0;</div>
<div class="line"><a id="l01403" name="l01403"></a><span class="lineno"> 1403</span>    <span class="keywordtype">bool</span> fnd;</div>
<div class="line"><a id="l01404" name="l01404"></a><span class="lineno"> 1404</span>    <span class="keywordflow">while</span>(1)</div>
<div class="line"><a id="l01405" name="l01405"></a><span class="lineno"> 1405</span>    {</div>
<div class="line"><a id="l01406" name="l01406"></a><span class="lineno"> 1406</span>        f&gt;&gt;first&gt;&gt;second&gt;&gt;third&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3&gt;&gt;p4;</div>
<div class="line"><a id="l01407" name="l01407"></a><span class="lineno"> 1407</span>        p1*=PI/180.0; <span class="comment">//Convert to radians</span></div>
<div class="line"><a id="l01408" name="l01408"></a><span class="lineno"> 1408</span>        <span class="keywordflow">if</span>(f.eof())</div>
<div class="line"><a id="l01409" name="l01409"></a><span class="lineno"> 1409</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01410" name="l01410"></a><span class="lineno"> 1410</span>        std::vector&lt;std::string&gt; ats; ats.push_back(first); ats.push_back(second); ats.push_back(third);</div>
<div class="line"><a id="l01411" name="l01411"></a><span class="lineno"> 1411</span>        std::vector&lt;double&gt; vals; vals.push_back(p1); vals.push_back(p2); vals.push_back(p3); vals.push_back(p4);</div>
<div class="line"><a id="l01412" name="l01412"></a><span class="lineno"> 1412</span>        <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>.push_back(make_pair(ats,vals));</div>
<div class="line"><a id="l01413" name="l01413"></a><span class="lineno"> 1413</span>        first=first[0]; second=second[0]; third=third[0];</div>
<div class="line"><a id="l01414" name="l01414"></a><span class="lineno"> 1414</span>        std::vector&lt;std::string&gt; atg; atg.push_back(first); atg.push_back(second); atg.push_back(third);</div>
<div class="line"><a id="l01415" name="l01415"></a><span class="lineno"> 1415</span>        fnd=<span class="keyword">false</span>;</div>
<div class="line"><a id="l01416" name="l01416"></a><span class="lineno"> 1416</span>        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>)</div>
<div class="line"><a id="l01417" name="l01417"></a><span class="lineno"> 1417</span>        {</div>
<div class="line"><a id="l01418" name="l01418"></a><span class="lineno"> 1418</span>            <span class="keywordflow">if</span>(matches(get&lt;0&gt;(a),atg)) {fnd=<span class="keyword">true</span>; <span class="keywordflow">break</span>;}</div>
<div class="line"><a id="l01419" name="l01419"></a><span class="lineno"> 1419</span>        }</div>
<div class="line"><a id="l01420" name="l01420"></a><span class="lineno"> 1420</span>        <span class="keywordflow">if</span>(!fnd)</div>
<div class="line"><a id="l01421" name="l01421"></a><span class="lineno"> 1421</span>            <a class="code hl_variable" href="classForceField.html#ae198b91b5ffc6278887ae798837d45e8">angle_parameters</a>.push_back(make_pair(atg,vals));</div>
<div class="line"><a id="l01422" name="l01422"></a><span class="lineno"> 1422</span>    }</div>
<div class="line"><a id="l01423" name="l01423"></a><span class="lineno"> 1423</span>    f.close();</div>
<div class="line"><a id="l01424" name="l01424"></a><span class="lineno"> 1424</span>    cout &lt;&lt; <span class="stringliteral">&quot;Done with Angles\n&quot;</span>;</div>
<div class="line"><a id="l01425" name="l01425"></a><span class="lineno"> 1425</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aab7dd2e1378e1ef7532a5e8184fdb936" name="aab7dd2e1378e1ef7532a5e8184fdb936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7dd2e1378e1ef7532a5e8184fdb936">&#9670;&nbsp;</a></span>loadBondParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadBondParameters </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>lengthfn</em> = <code>LengthDataFile</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>anglefn</em> = <code>AngleDataFile</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dihedralfn</em> = <code>DihedralDataFile</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>improperfn</em> = <code>ImproperDataFile</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>erase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper to load all parameters (bond-length,bond-angle,dihedral,and improper-dihedral). See documentation (PDF) for default filenames. </p>
<p >This function is a wrapper to load all required parameters at once using default (or, based on programmer's choice, other specified) input files for the data.<br  />
 To load any of bond length, angle, dihedral, or improper parameters separately, look at the respective functions (<a class="el" href="classForceField.html#a00fd23cd72bc2fb9037b744befae5180" title="Load bond-length data from a given file.">ForceField::loadLengths</a>, <a class="el" href="classForceField.html#a4e91de8d02133714b409ad4374346314" title="Load bond-angle data from a given file.">ForceField::loadAngles</a>, <a class="el" href="classForceField.html#a2247bad6012ae2d0897abb532a072d47" title="Load dihedral data from a given file.">ForceField::loadDihedrals</a>, <a class="el" href="classForceField.html#a4871a728498d1cd28e5cfc2130b99a53" title="Load improper dihedral data from a given file (not used in later versions of DeNovo)">ForceField::loadImpropers</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthfn</td><td>Filename to load <u>length</u> data (1st parameter) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">anglefn</td><td>Filename to load <u>angle</u> data (2nd parameter) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dihedralfn</td><td>Filename to load <u><b>proper</b> dihedral</u> data (3rd parameter) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">improperfn</td><td>Filename to load <u><b>improper</b> dihedral</u> data (4th parameter) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">erase</td><td>Delete any pre-existing data? (Default: Yes) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00832">832</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span>  {</div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span>    <span class="comment">//cout &lt;&lt; lengthfn &lt;&lt; &quot;; Now working\n&quot;;</span></div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span>    <a class="code hl_function" href="classForceField.html#a00fd23cd72bc2fb9037b744befae5180">loadLengths</a>(lengthfn,erase);</div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span>    <a class="code hl_function" href="classForceField.html#a4e91de8d02133714b409ad4374346314">loadAngles</a>(anglefn,erase);</div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span>    <a class="code hl_function" href="classForceField.html#a2247bad6012ae2d0897abb532a072d47">loadDihedrals</a>(dihedralfn,erase);</div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span>    <a class="code hl_function" href="classForceField.html#a4871a728498d1cd28e5cfc2130b99a53">loadImpropers</a>(improperfn);</div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span>    cout &lt;&lt; <span class="stringliteral">&quot;Done\n&quot;</span>;</div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span>  }</div>
<div class="ttc" id="aclassForceField_html_a00fd23cd72bc2fb9037b744befae5180"><div class="ttname"><a href="classForceField.html#a00fd23cd72bc2fb9037b744befae5180">ForceField::loadLengths</a></div><div class="ttdeci">void loadLengths(const std::string &amp;s, bool erase=true)</div><div class="ttdoc">Load bond-length data from a given file.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l01336">forcefield.hpp:1336</a></div></div>
<div class="ttc" id="aclassForceField_html_a2247bad6012ae2d0897abb532a072d47"><div class="ttname"><a href="classForceField.html#a2247bad6012ae2d0897abb532a072d47">ForceField::loadDihedrals</a></div><div class="ttdeci">void loadDihedrals(const std::string &amp;s, bool erase=true)</div><div class="ttdoc">Load dihedral data from a given file.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l01426">forcefield.hpp:1426</a></div></div>
<div class="ttc" id="aclassForceField_html_a4871a728498d1cd28e5cfc2130b99a53"><div class="ttname"><a href="classForceField.html#a4871a728498d1cd28e5cfc2130b99a53">ForceField::loadImpropers</a></div><div class="ttdeci">void loadImpropers(const std::string &amp;s)</div><div class="ttdoc">Load improper dihedral data from a given file (not used in later versions of DeNovo)</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l01457">forcefield.hpp:1457</a></div></div>
<div class="ttc" id="aclassForceField_html_a4e91de8d02133714b409ad4374346314"><div class="ttname"><a href="classForceField.html#a4e91de8d02133714b409ad4374346314">ForceField::loadAngles</a></div><div class="ttdeci">void loadAngles(const std::string &amp;s, bool erase=true)</div><div class="ttdoc">Load bond-angle data from a given file.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l01394">forcefield.hpp:1394</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afa84f8e5f7d4737c25281ccf8e649911" name="afa84f8e5f7d4737c25281ccf8e649911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa84f8e5f7d4737c25281ccf8e649911">&#9670;&nbsp;</a></span>loadCategories()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadCategories </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>catf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emptyCat</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load categories from an external file into this forcefield. </p>
<p >Categories can also be loaded when the <a class="el" href="classForceField.html">ForceField</a> object is created (See: <a class="el" href="classForceField.html#aafea81a4f90173d98b5d683f3508f936" title="Load the forcefield from the standard ffin format, and categories from a categories file....">ForceField(const std::string&amp;,const std::string&amp;)</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">catf</td><td>Fileame to load category data from (See Atom-type group formats in documentation PDF) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">emptyCat</td><td>Empty existing category data? (Default: Yes) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00434">434</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span>    {</div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span>        <span class="keywordflow">if</span>(emptyCat) <a class="code hl_variable" href="classForceField.html#ae5aeed0193bd434dbae1ed6f457a6c75">categories</a>.empty();</div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span>        ifstream cf; cf.open(catf,ios::in);</div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span>        std::string cat,data;</div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span>        <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span>        {</div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span>            cf &gt;&gt; cat &gt;&gt; data;</div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span>            <span class="keywordflow">if</span>(cf.eof()) <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span>            <a class="code hl_variable" href="classForceField.html#ae5aeed0193bd434dbae1ed6f457a6c75">categories</a>.push_back(<a class="code hl_class" href="classCategory.html">Category</a>(cat,data));</div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span>        }</div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span>        cout &lt;&lt; <span class="stringliteral">&quot;Categories loaded! &quot;</span>&lt;&lt;<a class="code hl_variable" href="classForceField.html#ae5aeed0193bd434dbae1ed6f457a6c75">categories</a>.size()&lt;&lt;<span class="stringliteral">&quot; categor(y/ies) exist(s).\n&quot;</span>;</div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span>    }</div>
<div class="ttc" id="aclassCategory_html"><div class="ttname"><a href="classCategory.html">Category</a></div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00284">forcefield.hpp:285</a></div></div>
<div class="ttc" id="aclassForceField_html_ae5aeed0193bd434dbae1ed6f457a6c75"><div class="ttname"><a href="classForceField.html#ae5aeed0193bd434dbae1ed6f457a6c75">ForceField::categories</a></div><div class="ttdeci">std::vector&lt; Category &gt; categories</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00321">forcefield.hpp:321</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2247bad6012ae2d0897abb532a072d47" name="a2247bad6012ae2d0897abb532a072d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2247bad6012ae2d0897abb532a072d47">&#9670;&nbsp;</a></span>loadDihedrals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadDihedrals </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>erase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load dihedral data from a given file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Filename to load from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">erase</td><td>Erase any pre-existing data (Default: Yes) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l01426">1426</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l01427" name="l01427"></a><span class="lineno"> 1427</span>{</div>
<div class="line"><a id="l01428" name="l01428"></a><span class="lineno"> 1428</span>    cout &lt;&lt; <span class="stringliteral">&quot;Loading dihedrals from: &quot;</span>&lt;&lt;filename&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l01429" name="l01429"></a><span class="lineno"> 1429</span>    <span class="keywordflow">if</span>(erase) <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>=std::vector&lt;std::pair&lt;vector_s,vector_d&gt;&gt;();</div>
<div class="line"><a id="l01430" name="l01430"></a><span class="lineno"> 1430</span>    ifstream f;</div>
<div class="line"><a id="l01431" name="l01431"></a><span class="lineno"> 1431</span>    f.open(filename,ios::in);</div>
<div class="line"><a id="l01432" name="l01432"></a><span class="lineno"> 1432</span>    std::string first,second,third,fourth;</div>
<div class="line"><a id="l01433" name="l01433"></a><span class="lineno"> 1433</span>    <span class="keywordtype">double</span> p1,p2,p3,d;</div>
<div class="line"><a id="l01434" name="l01434"></a><span class="lineno"> 1434</span>    <span class="keywordtype">bool</span> fnd;</div>
<div class="line"><a id="l01435" name="l01435"></a><span class="lineno"> 1435</span>    <span class="keywordflow">while</span>(1)</div>
<div class="line"><a id="l01436" name="l01436"></a><span class="lineno"> 1436</span>    {</div>
<div class="line"><a id="l01437" name="l01437"></a><span class="lineno"> 1437</span>        f&gt;&gt;first&gt;&gt;second&gt;&gt;third&gt;&gt;fourth&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3;</div>
<div class="line"><a id="l01438" name="l01438"></a><span class="lineno"> 1438</span>        <span class="keywordflow">if</span>(f.eof())</div>
<div class="line"><a id="l01439" name="l01439"></a><span class="lineno"> 1439</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01440" name="l01440"></a><span class="lineno"> 1440</span>        p1*=PI/180.0;</div>
<div class="line"><a id="l01441" name="l01441"></a><span class="lineno"> 1441</span>        std::vector&lt;std::string&gt; ats; ats.push_back(first); ats.push_back(second); ats.push_back(third); ats.push_back(fourth);</div>
<div class="line"><a id="l01442" name="l01442"></a><span class="lineno"> 1442</span>        std::vector&lt;double&gt; vals; vals.push_back(p1); vals.push_back(p2); vals.push_back(p3);</div>
<div class="line"><a id="l01443" name="l01443"></a><span class="lineno"> 1443</span>        <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>.push_back(make_pair(ats,vals));</div>
<div class="line"><a id="l01444" name="l01444"></a><span class="lineno"> 1444</span>        fnd=<span class="keyword">false</span>;</div>
<div class="line"><a id="l01445" name="l01445"></a><span class="lineno"> 1445</span>        first=first[0]; second=second[0]; third=third[0]; fourth=fourth[0];</div>
<div class="line"><a id="l01446" name="l01446"></a><span class="lineno"> 1446</span>        std::vector&lt;std::string&gt; atg; atg.push_back(first); atg.push_back(second); atg.push_back(third); atg.push_back(fourth);</div>
<div class="line"><a id="l01447" name="l01447"></a><span class="lineno"> 1447</span>        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>)</div>
<div class="line"><a id="l01448" name="l01448"></a><span class="lineno"> 1448</span>        {</div>
<div class="line"><a id="l01449" name="l01449"></a><span class="lineno"> 1449</span>            <span class="keywordflow">if</span>(matches(get&lt;0&gt;(a),atg)) {fnd=<span class="keyword">true</span>; <span class="keywordflow">break</span>;}</div>
<div class="line"><a id="l01450" name="l01450"></a><span class="lineno"> 1450</span>        }</div>
<div class="line"><a id="l01451" name="l01451"></a><span class="lineno"> 1451</span>        <span class="keywordflow">if</span>(!fnd)</div>
<div class="line"><a id="l01452" name="l01452"></a><span class="lineno"> 1452</span>            <a class="code hl_variable" href="classForceField.html#aa1d02343fc1649e13677701899841679">dihedral_parameters</a>.push_back(make_pair(atg,vals));</div>
<div class="line"><a id="l01453" name="l01453"></a><span class="lineno"> 1453</span>    }</div>
<div class="line"><a id="l01454" name="l01454"></a><span class="lineno"> 1454</span>    f.close();</div>
<div class="line"><a id="l01455" name="l01455"></a><span class="lineno"> 1455</span>    cout &lt;&lt; <span class="stringliteral">&quot;Done with dihedrals\n&quot;</span>;</div>
<div class="line"><a id="l01456" name="l01456"></a><span class="lineno"> 1456</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4871a728498d1cd28e5cfc2130b99a53" name="a4871a728498d1cd28e5cfc2130b99a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4871a728498d1cd28e5cfc2130b99a53">&#9670;&nbsp;</a></span>loadImpropers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadImpropers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load improper dihedral data from a given file (not used in later versions of DeNovo) </p>
<p >DeNovo Versions after SIGMA do not deal with improper dihedrals except for fallback cases or for programming explicit requirements.<br  />
 The data for those parameters has not been updated since, and many new atom types (and parameters for existing atom-types) have been added for all other bonding data, so be sure to check the data for completeness and validity before using this feature.<br  />
 <b>Warning: </b> For all practical purposes and general use of the DeNovo, this feature is considered <em>deprecated</em>. </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l01457">1457</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l01458" name="l01458"></a><span class="lineno"> 1458</span>{</div>
<div class="line"><a id="l01459" name="l01459"></a><span class="lineno"> 1459</span>    cout &lt;&lt; <span class="stringliteral">&quot;Loading Improper(dihedral)s from: &quot;</span>&lt;&lt;filename&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l01460" name="l01460"></a><span class="lineno"> 1460</span>    <a class="code hl_variable" href="classForceField.html#af14e5e64ad6163c41904507e7dac0803">improper_parameters</a>=std::vector&lt;std::pair&lt;vector_s,pair_dd&gt;&gt;();</div>
<div class="line"><a id="l01461" name="l01461"></a><span class="lineno"> 1461</span>    ifstream f;</div>
<div class="line"><a id="l01462" name="l01462"></a><span class="lineno"> 1462</span>    f.open(filename,ios::in);</div>
<div class="line"><a id="l01463" name="l01463"></a><span class="lineno"> 1463</span>    std::string first,second,third,fourth;</div>
<div class="line"><a id="l01464" name="l01464"></a><span class="lineno"> 1464</span>    <span class="keywordtype">double</span> p1,p2;</div>
<div class="line"><a id="l01465" name="l01465"></a><span class="lineno"> 1465</span>    <span class="keywordtype">bool</span> fnd;</div>
<div class="line"><a id="l01466" name="l01466"></a><span class="lineno"> 1466</span>    <span class="keywordflow">while</span>(1)</div>
<div class="line"><a id="l01467" name="l01467"></a><span class="lineno"> 1467</span>    {</div>
<div class="line"><a id="l01468" name="l01468"></a><span class="lineno"> 1468</span>        f&gt;&gt;first&gt;&gt;second&gt;&gt;third&gt;&gt;fourth&gt;&gt;p1&gt;&gt;p2;</div>
<div class="line"><a id="l01469" name="l01469"></a><span class="lineno"> 1469</span>        <span class="keywordflow">if</span>(f.eof())</div>
<div class="line"><a id="l01470" name="l01470"></a><span class="lineno"> 1470</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01471" name="l01471"></a><span class="lineno"> 1471</span>        p1*=PI/180.0;</div>
<div class="line"><a id="l01472" name="l01472"></a><span class="lineno"> 1472</span>        std::vector&lt;std::string&gt; ats; ats.push_back(first); ats.push_back(second); ats.push_back(third); ats.push_back(fourth);</div>
<div class="line"><a id="l01473" name="l01473"></a><span class="lineno"> 1473</span>        <a class="code hl_variable" href="classForceField.html#af14e5e64ad6163c41904507e7dac0803">improper_parameters</a>.push_back(make_pair(ats,make_pair(p1,p2)));</div>
<div class="line"><a id="l01474" name="l01474"></a><span class="lineno"> 1474</span>        first=first[0]; second=second[0]; third=third[0]; fourth=fourth[0];</div>
<div class="line"><a id="l01475" name="l01475"></a><span class="lineno"> 1475</span>        std::vector&lt;std::string&gt; atg; atg.push_back(first); atg.push_back(second); atg.push_back(third); atg.push_back(fourth);</div>
<div class="line"><a id="l01476" name="l01476"></a><span class="lineno"> 1476</span>        fnd=<span class="keyword">false</span>;</div>
<div class="line"><a id="l01477" name="l01477"></a><span class="lineno"> 1477</span>        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; a : <a class="code hl_variable" href="classForceField.html#af14e5e64ad6163c41904507e7dac0803">improper_parameters</a>)</div>
<div class="line"><a id="l01478" name="l01478"></a><span class="lineno"> 1478</span>        {</div>
<div class="line"><a id="l01479" name="l01479"></a><span class="lineno"> 1479</span>            <span class="keywordflow">if</span>(matches(get&lt;0&gt;(a),atg)) {fnd=<span class="keyword">true</span>; <span class="keywordflow">break</span>;}</div>
<div class="line"><a id="l01480" name="l01480"></a><span class="lineno"> 1480</span>        }</div>
<div class="line"><a id="l01481" name="l01481"></a><span class="lineno"> 1481</span>        <span class="keywordflow">if</span>(!fnd)</div>
<div class="line"><a id="l01482" name="l01482"></a><span class="lineno"> 1482</span>            <a class="code hl_variable" href="classForceField.html#af14e5e64ad6163c41904507e7dac0803">improper_parameters</a>.push_back(make_pair(atg,make_pair(p1,p2)));</div>
<div class="line"><a id="l01483" name="l01483"></a><span class="lineno"> 1483</span>    }</div>
<div class="line"><a id="l01484" name="l01484"></a><span class="lineno"> 1484</span>    cout &lt;&lt; <span class="stringliteral">&quot;Done with impropers\n&quot;</span>;</div>
<div class="line"><a id="l01485" name="l01485"></a><span class="lineno"> 1485</span>}</div>
<div class="ttc" id="aclassForceField_html_af14e5e64ad6163c41904507e7dac0803"><div class="ttname"><a href="classForceField.html#af14e5e64ad6163c41904507e7dac0803">ForceField::improper_parameters</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; vector_s, pair_dd &gt; &gt; improper_parameters</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00330">forcefield.hpp:330</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a00fd23cd72bc2fb9037b744befae5180" name="a00fd23cd72bc2fb9037b744befae5180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fd23cd72bc2fb9037b744befae5180">&#9670;&nbsp;</a></span>loadLengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadLengths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>erase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load bond-length data from a given file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Filename to load from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">erase</td><td>Erase any pre-existing data (Default: Yes) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l01336">1336</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span>{</div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"> 1338</span>    cout &lt;&lt; <span class="stringliteral">&quot;Loading lengths from: &quot;</span>&lt;&lt;filename&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a id="l01339" name="l01339"></a><span class="lineno"> 1339</span>    <span class="comment">//length_parameters=std::vector&lt;std::pair&lt;pair_ss,pair_dd&gt;&gt;();</span></div>
<div class="line"><a id="l01340" name="l01340"></a><span class="lineno"> 1340</span>    <span class="keywordflow">if</span>(erase) <a class="code hl_variable" href="classForceField.html#af96ba6f982c2595b5b10199f8595f78b">length_parameters</a>=std::vector&lt;BondData&gt;();</div>
<div class="line"><a id="l01341" name="l01341"></a><span class="lineno"> 1341</span>    <span class="comment">//bondables=std::vector&lt;pair_ss&gt;();</span></div>
<div class="line"><a id="l01342" name="l01342"></a><span class="lineno"> 1342</span>    ifstream f;</div>
<div class="line"><a id="l01343" name="l01343"></a><span class="lineno"> 1343</span>    f.open(filename,ios::in);</div>
<div class="line"><a id="l01344" name="l01344"></a><span class="lineno"> 1344</span>    std::string first,second;</div>
<div class="line"><a id="l01345" name="l01345"></a><span class="lineno"> 1345</span>    <span class="keywordtype">double</span> b0,kb;</div>
<div class="line"><a id="l01346" name="l01346"></a><span class="lineno"> 1346</span>    <span class="keywordflow">while</span>(1)</div>
<div class="line"><a id="l01347" name="l01347"></a><span class="lineno"> 1347</span>    {</div>
<div class="line"><a id="l01348" name="l01348"></a><span class="lineno"> 1348</span>        <span class="keywordtype">bool</span> ffirst=<span class="keyword">false</span>,fsecond=<span class="keyword">false</span>;</div>
<div class="line"><a id="l01349" name="l01349"></a><span class="lineno"> 1349</span>        f&gt;&gt;first&gt;&gt;second&gt;&gt;b0&gt;&gt;kb;</div>
<div class="line"><a id="l01350" name="l01350"></a><span class="lineno"> 1350</span>        <span class="keywordflow">if</span>(f.eof())</div>
<div class="line"><a id="l01351" name="l01351"></a><span class="lineno"> 1351</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01352" name="l01352"></a><span class="lineno"> 1352</span>        <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>* a : <a class="code hl_variable" href="classForceField.html#a2d43f27c2cbca56da3deb919cd401d99">atom_types</a>)</div>
<div class="line"><a id="l01353" name="l01353"></a><span class="lineno"> 1353</span>        {</div>
<div class="line"><a id="l01354" name="l01354"></a><span class="lineno"> 1354</span>            <span class="keywordflow">if</span>(a-&gt;toString()==first) ffirst=<span class="keyword">true</span>;</div>
<div class="line"><a id="l01355" name="l01355"></a><span class="lineno"> 1355</span>            <span class="keywordflow">if</span>(a-&gt;toString()==second) fsecond=<span class="keyword">true</span>;</div>
<div class="line"><a id="l01356" name="l01356"></a><span class="lineno"> 1356</span>            <span class="keywordflow">if</span>(ffirst &amp;&amp; fsecond) <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01357" name="l01357"></a><span class="lineno"> 1357</span>        }</div>
<div class="line"><a id="l01358" name="l01358"></a><span class="lineno"> 1358</span>        <span class="keywordflow">if</span>(ffirst &amp;&amp; fsecond) <a class="code hl_variable" href="classForceField.html#af96ba6f982c2595b5b10199f8595f78b">length_parameters</a>.push_back(<a class="code hl_class" href="classBondData.html">BondData</a>(first,second,b0,kb));</div>
<div class="line"><a id="l01359" name="l01359"></a><span class="lineno"> 1359</span>        <span class="comment">/*std::pair&lt;std::string,std::string&gt; ats(first,second);</span></div>
<div class="line"><a id="l01360" name="l01360"></a><span class="lineno"> 1360</span><span class="comment">        std::pair&lt;double,double&gt; vals(b0,kb);*/</span></div>
<div class="line"><a id="l01361" name="l01361"></a><span class="lineno"> 1361</span>        <span class="comment">//bondables.push_back(ats);</span></div>
<div class="line"><a id="l01362" name="l01362"></a><span class="lineno"> 1362</span>    }</div>
<div class="line"><a id="l01363" name="l01363"></a><span class="lineno"> 1363</span>  cout &lt;&lt; <span class="stringliteral">&quot;Loaded length data\n&quot;</span>;</div>
<div class="line"><a id="l01364" name="l01364"></a><span class="lineno"> 1364</span> </div>
<div class="line"><a id="l01365" name="l01365"></a><span class="lineno"> 1365</span>  std::vector&lt;std::string&gt; aload;</div>
<div class="line"><a id="l01366" name="l01366"></a><span class="lineno"> 1366</span>  std::vector&lt;std::vector&lt;BondData&gt;&gt; data;</div>
<div class="line"><a id="l01367" name="l01367"></a><span class="lineno"> 1367</span>  <span class="keywordtype">int</span> ind1=0,ind2=0;</div>
<div class="line"><a id="l01368" name="l01368"></a><span class="lineno"> 1368</span>  <span class="keywordflow">for</span>(<a class="code hl_class" href="classBondData.html">BondData</a>&amp; b : <a class="code hl_variable" href="classForceField.html#af96ba6f982c2595b5b10199f8595f78b">length_parameters</a>)</div>
<div class="line"><a id="l01369" name="l01369"></a><span class="lineno"> 1369</span>  {</div>
<div class="line"><a id="l01370" name="l01370"></a><span class="lineno"> 1370</span>    ind1=-1,ind2=-1;</div>
<div class="line"><a id="l01371" name="l01371"></a><span class="lineno"> 1371</span>    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;aload.size();i++)</div>
<div class="line"><a id="l01372" name="l01372"></a><span class="lineno"> 1372</span>    {</div>
<div class="line"><a id="l01373" name="l01373"></a><span class="lineno"> 1373</span>      <span class="keywordflow">if</span>(aload[i]==b.atom1) ind1=i;</div>
<div class="line"><a id="l01374" name="l01374"></a><span class="lineno"> 1374</span>      <span class="keywordflow">if</span>(aload[i]==b.atom2) ind2=i;</div>
<div class="line"><a id="l01375" name="l01375"></a><span class="lineno"> 1375</span>      <span class="keywordflow">if</span>(ind1!=-1 &amp;&amp; ind2!=-1) <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01376" name="l01376"></a><span class="lineno"> 1376</span>    }</div>
<div class="line"><a id="l01377" name="l01377"></a><span class="lineno"> 1377</span>    <span class="comment">//cout &lt;&lt; b.atom1 &lt;&lt;&quot; &quot;&lt;&lt;b.atom2&lt;&lt;&quot;\t&quot;&lt;&lt;(ind1==-1)&lt;&lt;&quot; &quot;&lt;&lt;(ind2==-1)&lt;&lt;&quot; for &quot;&lt;&lt;aload.size()&lt;&lt;&quot;\n&quot;;</span></div>
<div class="line"><a id="l01378" name="l01378"></a><span class="lineno"> 1378</span>    <span class="keywordflow">if</span>(ind1==-1) {aload.push_back(b.atom1); data.push_back(std::vector&lt;BondData&gt;()); ind1=aload.size()-1;}</div>
<div class="line"><a id="l01379" name="l01379"></a><span class="lineno"> 1379</span>    data[ind1].push_back(b);</div>
<div class="line"><a id="l01380" name="l01380"></a><span class="lineno"> 1380</span>    <span class="keywordflow">if</span>(b.atom1==b.atom2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01381" name="l01381"></a><span class="lineno"> 1381</span>    <span class="keywordflow">if</span>(ind2==-1) {aload.push_back(b.atom2); data.push_back(std::vector&lt;BondData&gt;()); ind2=aload.size()-1;}</div>
<div class="line"><a id="l01382" name="l01382"></a><span class="lineno"> 1382</span>    data[ind2].push_back(b);</div>
<div class="line"><a id="l01383" name="l01383"></a><span class="lineno"> 1383</span>  }</div>
<div class="line"><a id="l01384" name="l01384"></a><span class="lineno"> 1384</span>  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;aload.size();i++)</div>
<div class="line"><a id="l01385" name="l01385"></a><span class="lineno"> 1385</span>  {</div>
<div class="line"><a id="l01386" name="l01386"></a><span class="lineno"> 1386</span>    <span class="comment">//cout &lt;&lt;aload[i]&lt;&lt;&quot;\t&quot;;</span></div>
<div class="line"><a id="l01387" name="l01387"></a><span class="lineno"> 1387</span>    <span class="comment">//for(BondData&amp; d : data[i]) cout&lt;&lt;d.getSecond(aload[i])&lt;&lt;&quot;\n&quot;;</span></div>
<div class="line"><a id="l01388" name="l01388"></a><span class="lineno"> 1388</span>    <a class="code hl_variable" href="classForceField.html#a90e6ae752fd0f03399f1f8cfdfff12f7">atombondmap</a>.push_back(make_pair(aload[i],data[i]));</div>
<div class="line"><a id="l01389" name="l01389"></a><span class="lineno"> 1389</span>  }</div>
<div class="line"><a id="l01390" name="l01390"></a><span class="lineno"> 1390</span>  cout &lt;&lt; <span class="stringliteral">&quot;Loaded mapping for bondtypes\n&quot;</span>;</div>
<div class="line"><a id="l01391" name="l01391"></a><span class="lineno"> 1391</span>    cout &lt;&lt; <span class="stringliteral">&quot;Done with lengths\n&quot;</span>;</div>
<div class="line"><a id="l01392" name="l01392"></a><span class="lineno"> 1392</span>    f.close();</div>
<div class="line"><a id="l01393" name="l01393"></a><span class="lineno"> 1393</span>}</div>
<div class="ttc" id="aclassBondData_html"><div class="ttname"><a href="classBondData.html">BondData</a></div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00127">forcefield.hpp:128</a></div></div>
<div class="ttc" id="aclassForceField_html_a90e6ae752fd0f03399f1f8cfdfff12f7"><div class="ttname"><a href="classForceField.html#a90e6ae752fd0f03399f1f8cfdfff12f7">ForceField::atombondmap</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; std::string, std::vector&lt; BondData &gt; &gt; &gt; atombondmap</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00331">forcefield.hpp:331</a></div></div>
<div class="ttc" id="aclassForceField_html_af96ba6f982c2595b5b10199f8595f78b"><div class="ttname"><a href="classForceField.html#af96ba6f982c2595b5b10199f8595f78b">ForceField::length_parameters</a></div><div class="ttdeci">std::vector&lt; BondData &gt; length_parameters</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00327">forcefield.hpp:327</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d792d4afbcfdd034e4c10bdd3ba523e" name="a6d792d4afbcfdd034e4c10bdd3ba523e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d792d4afbcfdd034e4c10bdd3ba523e">&#9670;&nbsp;</a></span>loadResidues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadResidues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>resf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load residues from an RTP file. </p>
<p >Standard RTP files can be used by DeNovo for loading residues. Each residue has unique atom names for each atom which is then mapped to a forcefield atom type. (Open protein.rtp attached with DeNovo to see the format)<br  />
 These files can be found in GROMACS data files, or (with enough effort) written manually. It's preferred to use GROMACS rtp files so that GROMACS can be used to convert/rewrite PDB files (and hence the atom-type names and unique names of all the atoms match)<br  />
 The protein.rtp and dna.rtp files are taken from GROMACS data files for the CHARMM-27 forcefield based on which the DeNovo generation is based as well. </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l01183">1183</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span>{</div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span>    ifstream fs; fs.open(resf,ios::in);</div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span>    std::string curline,section,resname;</div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span>    std::vector&lt;std::string&gt; lineset;</div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span>    <a class="code hl_variable" href="classForceField.html#a27f1592a6daf0ce6ed413cb936424787">residues</a>=std::vector&lt;Residue&gt;();</div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span>    <span class="keywordtype">bool</span> appmode=<span class="keyword">false</span>;</div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span>    <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span>    {</div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span>        getline(fs,curline);</div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span>        <span class="keywordflow">if</span>(fs.eof()) <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span>        <span class="keywordtype">int</span> bI=<a class="code hl_function" href="namespacestringfx.html#a39713d3c86433bb2f090df0c6c37a565">stringfx::indexOf</a>(<span class="charliteral">&#39;[&#39;</span>,curline);</div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"> 1195</span>        <span class="keywordflow">if</span>(bI!=-1)</div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span>        {</div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span>            <span class="keywordtype">int</span> ebI=<a class="code hl_function" href="namespacestringfx.html#a39713d3c86433bb2f090df0c6c37a565">stringfx::indexOf</a>(<span class="charliteral">&#39;]&#39;</span>,curline);</div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span>            section=<a class="code hl_function" href="namespacestringfx.html#aa81116cbad8cb2190429822b6fd14307">stringfx::trim</a>(curline.substr(bI+1,ebI-bI-1));</div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span>            <span class="keywordflow">if</span>(section==<span class="stringliteral">&quot;atoms&quot;</span>) {appmode=<span class="keyword">true</span>; <span class="keywordflow">continue</span>;}</div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span>            <span class="keywordflow">else</span></div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"> 1201</span>            {</div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"> 1202</span>                appmode=<span class="keyword">false</span>;</div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"> 1203</span>                <span class="keywordflow">if</span>(lineset.size())</div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"> 1204</span>                {</div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span>                    <a class="code hl_variable" href="classForceField.html#a27f1592a6daf0ce6ed413cb936424787">residues</a>.push_back(<a class="code hl_class" href="classResidue.html">Residue</a>(resname,lineset));</div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span>                    lineset=std::vector&lt;std::string&gt;();</div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span>                }</div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span>                resname=section;</div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span>            }</div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span>        }</div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span>        <span class="keywordflow">if</span>(appmode) lineset.push_back(curline);</div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span>    }</div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"> 1214</span>    cout &lt;&lt; <a class="code hl_variable" href="classForceField.html#a27f1592a6daf0ce6ed413cb936424787">residues</a>.size()&lt;&lt;<span class="stringliteral">&quot; residues loaded.\n&quot;</span>;</div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"> 1215</span>}</div>
<div class="ttc" id="aclassForceField_html_a27f1592a6daf0ce6ed413cb936424787"><div class="ttname"><a href="classForceField.html#a27f1592a6daf0ce6ed413cb936424787">ForceField::residues</a></div><div class="ttdeci">std::vector&lt; Residue &gt; residues</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00323">forcefield.hpp:323</a></div></div>
<div class="ttc" id="aclassResidue_html"><div class="ttname"><a href="classResidue.html">Residue</a></div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00071">forcefield.hpp:72</a></div></div>
<div class="ttc" id="anamespacestringfx_html_a39713d3c86433bb2f090df0c6c37a565"><div class="ttname"><a href="namespacestringfx.html#a39713d3c86433bb2f090df0c6c37a565">stringfx::indexOf</a></div><div class="ttdeci">int indexOf(char c, const std::string &amp;s)</div><div class="ttdoc">Find the index of a character in a string.</div><div class="ttdef"><b>Definition:</b> <a href="commons_8h_source.html#l00323">commons.h:323</a></div></div>
<div class="ttc" id="anamespacestringfx_html_aa81116cbad8cb2190429822b6fd14307"><div class="ttname"><a href="namespacestringfx.html#aa81116cbad8cb2190429822b6fd14307">stringfx::trim</a></div><div class="ttdeci">std::string trim(const std::string &amp;aString)</div><div class="ttdoc">Trim (remove trailing spaces from) a string.</div><div class="ttdef"><b>Definition:</b> <a href="commons_8h_source.html#l00406">commons.h:406</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4fd86ba2d60c42c52569c340ce812a72" name="a4fd86ba2d60c42c52569c340ce812a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd86ba2d60c42c52569c340ce812a72">&#9670;&nbsp;</a></span>loadRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ForceField::loadRules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emptyRules</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load rules from a given file. </p>
<p >Rules define what atom-atom bonds are allowed, and how many. See the atom-type definition section of documentation PDF for more details on format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fl</td><td>Input filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">emptyRules</td><td>Remove existing rule data? (Default: Yes) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00483">483</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span>{<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>=<a class="code hl_function" href="namespacechemtools.html#ac0566d6420d090a2cd4d9530bca1b769">chemtools::getRuleset</a>(fl,<span class="keyword">this</span>); cout &lt;&lt; <span class="stringliteral">&quot;Loaded rules. Rules for &quot;</span>&lt;&lt;<a class="code hl_variable" href="classForceField.html#a7ca2da8607b87bcc0c089614a548c4fa">rules</a>.size()&lt;&lt;<span class="stringliteral">&quot; atom types found\n&quot;</span>;}</div>
<div class="ttc" id="anamespacechemtools_html_ac0566d6420d090a2cd4d9530bca1b769"><div class="ttname"><a href="namespacechemtools.html#ac0566d6420d090a2cd4d9530bca1b769">chemtools::getRuleset</a></div><div class="ttdeci">static std::vector&lt; std::pair&lt; std::string, std::vector&lt; Rule &gt; &gt; &gt; getRuleset(const std::string &amp;file, const ForceField *ff=nullptr)</div><div class="ttdoc">Load all rules from a file.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l01287">forcefield.hpp:1287</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a314a55483177e20397b04e185b37b2ed" name="a314a55483177e20397b04e185b37b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314a55483177e20397b04e185b37b2ed">&#9670;&nbsp;</a></span>selectAtomByRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectAtomByRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMolecule.html">Molecule</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>temp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Situationally choose an atom that can bond to the selected atom. </p>
<p >Get a copy of one of the loaded atom-types such that it can bond to the source atom (see params).<br  />
 This function ensures that after adding this bond, the no atom-type definitions are violated. No checks are made to ensure that all the rules can still be satisfied after this stage. It is assumed that the rules are sane enough to allow the atom-type to satisfy them </p>

</div>
</div>
<a id="a95d0676e821612c47f3675c790cac28a" name="a95d0676e821612c47f3675c790cac28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d0676e821612c47f3675c790cac28a">&#9670;&nbsp;</a></span>selectRandomBondableAtom() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectRandomBondableAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>bias</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random atom that can bond to this atom but bias the output. </p>
<p >This function biases the output of the random result to return an atom-type of the same element as the biasing atom (actually it biases using the first character, so CL and BR cannot be bias targets)<br  />
 If no such atom-type is available, then a random atom is returned. If multiple atom-types of the bias element are available, one is chosen randomly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The atom which has to form the bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The atom-type (technically element) to which to bias the result </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00608">608</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span>    {</div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span>        std::vector&lt;std::string&gt; allatoms,biasedatoms;</div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span>        std::string temp=a-&gt;toString(),temp2;</div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_class" href="classBondData.html">BondData</a>&amp; bd : <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a))</div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span>        {</div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span>            temp2=bd.getSecond(temp);</div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span>            allatoms.push_back(temp2);</div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span>            <span class="keywordflow">if</span>(bias &amp;&amp; temp2[0]==bias-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]) biasedatoms.push_back(temp2);</div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span>        }</div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span>        <span class="keywordflow">if</span>(!allatoms.size()) <span class="keywordflow">throw</span> <a class="code hl_class" href="classNoBondsAvailableException.html">NoBondsAvailableException</a>();</div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span>        <span class="keywordflow">if</span>(!biasedatoms.size()) <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(allatoms));</div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span>        <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(biasedatoms));</div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span>    }</div>
<div class="ttc" id="aclassForceField_html_a388e3f80e59286f915299e61341d078f"><div class="ttname"><a href="classForceField.html#a388e3f80e59286f915299e61341d078f">ForceField::getAtom</a></div><div class="ttdeci">Atom * getAtom(const std::string &amp;s) const</div><div class="ttdoc">Get a copy of an atom-type loaded into this ForceField by name.</div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00540">forcefield.hpp:540</a></div></div>
<div class="ttc" id="aclassNoBondsAvailableException_html"><div class="ttname"><a href="classNoBondsAvailableException.html">NoBondsAvailableException</a></div><div class="ttdef"><b>Definition:</b> <a href="forcefield_8hpp_source.html#l00017">forcefield.hpp:17</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a95d0676e821612c47f3675c790cac28a" name="a95d0676e821612c47f3675c790cac28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d0676e821612c47f3675c790cac28a">&#9670;&nbsp;</a></span>selectRandomBondableAtom() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectRandomBondableAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>bias</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random atom that can bond to this atom but bias the output. </p>
<p >This function biases the output of the random result to return an atom-type of the same element as the biasing atom (actually it biases using the first character, so CL and BR cannot be bias targets)<br  />
 If no such atom-type is available, then a random atom is returned. If multiple atom-types of the bias element are available, one is chosen randomly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The atom which has to form the bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The atom-type (technically element) to which to bias the result </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00561">561</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span>    {</div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span>        std::vector&lt;std::string&gt; allatoms,biasedatoms;</div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>        std::string temp=a-&gt;toString(),temp2;</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_class" href="classBondData.html">BondData</a>&amp; bd : <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a))</div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span>        {</div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>            temp2=bd.getSecond(temp);</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span>            allatoms.push_back(temp2);</div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span>            <span class="keywordflow">if</span>(bias &amp;&amp; temp2[0]==bias-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]) biasedatoms.push_back(temp2);</div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span>        }</div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span>        <span class="keywordflow">if</span>(!allatoms.size()) <span class="keywordflow">throw</span> <a class="code hl_class" href="classNoBondsAvailableException.html">NoBondsAvailableException</a>();</div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span>        <span class="keywordflow">if</span>(!biasedatoms.size()) <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(allatoms));</div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span>        <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(biasedatoms));</div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a95d0676e821612c47f3675c790cac28a" name="a95d0676e821612c47f3675c790cac28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d0676e821612c47f3675c790cac28a">&#9670;&nbsp;</a></span>selectRandomBondableAtom() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectRandomBondableAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>bias</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random atom that can bond to this atom but bias the output. </p>
<p >This function biases the output of the random result to return an atom-type of the same element as the biasing atom (actually it biases using the first character, so CL and BR cannot be bias targets)<br  />
 If no such atom-type is available, then a random atom is returned. If multiple atom-types of the bias element are available, one is chosen randomly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The atom which has to form the bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The atom-type (technically element) to which to bias the result </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html#l00508">508</a> of file <a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span>    {</div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span>        std::vector&lt;std::string&gt; allatoms,biasedatoms;</div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span>        std::string temp=a-&gt;toString(),temp2;</div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_class" href="classBondData.html">BondData</a>&amp; bd : <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a))</div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span>        {</div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span>            temp2=bd.getSecond(temp);</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span>            allatoms.push_back(temp2);</div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span>            <span class="keywordflow">if</span>(bias &amp;&amp; temp2[0]==bias-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]) biasedatoms.push_back(temp2);</div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span>        }</div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span>        <span class="keywordflow">if</span>(!allatoms.size()) <a class="code hl_class" href="classNoBondsAvailableException.html">NoBondsAvailableException</a>();</div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span>        <span class="keywordflow">if</span>(!biasedatoms.size()) <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(allatoms));</div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span>        <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(biasedatoms));</div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a95d0676e821612c47f3675c790cac28a" name="a95d0676e821612c47f3675c790cac28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d0676e821612c47f3675c790cac28a">&#9670;&nbsp;</a></span>selectRandomBondableAtom() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectRandomBondableAtom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>bias</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random atom that can bond to this atom but bias the output. </p>
<p >This function biases the output of the random result to return an atom-type of the same element as the biasing atom (actually it biases using the first character, so CL and BR cannot be bias targets)<br  />
 If no such atom-type is available, then a random atom is returned. If multiple atom-types of the bias element are available, one is chosen randomly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The atom which has to form the bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The atom-type (technically element) to which to bias the result </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00559">559</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span>    {</div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span>        std::vector&lt;std::string&gt; allatoms,biasedatoms;</div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span>        std::string temp=a-&gt;toString(),temp2;</div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_class" href="classBondData.html">BondData</a>&amp; bd : <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a))</div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>        {</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span>            temp2=bd.getSecond(temp);</div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span>            allatoms.push_back(temp2);</div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>            <span class="keywordflow">if</span>(bias &amp;&amp; temp2[0]==bias-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]) biasedatoms.push_back(temp2);</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span>        }</div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span>        <span class="keywordflow">if</span>(!allatoms.size()) <span class="keywordflow">throw</span> <a class="code hl_class" href="classNoBondsAvailableException.html">NoBondsAvailableException</a>();</div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span>        <span class="keywordflow">if</span>(!biasedatoms.size()) <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(allatoms));</div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span>        <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code hl_function" href="classForceField.html#a388e3f80e59286f915299e61341d078f">getAtom</a>(randomSelect(biasedatoms));</div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aab183018c1dce0c5c93e1dd36eccd57e" name="aab183018c1dce0c5c93e1dd36eccd57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab183018c1dce0c5c93e1dd36eccd57e">&#9670;&nbsp;</a></span>selectRandomBondableAtomTerminal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectRandomBondableAtomTerminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>bias</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random terminal atom that can bond to this atom but bias the output. </p>
<p >This function biases the output of the random result to return an atom-type of the same element as the biasing atom (actually it biases using the first character, so CL and BR cannot be bias targets)<br  />
If no such atom-type is available, then a random atom is returned. If multiple atom-types of the bias element are available, one is chosen randomly.<br  />
 Note that this function specifically looks for a <b>terminal</b> atom. If no terminals are possible, a nullptr is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The atom which has to form the bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The atom-type (technically element) to which to bias the result </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00628">628</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span>    {</div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span>        std::vector&lt;Atom*&gt; allatoms,biasedatoms;</div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span>        <a class="code hl_class" href="classAtom.html">Atom</a>* temp2=<span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_class" href="classBondData.html">BondData</a>&amp; bd : <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a))</div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span>        {</div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span>            temp2=bd.getSecond(a,*<span class="keyword">this</span>);</div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span>            <span class="keywordflow">if</span>(!temp2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span>            <span class="keywordflow">if</span>(temp2-&gt;<a class="code hl_function" href="classAtom.html#a262d1cb2ea75ec2ced42bc995bc49fc3">getStandardValency</a>()==1)  allatoms.push_back(temp2);</div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span>            <span class="keywordflow">else</span> {<span class="keyword">delete</span> temp2; <span class="keywordflow">continue</span>;}</div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span>            <span class="keywordflow">if</span>(bias &amp;&amp; temp2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]==bias-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]) biasedatoms.push_back(temp2);</div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span>        }</div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span>        <span class="keywordflow">if</span>(!allatoms.size()) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span>        <a class="code hl_class" href="classAtom.html">Atom</a>* reta;</div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span>        <span class="keywordflow">if</span>(!biasedatoms.size()) reta=randomSelect(allatoms);</div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span>        <span class="keywordflow">else</span> reta=randomSelect(biasedatoms);</div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span>        <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>*&amp; ap : allatoms) {<span class="keywordflow">if</span>(ap!=reta) <span class="keyword">delete</span> ap;}</div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span>        <span class="keywordflow">return</span> reta;</div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span>    }</div>
<div class="ttc" id="aclassAtom_html_a262d1cb2ea75ec2ced42bc995bc49fc3"><div class="ttname"><a href="classAtom.html#a262d1cb2ea75ec2ced42bc995bc49fc3">Atom::getStandardValency</a></div><div class="ttdeci">int getStandardValency() const</div><div class="ttdoc">Get the force-field (or otherwise loaded) maximum allowed valency for this atom.</div><div class="ttdef"><b>Definition:</b> <a href="Atom_8hpp_source.html#l00120">Atom.hpp:120</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aab183018c1dce0c5c93e1dd36eccd57e" name="aab183018c1dce0c5c93e1dd36eccd57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab183018c1dce0c5c93e1dd36eccd57e">&#9670;&nbsp;</a></span>selectRandomBondableAtomTerminal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectRandomBondableAtomTerminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>bias</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random terminal atom that can bond to this atom but bias the output. </p>
<p >This function biases the output of the random result to return an atom-type of the same element as the biasing atom (actually it biases using the first character, so CL and BR cannot be bias targets)<br  />
If no such atom-type is available, then a random atom is returned. If multiple atom-types of the bias element are available, one is chosen randomly.<br  />
 Note that this function specifically looks for a <b>terminal</b> atom. If no terminals are possible, a nullptr is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The atom which has to form the bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The atom-type (technically element) to which to bias the result </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp_8hpp_source.html#l00581">581</a> of file <a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span>    {</div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span>        std::vector&lt;Atom*&gt; allatoms,biasedatoms;</div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span>        <a class="code hl_class" href="classAtom.html">Atom</a>* temp2=<span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_class" href="classBondData.html">BondData</a>&amp; bd : <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a))</div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>        {</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span>            temp2=bd.getSecond(a,*<span class="keyword">this</span>);</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span>            <span class="keywordflow">if</span>(!temp2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span>            <span class="keywordflow">if</span>(temp2-&gt;<a class="code hl_function" href="classAtom.html#a262d1cb2ea75ec2ced42bc995bc49fc3">getStandardValency</a>()==1)  allatoms.push_back(temp2);</div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span>            <span class="keywordflow">else</span> {<span class="keyword">delete</span> temp2; <span class="keywordflow">continue</span>;}</div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span>            <span class="keywordflow">if</span>(bias &amp;&amp; temp2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]==bias-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]) biasedatoms.push_back(temp2);</div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span>        }</div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span>        <span class="keywordflow">if</span>(!allatoms.size()) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span>        <a class="code hl_class" href="classAtom.html">Atom</a>* reta;</div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span>        <span class="keywordflow">if</span>(!biasedatoms.size()) reta=randomSelect(allatoms);</div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span>        <span class="keywordflow">else</span> reta=randomSelect(biasedatoms);</div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span>        <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>*&amp; ap : allatoms) {<span class="keywordflow">if</span>(ap!=reta) <span class="keyword">delete</span> ap;}</div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span>        <span class="keywordflow">return</span> reta;</div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aab183018c1dce0c5c93e1dd36eccd57e" name="aab183018c1dce0c5c93e1dd36eccd57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab183018c1dce0c5c93e1dd36eccd57e">&#9670;&nbsp;</a></span>selectRandomBondableAtomTerminal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtom.html">Atom</a> * ForceField::selectRandomBondableAtomTerminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtom.html">Atom</a> *&#160;</td>
          <td class="paramname"><em>bias</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random terminal atom that can bond to this atom but bias the output. </p>
<p >This function biases the output of the random result to return an atom-type of the same element as the biasing atom (actually it biases using the first character, so CL and BR cannot be bias targets)<br  />
If no such atom-type is available, then a random atom is returned. If multiple atom-types of the bias element are available, one is chosen randomly.<br  />
 Note that this function specifically looks for a <b>terminal</b> atom. If no terminals are possible, a nullptr is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The atom which has to form the bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bias</td><td>The atom-type (technically element) to which to bias the result </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html#l00579">579</a> of file <a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a>.</p>
<div class="fragment"><div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span>    {</div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span>        std::vector&lt;Atom*&gt; allatoms,biasedatoms;</div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span>        <a class="code hl_class" href="classAtom.html">Atom</a>* temp2=<span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <a class="code hl_class" href="classBondData.html">BondData</a>&amp; bd : <a class="code hl_function" href="classForceField.html#a11ef1ec5670fc1755a3ad4618d63d734">getAllowedBonds</a>(a))</div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span>        {</div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span>            temp2=bd.getSecond(a,*<span class="keyword">this</span>);</div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>            <span class="keywordflow">if</span>(!temp2) <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span>            <span class="keywordflow">if</span>(temp2-&gt;<a class="code hl_function" href="classAtom.html#a262d1cb2ea75ec2ced42bc995bc49fc3">getStandardValency</a>()==1)  allatoms.push_back(temp2);</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span>            <span class="keywordflow">else</span> {<span class="keyword">delete</span> temp2; <span class="keywordflow">continue</span>;}</div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span>            <span class="keywordflow">if</span>(bias &amp;&amp; temp2-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]==bias-&gt;<a class="code hl_function" href="classAtom.html#a189def3b8bade8507d49cfd7de881178">toString</a>()[0]) biasedatoms.push_back(temp2);</div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span>        }</div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span>        <span class="keywordflow">if</span>(!allatoms.size()) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span>        <a class="code hl_class" href="classAtom.html">Atom</a>* reta;</div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span>        <span class="keywordflow">if</span>(!biasedatoms.size()) reta=randomSelect(allatoms);</div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span>        <span class="keywordflow">else</span> reta=randomSelect(biasedatoms);</div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span>        <span class="keywordflow">for</span>(<a class="code hl_class" href="classAtom.html">Atom</a>*&amp; ap : allatoms) {<span class="keywordflow">if</span>(ap!=reta) <span class="keyword">delete</span> ap;}</div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span>        <span class="keywordflow">return</span> reta;</div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae198b91b5ffc6278887ae798837d45e8" name="ae198b91b5ffc6278887ae798837d45e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae198b91b5ffc6278887ae798837d45e8">&#9670;&nbsp;</a></span>angle_parameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; vector_s, vector_d &gt; &gt; ForceField::angle_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Angle parameter data. It maps string vectors (list of atoms contributing to the angle formation) to angle parameters (including Urey-Bradley parameters - See documentation PDF for details) </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00328">328</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="a2d43f27c2cbca56da3deb919cd401d99" name="a2d43f27c2cbca56da3deb919cd401d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d43f27c2cbca56da3deb919cd401d99">&#9670;&nbsp;</a></span>atom_types</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classAtom.html">Atom</a> * &gt; ForceField::atom_types</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The list that stores one <a class="el" href="classAtom.html">Atom</a> object copy for each atom-type. These objects are cloned (see <a class="el" href="classAtom.html#a4a32546c48786b6e531e7177cec70fa2" title="The standard copy constructor.">Atom::Atom(const Atom&amp;)</a>) when a new <a class="el" href="classAtom.html">Atom</a> of a particular atom-type name is retrieved from this <a class="el" href="classForceField.html">ForceField</a> </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00320">320</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="a90e6ae752fd0f03399f1f8cfdfff12f7" name="a90e6ae752fd0f03399f1f8cfdfff12f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e6ae752fd0f03399f1f8cfdfff12f7">&#9670;&nbsp;</a></span>atombondmap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; &gt; &gt; ForceField::atombondmap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This list maps each atom-type to a list of bonds (stored as <a class="el" href="classBondData.html">BondData</a> objects) which are bonds it is allowed to make. </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00331">331</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="ae5aeed0193bd434dbae1ed6f457a6c75" name="ae5aeed0193bd434dbae1ed6f457a6c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5aeed0193bd434dbae1ed6f457a6c75">&#9670;&nbsp;</a></span>categories</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classCategory.html">Category</a> &gt; ForceField::categories</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores the list of categories loaded into this <a class="el" href="classForceField.html">ForceField</a> (see: <a class="el" href="classCategory.html">Category</a>) </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00321">321</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="af752c7414672539b59ab0815b0ca50cd" name="af752c7414672539b59ab0815b0ca50cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af752c7414672539b59ab0815b0ca50cd">&#9670;&nbsp;</a></span>defaultconnectivities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; char, int &gt; &gt; ForceField::defaultconnectivities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default connectivity data to be used (if no valencies are loaded - such as for an incomplete forcefield). Especially used for calculating Bond orders </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00325">325</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="aa1d02343fc1649e13677701899841679" name="aa1d02343fc1649e13677701899841679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d02343fc1649e13677701899841679">&#9670;&nbsp;</a></span>dihedral_parameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; vector_s, vector_d &gt; &gt; ForceField::dihedral_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Dihedral parameter data. It maps string vectors (list of atom names for the atoms contributing to the dihedral formation in proper order) to dihedral parameters (equilibrium value,force-constant,multiplicity) </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00329">329</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="a1c0c7a249011a551ed43d3abd6db2d0b" name="a1c0c7a249011a551ed43d3abd6db2d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0c7a249011a551ed43d3abd6db2d0b">&#9670;&nbsp;</a></span>electronegativities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; char, double &gt; &gt; ForceField::electronegativities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Still under development - intended to be used for Gasteiger Charge calculation </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00324">324</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="af14e5e64ad6163c41904507e7dac0803" name="af14e5e64ad6163c41904507e7dac0803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14e5e64ad6163c41904507e7dac0803">&#9670;&nbsp;</a></span>improper_parameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; vector_s, pair_dd &gt; &gt; ForceField::improper_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Similar to dihedral_parameters. It maps atom lists to improper dihedral parameters </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00330">330</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="af96ba6f982c2595b5b10199f8595f78b" name="af96ba6f982c2595b5b10199f8595f78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96ba6f982c2595b5b10199f8595f78b">&#9670;&nbsp;</a></span>length_parameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classBondData.html">BondData</a> &gt; ForceField::length_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Bond data stored in <a class="el" href="classBondData.html">BondData</a> objects. They contain a pair of atom-types which contribute to forming the bond, and the bond parameters (equilibrium length and force-constant) </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00327">327</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="a5b05b6e971278625ec83106dc70cc1f7" name="a5b05b6e971278625ec83106dc70cc1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b05b6e971278625ec83106dc70cc1f7">&#9670;&nbsp;</a></span>one_four_interactions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; pair_ss, pair_dd &gt; &gt; ForceField::one_four_interactions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stores 1-4 interaction parameters. Not used in later versions of DeNovo </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00333">333</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="a19b597eadca31d11346a53b49c3eb4d4" name="a19b597eadca31d11346a53b49c3eb4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b597eadca31d11346a53b49c3eb4d4">&#9670;&nbsp;</a></span>other_interactions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, vector_d &gt; &gt; ForceField::other_interactions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stores L-J interaction parameters. Not used in later versions of DeNovo. These parameters are taken directly from the atom-types </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00334">334</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="a27f1592a6daf0ce6ed413cb936424787" name="a27f1592a6daf0ce6ed413cb936424787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f1592a6daf0ce6ed413cb936424787">&#9670;&nbsp;</a></span>residues</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classResidue.html">Residue</a> &gt; ForceField::residues</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classResidue.html">Residue</a> objects can also be stored when loading residues from an RTP file (see <a class="el" href="classForceField.html#a6d792d4afbcfdd034e4c10bdd3ba523e" title="Load residues from an RTP file.">loadResidues()</a>) </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00323">323</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<a id="a7ca2da8607b87bcc0c089614a548c4fa" name="a7ca2da8607b87bcc0c089614a548c4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca2da8607b87bcc0c089614a548c4fa">&#9670;&nbsp;</a></span>rules</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, std::vector&lt; <a class="el" href="classchemtools_1_1Rule.html">chemtools::Rule</a> &gt; &gt; &gt; ForceField::rules</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Maps each atom type to a set of rules (which are the atom-type definition rules). See <a class="el" href="classchemtools_1_1Rule.html">chemtools::Rule</a> and atom-type definition rules in the documentation (PDF) </p>

<p class="definition">Definition at line <a class="el" href="forcefield_8hpp_source.html#l00322">322</a> of file <a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>forcefield/<a class="el" href="forcefield_8hpp_source.html">forcefield.hpp</a></li>
<li>forcefield/<a class="el" href="forcefield__precomp_8hpp_source.html">forcefield_precomp.hpp</a></li>
<li>forcefield/<a class="el" href="forcefield__precomp__omega__stable_8hpp_source.html">forcefield_precomp_omega_stable.hpp</a></li>
<li>forcefield/<a class="el" href="forcefield__precomp__omega__stable2_8hpp_source.html">forcefield_precomp_omega_stable2.hpp</a></li>
<li>graph/<a class="el" href="Molecule_8hpp_source.html">Molecule.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
