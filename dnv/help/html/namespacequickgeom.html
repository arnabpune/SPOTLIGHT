<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Denovo omega: quickgeom Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Denovo omega<span id="projectnumber">&#160;0.0</span>
   </div>
   <div id="projectbrief">A de-novo optimum-binder molecule-design program.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">quickgeom Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickgeom_1_1Container.html">Container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickgeom_1_1ContainerUnion.html">ContainerUnion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickgeom_1_1Cuboid.html">Cuboid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickgeom_1_1Sphere.html">Sphere</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96b76be4834ffe4dda706fcb091fe9b1"><td class="memItemLeft" align="right" valign="top"><a id="a96b76be4834ffe4dda706fcb091fe9b1" name="a96b76be4834ffe4dda706fcb091fe9b1"></a>
static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomUnitVector</b> (int devid=0)</td></tr>
<tr class="memdesc:a96b76be4834ffe4dda706fcb091fe9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get literally <b>any</b> random unit vector. <br /></td></tr>
<tr class="separator:a96b76be4834ffe4dda706fcb091fe9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e4c893cad9213aba7e80dc2345c2b2"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#a02e4c893cad9213aba7e80dc2345c2b2">getRandomVectorInShell</a> (const Eigen::Vector3d &amp;origin, const double &amp;radius, int devid=0)</td></tr>
<tr class="memdesc:a02e4c893cad9213aba7e80dc2345c2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random vector pointing to a point at a given distance from a fixed center.  <a href="namespacequickgeom.html#a02e4c893cad9213aba7e80dc2345c2b2">More...</a><br /></td></tr>
<tr class="separator:a02e4c893cad9213aba7e80dc2345c2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6886551455b71fe88580560aae508"><td class="memItemLeft" align="right" valign="top"><a id="a78c6886551455b71fe88580560aae508" name="a78c6886551455b71fe88580560aae508"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomVectorsInShell</b> (const Eigen::Vector3d &amp;origin, const double &amp;radius, int sampleSize, int devid=0)</td></tr>
<tr class="memdesc:a78c6886551455b71fe88580560aae508"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to generate multiple vectors around a given centre (useful while trialling seed positions or the position of the second atom). See <a class="el" href="namespacequickgeom.html#a92859df06e8b2131cd4a358ccb4fe722" title="Get a random vector pointing to a point at a given distance from a fixed center.">getRandomVectorInShell(const Eigen::Vector3d&amp;,const double&amp;)</a> <br /></td></tr>
<tr class="separator:a78c6886551455b71fe88580560aae508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215bf456c473c34054e4be483d30bd28"><td class="memItemLeft" align="right" valign="top"><a id="a215bf456c473c34054e4be483d30bd28" name="a215bf456c473c34054e4be483d30bd28"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>angleBetween</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2)</td></tr>
<tr class="memdesc:a215bf456c473c34054e4be483d30bd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angle subtended by two vectors. <br /></td></tr>
<tr class="separator:a215bf456c473c34054e4be483d30bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9931a326c1368d02b5249e68a0cd00ee"><td class="memItemLeft" align="right" valign="top"><a id="a9931a326c1368d02b5249e68a0cd00ee" name="a9931a326c1368d02b5249e68a0cd00ee"></a>
static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>planeOf</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2)</td></tr>
<tr class="memdesc:a9931a326c1368d02b5249e68a0cd00ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normal unit vector to the plane created by two vectors. <br /></td></tr>
<tr class="separator:a9931a326c1368d02b5249e68a0cd00ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a172b92f8eee792705499c271696954"><td class="memItemLeft" align="right" valign="top"><a id="a3a172b92f8eee792705499c271696954" name="a3a172b92f8eee792705499c271696954"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>dihedralBetween</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2, const Eigen::Vector3d &amp;v3)</td></tr>
<tr class="memdesc:a3a172b92f8eee792705499c271696954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given three bond vectors, calculate the dihedral angle they make. <br /></td></tr>
<tr class="separator:a3a172b92f8eee792705499c271696954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c722fa92ca4d7948501f81c1de9f17f"><td class="memItemLeft" align="right" valign="top"><a id="a0c722fa92ca4d7948501f81c1de9f17f" name="a0c722fa92ca4d7948501f81c1de9f17f"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>getRotationMatrix</b> (const Eigen::Vector3d &amp;axis, double angle)</td></tr>
<tr class="memdesc:a0c722fa92ca4d7948501f81c1de9f17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation matrix for rotation about a particular axis, by a given angle. <br /></td></tr>
<tr class="separator:a0c722fa92ca4d7948501f81c1de9f17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15be590bb59c45ea47f2501c383cb467"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#a15be590bb59c45ea47f2501c383cb467">getRotation</a> (const Eigen::Vector3d &amp;vi, const Eigen::Vector3d &amp;vf)</td></tr>
<tr class="memdesc:a15be590bb59c45ea47f2501c383cb467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation matrix to rotate a vector from intital to final state.  <a href="namespacequickgeom.html#a15be590bb59c45ea47f2501c383cb467">More...</a><br /></td></tr>
<tr class="separator:a15be590bb59c45ea47f2501c383cb467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a985eca968dd07d69c6460717c1d1c"><td class="memItemLeft" align="right" valign="top"><a id="aa2a985eca968dd07d69c6460717c1d1c" name="aa2a985eca968dd07d69c6460717c1d1c"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getConePositions</b> (const Eigen::Vector3d &amp;fixed, double length, double angle, int num=10, int devid=0)</td></tr>
<tr class="memdesc:aa2a985eca968dd07d69c6460717c1d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get positions inside the cross-section of cone for trialling positions with given bond length and angle. <br /></td></tr>
<tr class="separator:aa2a985eca968dd07d69c6460717c1d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60aae27d8f525f83c7088e81fcda69f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#af60aae27d8f525f83c7088e81fcda69f">getArcPositions</a> (const Eigen::Vector3d &amp;fixed, const Eigen::Vector3d &amp;def, double length, double angle, const std::vector&lt; double &gt; &amp;dihedral, int num=10, int devid=0)</td></tr>
<tr class="memdesc:af60aae27d8f525f83c7088e81fcda69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function used for generating trial positions with a given length, angle and set of allowed dihedrals.  <a href="namespacequickgeom.html#af60aae27d8f525f83c7088e81fcda69f">More...</a><br /></td></tr>
<tr class="separator:af60aae27d8f525f83c7088e81fcda69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315e97c84928b360f2c24b0cc39f2831"><td class="memItemLeft" align="right" valign="top"><a id="a315e97c84928b360f2c24b0cc39f2831" name="a315e97c84928b360f2c24b0cc39f2831"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getArcPositions</b> (const Eigen::Vector3d &amp;fixed, const Eigen::Vector3d &amp;def, double length, double angle, double dihedral, int num=10)</td></tr>
<tr class="memdesc:a315e97c84928b360f2c24b0cc39f2831"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for calling <a class="el" href="namespacequickgeom.html#af60aae27d8f525f83c7088e81fcda69f" title="The function used for generating trial positions with a given length, angle and set of allowed dihedr...">getArcPositions()</a> with a single allowed dihedral instead of a set. <br /></td></tr>
<tr class="separator:a315e97c84928b360f2c24b0cc39f2831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87a99974f08e140495028c84bd5218f"><td class="memItemLeft" align="right" valign="top"><a id="ac87a99974f08e140495028c84bd5218f" name="ac87a99974f08e140495028c84bd5218f"></a>
static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomPositionInSpace</b> (<a class="el" href="classquickgeom_1_1Container.html">quickgeom::Container</a> *cnt)</td></tr>
<tr class="memdesc:ac87a99974f08e140495028c84bd5218f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRNG.html">RNG</a> to generate positions in any region in space. <br /></td></tr>
<tr class="separator:ac87a99974f08e140495028c84bd5218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af810526addff4d3fcd284afde1687573"><td class="memItemLeft" align="right" valign="top"><a id="af810526addff4d3fcd284afde1687573" name="af810526addff4d3fcd284afde1687573"></a>
static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomUnitVector</b> ()</td></tr>
<tr class="memdesc:af810526addff4d3fcd284afde1687573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get literally <b>any</b> random unit vector. <br /></td></tr>
<tr class="separator:af810526addff4d3fcd284afde1687573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92859df06e8b2131cd4a358ccb4fe722"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#a92859df06e8b2131cd4a358ccb4fe722">getRandomVectorInShell</a> (const Eigen::Vector3d &amp;origin, const double &amp;radius)</td></tr>
<tr class="memdesc:a92859df06e8b2131cd4a358ccb4fe722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random vector pointing to a point at a given distance from a fixed center.  <a href="namespacequickgeom.html#a92859df06e8b2131cd4a358ccb4fe722">More...</a><br /></td></tr>
<tr class="separator:a92859df06e8b2131cd4a358ccb4fe722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d72bdab9c2441d326788d2b50d29602"><td class="memItemLeft" align="right" valign="top"><a id="a7d72bdab9c2441d326788d2b50d29602" name="a7d72bdab9c2441d326788d2b50d29602"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomVectorsInShell</b> (const Eigen::Vector3d &amp;origin, const double &amp;radius, int sampleSize)</td></tr>
<tr class="memdesc:a7d72bdab9c2441d326788d2b50d29602"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to generate multiple vectors around a given centre (useful while trialling seed positions or the position of the second atom). See <a class="el" href="namespacequickgeom.html#a92859df06e8b2131cd4a358ccb4fe722" title="Get a random vector pointing to a point at a given distance from a fixed center.">getRandomVectorInShell(const Eigen::Vector3d&amp;,const double&amp;)</a> <br /></td></tr>
<tr class="separator:a7d72bdab9c2441d326788d2b50d29602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215bf456c473c34054e4be483d30bd28"><td class="memItemLeft" align="right" valign="top"><a id="a215bf456c473c34054e4be483d30bd28" name="a215bf456c473c34054e4be483d30bd28"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>angleBetween</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2)</td></tr>
<tr class="memdesc:a215bf456c473c34054e4be483d30bd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angle subtended by two vectors. <br /></td></tr>
<tr class="separator:a215bf456c473c34054e4be483d30bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9931a326c1368d02b5249e68a0cd00ee"><td class="memItemLeft" align="right" valign="top"><a id="a9931a326c1368d02b5249e68a0cd00ee" name="a9931a326c1368d02b5249e68a0cd00ee"></a>
static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>planeOf</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2)</td></tr>
<tr class="memdesc:a9931a326c1368d02b5249e68a0cd00ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normal unit vector to the plane created by two vectors. <br /></td></tr>
<tr class="separator:a9931a326c1368d02b5249e68a0cd00ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a172b92f8eee792705499c271696954"><td class="memItemLeft" align="right" valign="top"><a id="a3a172b92f8eee792705499c271696954" name="a3a172b92f8eee792705499c271696954"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>dihedralBetween</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2, const Eigen::Vector3d &amp;v3)</td></tr>
<tr class="memdesc:a3a172b92f8eee792705499c271696954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given three bond vectors, calculate the dihedral angle they make. <br /></td></tr>
<tr class="separator:a3a172b92f8eee792705499c271696954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c722fa92ca4d7948501f81c1de9f17f"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#a0c722fa92ca4d7948501f81c1de9f17f">getRotationMatrix</a> (const Eigen::Vector3d &amp;axis, double angle)</td></tr>
<tr class="separator:a0c722fa92ca4d7948501f81c1de9f17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d8cab088ba791a90c1586a23f6feaf"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#a04d8cab088ba791a90c1586a23f6feaf">getArcPositions</a> (const Eigen::Vector3d &amp;fixed, const Eigen::Vector3d &amp;def, double length, double angle, const std::vector&lt; double &gt; &amp;dihedral, int num=10)</td></tr>
<tr class="memdesc:a04d8cab088ba791a90c1586a23f6feaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function used for generating trial positions with a given length, angle and set of allowed dihedrals.  <a href="namespacequickgeom.html#a04d8cab088ba791a90c1586a23f6feaf">More...</a><br /></td></tr>
<tr class="separator:a04d8cab088ba791a90c1586a23f6feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315e97c84928b360f2c24b0cc39f2831"><td class="memItemLeft" align="right" valign="top"><a id="a315e97c84928b360f2c24b0cc39f2831" name="a315e97c84928b360f2c24b0cc39f2831"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getArcPositions</b> (const Eigen::Vector3d &amp;fixed, const Eigen::Vector3d &amp;def, double length, double angle, double dihedral, int num=10)</td></tr>
<tr class="memdesc:a315e97c84928b360f2c24b0cc39f2831"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for calling <a class="el" href="namespacequickgeom.html#af60aae27d8f525f83c7088e81fcda69f" title="The function used for generating trial positions with a given length, angle and set of allowed dihedr...">getArcPositions()</a> with a single allowed dihedral instead of a set. <br /></td></tr>
<tr class="separator:a315e97c84928b360f2c24b0cc39f2831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b76be4834ffe4dda706fcb091fe9b1"><td class="memItemLeft" align="right" valign="top"><a id="a96b76be4834ffe4dda706fcb091fe9b1" name="a96b76be4834ffe4dda706fcb091fe9b1"></a>
static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomUnitVector</b> (int devid=0)</td></tr>
<tr class="memdesc:a96b76be4834ffe4dda706fcb091fe9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get literally <b>any</b> random unit vector. <br /></td></tr>
<tr class="separator:a96b76be4834ffe4dda706fcb091fe9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e4c893cad9213aba7e80dc2345c2b2"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#a02e4c893cad9213aba7e80dc2345c2b2">getRandomVectorInShell</a> (const Eigen::Vector3d &amp;origin, const double &amp;radius, int devid=0)</td></tr>
<tr class="memdesc:a02e4c893cad9213aba7e80dc2345c2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random vector pointing to a point at a given distance from a fixed center.  <a href="namespacequickgeom.html#a02e4c893cad9213aba7e80dc2345c2b2">More...</a><br /></td></tr>
<tr class="separator:a02e4c893cad9213aba7e80dc2345c2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6886551455b71fe88580560aae508"><td class="memItemLeft" align="right" valign="top"><a id="a78c6886551455b71fe88580560aae508" name="a78c6886551455b71fe88580560aae508"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getRandomVectorsInShell</b> (const Eigen::Vector3d &amp;origin, const double &amp;radius, int sampleSize, int devid=0)</td></tr>
<tr class="memdesc:a78c6886551455b71fe88580560aae508"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to generate multiple vectors around a given centre (useful while trialling seed positions or the position of the second atom). See <a class="el" href="namespacequickgeom.html#a92859df06e8b2131cd4a358ccb4fe722" title="Get a random vector pointing to a point at a given distance from a fixed center.">getRandomVectorInShell(const Eigen::Vector3d&amp;,const double&amp;)</a> <br /></td></tr>
<tr class="separator:a78c6886551455b71fe88580560aae508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215bf456c473c34054e4be483d30bd28"><td class="memItemLeft" align="right" valign="top"><a id="a215bf456c473c34054e4be483d30bd28" name="a215bf456c473c34054e4be483d30bd28"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>angleBetween</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2)</td></tr>
<tr class="memdesc:a215bf456c473c34054e4be483d30bd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the angle subtended by two vectors. <br /></td></tr>
<tr class="separator:a215bf456c473c34054e4be483d30bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9931a326c1368d02b5249e68a0cd00ee"><td class="memItemLeft" align="right" valign="top"><a id="a9931a326c1368d02b5249e68a0cd00ee" name="a9931a326c1368d02b5249e68a0cd00ee"></a>
static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>planeOf</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2)</td></tr>
<tr class="memdesc:a9931a326c1368d02b5249e68a0cd00ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normal unit vector to the plane created by two vectors. <br /></td></tr>
<tr class="separator:a9931a326c1368d02b5249e68a0cd00ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a172b92f8eee792705499c271696954"><td class="memItemLeft" align="right" valign="top"><a id="a3a172b92f8eee792705499c271696954" name="a3a172b92f8eee792705499c271696954"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>dihedralBetween</b> (const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2, const Eigen::Vector3d &amp;v3)</td></tr>
<tr class="memdesc:a3a172b92f8eee792705499c271696954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given three bond vectors, calculate the dihedral angle they make. <br /></td></tr>
<tr class="separator:a3a172b92f8eee792705499c271696954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c722fa92ca4d7948501f81c1de9f17f"><td class="memItemLeft" align="right" valign="top"><a id="a0c722fa92ca4d7948501f81c1de9f17f" name="a0c722fa92ca4d7948501f81c1de9f17f"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><b>getRotationMatrix</b> (const Eigen::Vector3d &amp;axis, double angle)</td></tr>
<tr class="memdesc:a0c722fa92ca4d7948501f81c1de9f17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation matrix for rotation about a particular axis, by a given angle. <br /></td></tr>
<tr class="separator:a0c722fa92ca4d7948501f81c1de9f17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15be590bb59c45ea47f2501c383cb467"><td class="memItemLeft" align="right" valign="top">static Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#a15be590bb59c45ea47f2501c383cb467">getRotation</a> (const Eigen::Vector3d &amp;vi, const Eigen::Vector3d &amp;vf)</td></tr>
<tr class="memdesc:a15be590bb59c45ea47f2501c383cb467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a rotation matrix to rotate a vector from intital to final state.  <a href="namespacequickgeom.html#a15be590bb59c45ea47f2501c383cb467">More...</a><br /></td></tr>
<tr class="separator:a15be590bb59c45ea47f2501c383cb467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a985eca968dd07d69c6460717c1d1c"><td class="memItemLeft" align="right" valign="top"><a id="aa2a985eca968dd07d69c6460717c1d1c" name="aa2a985eca968dd07d69c6460717c1d1c"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getConePositions</b> (const Eigen::Vector3d &amp;fixed, double length, double angle, int num=10, int devid=0)</td></tr>
<tr class="memdesc:aa2a985eca968dd07d69c6460717c1d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get positions inside the cross-section of cone for trialling positions with given bond length and angle. <br /></td></tr>
<tr class="separator:aa2a985eca968dd07d69c6460717c1d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60aae27d8f525f83c7088e81fcda69f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickgeom.html#af60aae27d8f525f83c7088e81fcda69f">getArcPositions</a> (const Eigen::Vector3d &amp;fixed, const Eigen::Vector3d &amp;def, double length, double angle, const std::vector&lt; double &gt; &amp;dihedral, int num=10, int devid=0)</td></tr>
<tr class="memdesc:af60aae27d8f525f83c7088e81fcda69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function used for generating trial positions with a given length, angle and set of allowed dihedrals.  <a href="namespacequickgeom.html#af60aae27d8f525f83c7088e81fcda69f">More...</a><br /></td></tr>
<tr class="separator:af60aae27d8f525f83c7088e81fcda69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315e97c84928b360f2c24b0cc39f2831"><td class="memItemLeft" align="right" valign="top"><a id="a315e97c84928b360f2c24b0cc39f2831" name="a315e97c84928b360f2c24b0cc39f2831"></a>
static std::vector&lt; Eigen::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getArcPositions</b> (const Eigen::Vector3d &amp;fixed, const Eigen::Vector3d &amp;def, double length, double angle, double dihedral, int num=10)</td></tr>
<tr class="memdesc:a315e97c84928b360f2c24b0cc39f2831"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for calling <a class="el" href="namespacequickgeom.html#af60aae27d8f525f83c7088e81fcda69f" title="The function used for generating trial positions with a given length, angle and set of allowed dihedr...">getArcPositions()</a> with a single allowed dihedral instead of a set. <br /></td></tr>
<tr class="separator:a315e97c84928b360f2c24b0cc39f2831"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This namespace contains all the methods used for geometric evaluations in DeNovo. This includes position trialling, angle calculation, and random radial vector generation.<br  />
Note: All angle related methods take angle input in radians and output is given also in radians This namespace makes extensive use of the Eigen libraries. See Eigen: <a href="http://eigen.tuxfamily.org/">http://eigen.tuxfamily.org/</a> for more details. (git repo: <a href="https://gitlab.com/libeigen/eigen.git">https://gitlab.com/libeigen/eigen.git</a>) </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a04d8cab088ba791a90c1586a23f6feaf" name="a04d8cab088ba791a90c1586a23f6feaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d8cab088ba791a90c1586a23f6feaf">&#9670;&nbsp;</a></span>getArcPositions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; Eigen::Vector3d &gt; quickgeom::getArcPositions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dihedral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function used for generating trial positions with a given length, angle and set of allowed dihedrals. </p>
<p >This function uses geometric calculations to choose trial positions when placing a new atom. It also adds in the gaussian error. See the algorithm PDF for details on the calculation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed</td><td>The primary axis vector (The vector representing the bond whose one end will be connected to the atom being trialled) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The defining vector (or fixed vector). It is the bond-vector with respect to which the dihedrals are defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The bond length. The vectors returned will have this magnitude, ensuring that the new atom is placed at this distance from the source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The bond angle. This angle will be maintained from the "fixed" vector. See algorithm PDF for details on the exact calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dihedral</td><td>The set of all allowed dihedrals in a vector object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of trial positions to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of Vectors (Eigen::Vector3d) which has the suggested positions. All vectors are centered at origin and have to be translated to the source atom. </dd></dl>

<p class="definition">Definition at line <a class="el" href="commons__oldRNG_8h_source.html#l00383">383</a> of file <a class="el" href="commons__oldRNG_8h_source.html">commons_oldRNG.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span>    {</div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span>        <span class="keywordtype">double</span> beta=fixed.dot(def)/(fixed.norm()*def.norm());</div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span>        <span class="comment">//Eigen::Vector3d plane=fixed.cross(def); plane/=plane.norm();</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span>        <span class="keywordtype">double</span> theta,phi;</div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span>        std::vector&lt;Eigen::Vector3d&gt; poses;</div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span>        Eigen::Vector3d prpos,per=def-(def.dot(fixed)/fixed.norm())*(fixed/fixed.norm()); per/=per.norm(); <span class="comment">//per=def/def.norm()-(def.dot(fixed/fixed.norm())*fixed/fixed.norm()); per/=per.norm();</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span>        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;num;i++)</div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span>        {</div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span>            theta=throwarandompoint_normal(angle,ANGVAR);</div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span>            <span class="keywordflow">if</span>(dihedral.size()==1) phi=throwarandompoint_normal(dihedral[0],DIHVAR);</div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span>            <span class="keywordflow">else</span> phi=throwarandompoint_normal(randomSelect(dihedral),DIHVAR);</div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span>            <span class="comment">//double x=((toss())?1:-1)*acos((cos(theta)*beta - sqrt(beta*beta + sin(theta)*sin(theta)))/(1+beta*beta));</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span>            <span class="comment">//prpos=(sin(x)*(fixed/fixed.norm())+cos(x)*(def/def.norm()));</span></div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span>            prpos=cos(theta)*(fixed/fixed.norm())+sin(theta)*per;</div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span>            <span class="comment">//cout &lt;&lt; prpos.norm()&lt;&lt;&quot;,&quot;;</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span>            <span class="comment">//if(prpos.cross(fixed).dot(plane)&gt;0) phi+=PI;</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span>            <span class="keyword">auto</span> nrM=<a class="code hl_function" href="namespacequickgeom.html#a0c722fa92ca4d7948501f81c1de9f17f">getRotationMatrix</a>(fixed/fixed.norm(),(toss()?-1:1)*phi);</div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span>            poses.push_back(nrM*(length*prpos));</div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span>        }</div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span>        <span class="comment">//cout &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span>        <span class="keywordflow">return</span> poses;</div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span>    }</div>
<div class="ttc" id="anamespacequickgeom_html_a0c722fa92ca4d7948501f81c1de9f17f"><div class="ttname"><a href="namespacequickgeom.html#a0c722fa92ca4d7948501f81c1de9f17f">quickgeom::getRotationMatrix</a></div><div class="ttdeci">static auto getRotationMatrix(const Eigen::Vector3d &amp;axis, double angle)</div><div class="ttdef"><b>Definition:</b> <a href="commons__oldRNG_8h_source.html#l00327">commons_oldRNG.h:327</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af60aae27d8f525f83c7088e81fcda69f" name="af60aae27d8f525f83c7088e81fcda69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60aae27d8f525f83c7088e81fcda69f">&#9670;&nbsp;</a></span>getArcPositions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; Eigen::Vector3d &gt; quickgeom::getArcPositions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dihedral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function used for generating trial positions with a given length, angle and set of allowed dihedrals. </p>
<p >This function uses geometric calculations to choose trial positions when placing a new atom. It also adds in the gaussian error. See the algorithm PDF for details on the calculation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed</td><td>The primary axis vector (The vector representing the bond whose one end will be connected to the atom being trialled) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The defining vector (or fixed vector). It is the bond-vector with respect to which the dihedrals are defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The bond length. The vectors returned will have this magnitude, ensuring that the new atom is placed at this distance from the source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The bond angle. This angle will be maintained from the "fixed" vector. See algorithm PDF for details on the exact calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dihedral</td><td>The set of all allowed dihedrals in a vector object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of trial positions to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of Vectors (Eigen::Vector3d) which has the suggested positions. All vectors are centered at origin and have to be translated to the source atom. </dd></dl>

<p class="definition">Definition at line <a class="el" href="commons_8h_source.html#l00559">559</a> of file <a class="el" href="commons_8h_source.html">commons.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span>    {</div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span>        <span class="keywordtype">double</span> beta=fixed.dot(def)/(fixed.norm()*def.norm());</div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span>        <span class="comment">//Eigen::Vector3d plane=fixed.cross(def); plane/=plane.norm();</span></div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span>        <span class="keywordtype">double</span> theta,phi;</div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>        std::vector&lt;Eigen::Vector3d&gt; poses;</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span>        Eigen::Vector3d prpos,per=def-(def.dot(fixed)/fixed.norm())*(fixed/fixed.norm()); per/=per.norm(); <span class="comment">//per=def/def.norm()-(def.dot(fixed/fixed.norm())*fixed/fixed.norm()); per/=per.norm();</span></div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span>        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;num;i++)</div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>        {</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span>            theta=RNG::throwarandompoint_normal(devid,angle,ANGVAR);</div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span>            <span class="keywordflow">if</span>(dihedral.size()==1) phi=RNG::throwarandompoint_normal(devid,dihedral[0],DIHVAR);</div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span>            <span class="keywordflow">else</span> phi=RNG::throwarandompoint_normal(devid,randomSelect(dihedral,devid),DIHVAR);</div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span>            <span class="comment">//double x=((toss(devid))?1:-1)*acos((cos(theta)*beta - sqrt(beta*beta + sin(theta)*sin(theta)))/(1+beta*beta));</span></div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span>            <span class="comment">//prpos=(sin(x)*(fixed/fixed.norm())+cos(x)*(def/def.norm()));</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span>            prpos=cos(theta)*(fixed/fixed.norm())+sin(theta)*per;</div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span>            <span class="comment">//cout &lt;&lt; prpos.norm()&lt;&lt;&quot;,&quot;;</span></div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span>            <span class="comment">//if(prpos.cross(fixed).dot(plane)&gt;0) phi+=PI;</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span>            <span class="keyword">auto</span> nrM=<a class="code hl_function" href="namespacequickgeom.html#a0c722fa92ca4d7948501f81c1de9f17f">getRotationMatrix</a>(fixed/fixed.norm(),(toss(devid)?-1:1)*phi);</div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span>            poses.push_back(nrM*(length*prpos));</div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span>        }</div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span>        <span class="comment">//cout &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span>        <span class="keywordflow">return</span> poses;</div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af60aae27d8f525f83c7088e81fcda69f" name="af60aae27d8f525f83c7088e81fcda69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60aae27d8f525f83c7088e81fcda69f">&#9670;&nbsp;</a></span>getArcPositions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; Eigen::Vector3d &gt; quickgeom::getArcPositions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dihedral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function used for generating trial positions with a given length, angle and set of allowed dihedrals. </p>
<p >This function uses geometric calculations to choose trial positions when placing a new atom. It also adds in the gaussian error. See the algorithm PDF for details on the calculation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed</td><td>The primary axis vector (The vector representing the bond whose one end will be connected to the atom being trialled) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The defining vector (or fixed vector). It is the bond-vector with respect to which the dihedrals are defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The bond length. The vectors returned will have this magnitude, ensuring that the new atom is placed at this distance from the source. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>The bond angle. This angle will be maintained from the "fixed" vector. See algorithm PDF for details on the exact calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dihedral</td><td>The set of all allowed dihedrals in a vector object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of trial positions to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of Vectors (Eigen::Vector3d) which has the suggested positions. All vectors are centered at origin and have to be translated to the source atom. </dd></dl>

<p class="definition">Definition at line <a class="el" href="commons__omegastable_8h_source.html#l00426">426</a> of file <a class="el" href="commons__omegastable_8h_source.html">commons_omegastable.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span>    {</div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span>        <span class="keywordtype">double</span> beta=fixed.dot(def)/(fixed.norm()*def.norm());</div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span>        <span class="comment">//Eigen::Vector3d plane=fixed.cross(def); plane/=plane.norm();</span></div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span>        <span class="keywordtype">double</span> theta,phi;</div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span>        std::vector&lt;Eigen::Vector3d&gt; poses;</div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span>        Eigen::Vector3d prpos,per=def-(def.dot(fixed)/fixed.norm())*(fixed/fixed.norm()); per/=per.norm(); <span class="comment">//per=def/def.norm()-(def.dot(fixed/fixed.norm())*fixed/fixed.norm()); per/=per.norm();</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span>        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;num;i++)</div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span>        {</div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span>            theta=RNG::throwarandompoint_normal(devid,angle,ANGVAR);</div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span>            <span class="keywordflow">if</span>(dihedral.size()==1) phi=RNG::throwarandompoint_normal(devid,dihedral[0],DIHVAR);</div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span>            <span class="keywordflow">else</span> phi=RNG::throwarandompoint_normal(devid,randomSelect(dihedral,devid),DIHVAR);</div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span>            <span class="comment">//double x=((toss(devid))?1:-1)*acos((cos(theta)*beta - sqrt(beta*beta + sin(theta)*sin(theta)))/(1+beta*beta));</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span>            <span class="comment">//prpos=(sin(x)*(fixed/fixed.norm())+cos(x)*(def/def.norm()));</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span>            prpos=cos(theta)*(fixed/fixed.norm())+sin(theta)*per;</div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span>            <span class="comment">//cout &lt;&lt; prpos.norm()&lt;&lt;&quot;,&quot;;</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span>            <span class="comment">//if(prpos.cross(fixed).dot(plane)&gt;0) phi+=PI;</span></div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span>            <span class="keyword">auto</span> nrM=<a class="code hl_function" href="namespacequickgeom.html#a0c722fa92ca4d7948501f81c1de9f17f">getRotationMatrix</a>(fixed/fixed.norm(),(toss(devid)?-1:1)*phi);</div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span>            poses.push_back(nrM*(length*prpos));</div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span>        }</div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span>        <span class="comment">//cout &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span>        <span class="keywordflow">return</span> poses;</div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a92859df06e8b2131cd4a358ccb4fe722" name="a92859df06e8b2131cd4a358ccb4fe722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92859df06e8b2131cd4a358ccb4fe722">&#9670;&nbsp;</a></span>getRandomVectorInShell() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Vector3d quickgeom::getRandomVectorInShell </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random vector pointing to a point at a given distance from a fixed center. </p>
<p >This method generates a vector pointing to a point dispersed randomly around a fixed center at a given distance from it </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>The center about which the points are to be dispersed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The distance from the center for all the points </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="commons__oldRNG_8h_source.html#l00310">310</a> of file <a class="el" href="commons__oldRNG_8h_source.html">commons_oldRNG.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span>{<span class="keywordflow">return</span> radius*<a class="code hl_function" href="namespacequickgeom.html#af810526addff4d3fcd284afde1687573">getRandomUnitVector</a>()+origin;}</div>
<div class="ttc" id="anamespacequickgeom_html_af810526addff4d3fcd284afde1687573"><div class="ttname"><a href="namespacequickgeom.html#af810526addff4d3fcd284afde1687573">quickgeom::getRandomUnitVector</a></div><div class="ttdeci">static Eigen::Vector3d getRandomUnitVector()</div><div class="ttdoc">Get literally any random unit vector.</div><div class="ttdef"><b>Definition:</b> <a href="commons__oldRNG_8h_source.html#l00299">commons_oldRNG.h:299</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a02e4c893cad9213aba7e80dc2345c2b2" name="a02e4c893cad9213aba7e80dc2345c2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e4c893cad9213aba7e80dc2345c2b2">&#9670;&nbsp;</a></span>getRandomVectorInShell() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Vector3d quickgeom::getRandomVectorInShell </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random vector pointing to a point at a given distance from a fixed center. </p>
<p >This method generates a vector pointing to a point dispersed randomly around a fixed center at a given distance from it </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>The center about which the points are to be dispersed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The distance from the center for all the points </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="commons_8h_source.html#l00497">497</a> of file <a class="el" href="commons_8h_source.html">commons.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span>{<span class="keywordflow">return</span> radius*<a class="code hl_function" href="namespacequickgeom.html#a96b76be4834ffe4dda706fcb091fe9b1">getRandomUnitVector</a>(devid)+origin;}</div>
<div class="ttc" id="anamespacequickgeom_html_a96b76be4834ffe4dda706fcb091fe9b1"><div class="ttname"><a href="namespacequickgeom.html#a96b76be4834ffe4dda706fcb091fe9b1">quickgeom::getRandomUnitVector</a></div><div class="ttdeci">static Eigen::Vector3d getRandomUnitVector(int devid=0)</div><div class="ttdoc">Get literally any random unit vector.</div><div class="ttdef"><b>Definition:</b> <a href="commons_8h_source.html#l00486">commons.h:486</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a02e4c893cad9213aba7e80dc2345c2b2" name="a02e4c893cad9213aba7e80dc2345c2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e4c893cad9213aba7e80dc2345c2b2">&#9670;&nbsp;</a></span>getRandomVectorInShell() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Vector3d quickgeom::getRandomVectorInShell </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>devid</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a random vector pointing to a point at a given distance from a fixed center. </p>
<p >This method generates a vector pointing to a point dispersed randomly around a fixed center at a given distance from it </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>The center about which the points are to be dispersed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>The distance from the center for all the points </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="commons__omegastable_8h_source.html#l00342">342</a> of file <a class="el" href="commons__omegastable_8h_source.html">commons_omegastable.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span>{<span class="keywordflow">return</span> radius*<a class="code hl_function" href="namespacequickgeom.html#a96b76be4834ffe4dda706fcb091fe9b1">getRandomUnitVector</a>(devid)+origin;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15be590bb59c45ea47f2501c383cb467" name="a15be590bb59c45ea47f2501c383cb467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15be590bb59c45ea47f2501c383cb467">&#9670;&nbsp;</a></span>getRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Vector3d quickgeom::getRotation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a rotation matrix to rotate a vector from intital to final state. </p>
<p >The rotation is in the plane containing both vectors. The resulting vector faces in the direction of the normal to the plane of rotation, and the magnitude of vector is the angle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vi</td><td>Initial position vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vf</td><td>Final position vector </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="commons_8h_source.html#l00525">525</a> of file <a class="el" href="commons_8h_source.html">commons.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span>    {</div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span>        Eigen::Vector3d n=vi.cross(vf);</div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span>        <span class="keywordflow">return</span> n*(<a class="code hl_function" href="namespacequickgeom.html#a215bf456c473c34054e4be483d30bd28">angleBetween</a>(vi,vf)/n.norm());</div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span>    }</div>
<div class="ttc" id="anamespacequickgeom_html_a215bf456c473c34054e4be483d30bd28"><div class="ttname"><a href="namespacequickgeom.html#a215bf456c473c34054e4be483d30bd28">quickgeom::angleBetween</a></div><div class="ttdeci">static double angleBetween(const Eigen::Vector3d &amp;v1, const Eigen::Vector3d &amp;v2)</div><div class="ttdoc">Get the angle subtended by two vectors.</div><div class="ttdef"><b>Definition:</b> <a href="commons_8h_source.html#l00507">commons.h:507</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a15be590bb59c45ea47f2501c383cb467" name="a15be590bb59c45ea47f2501c383cb467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15be590bb59c45ea47f2501c383cb467">&#9670;&nbsp;</a></span>getRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Vector3d quickgeom::getRotation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a rotation matrix to rotate a vector from intital to final state. </p>
<p >The rotation is in the plane containing both vectors. The resulting vector faces in the direction of the normal to the plane of rotation, and the magnitude of vector is the angle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vi</td><td>Initial position vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vf</td><td>Final position vector </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="commons__omegastable_8h_source.html#l00364">364</a> of file <a class="el" href="commons__omegastable_8h_source.html">commons_omegastable.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span>    {</div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span>        Eigen::Vector3d n=vi.cross(vf);</div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span>        <span class="keywordflow">return</span> n*(<a class="code hl_function" href="namespacequickgeom.html#a215bf456c473c34054e4be483d30bd28">angleBetween</a>(vi,vf)/n.norm());</div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c722fa92ca4d7948501f81c1de9f17f" name="a0c722fa92ca4d7948501f81c1de9f17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c722fa92ca4d7948501f81c1de9f17f">&#9670;&nbsp;</a></span>getRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto quickgeom::getRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get a rotation matrix for rotation about a particular axis, by a given angle </p>

<p class="definition">Definition at line <a class="el" href="commons__oldRNG_8h_source.html#l00327">327</a> of file <a class="el" href="commons__oldRNG_8h_source.html">commons_oldRNG.h</a>.</p>
<div class="fragment"><div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span>{<span class="keywordflow">return</span> Eigen::AngleAxisd(angle,axis);} <span class="comment">//angle in radians</span></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
