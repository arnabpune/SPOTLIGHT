\hypertarget{namespacequickgeom}{}\doxysection{quickgeom Namespace Reference}
\label{namespacequickgeom}\index{quickgeom@{quickgeom}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classquickgeom_1_1Container}{Container}}
\item 
class \mbox{\hyperlink{classquickgeom_1_1ContainerUnion}{Container\+Union}}
\item 
class \mbox{\hyperlink{classquickgeom_1_1Cuboid}{Cuboid}}
\item 
class \mbox{\hyperlink{classquickgeom_1_1Sphere}{Sphere}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacequickgeom_a96b76be4834ffe4dda706fcb091fe9b1}\label{namespacequickgeom_a96b76be4834ffe4dda706fcb091fe9b1}} 
static Eigen\+::\+Vector3d {\bfseries get\+Random\+Unit\+Vector} (int devid=0)
\begin{DoxyCompactList}\small\item\em Get literally {\bfseries{any}} random unit vector. \end{DoxyCompactList}\item 
static Eigen\+::\+Vector3d \mbox{\hyperlink{namespacequickgeom_a02e4c893cad9213aba7e80dc2345c2b2}{get\+Random\+Vector\+In\+Shell}} (const Eigen\+::\+Vector3d \&origin, const double \&radius, int devid=0)
\begin{DoxyCompactList}\small\item\em Get a random vector pointing to a point at a given distance from a fixed center. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a78c6886551455b71fe88580560aae508}\label{namespacequickgeom_a78c6886551455b71fe88580560aae508}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Random\+Vectors\+In\+Shell} (const Eigen\+::\+Vector3d \&origin, const double \&radius, int sample\+Size, int devid=0)
\begin{DoxyCompactList}\small\item\em A wrapper to generate multiple vectors around a given centre (useful while trialling seed positions or the position of the second atom). See \mbox{\hyperlink{namespacequickgeom_a92859df06e8b2131cd4a358ccb4fe722}{get\+Random\+Vector\+In\+Shell(const Eigen\+::\+Vector3d\&,const double\&)}} \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}\label{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}} 
static double {\bfseries angle\+Between} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2)
\begin{DoxyCompactList}\small\item\em Get the angle subtended by two vectors. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a9931a326c1368d02b5249e68a0cd00ee}\label{namespacequickgeom_a9931a326c1368d02b5249e68a0cd00ee}} 
static Eigen\+::\+Vector3d {\bfseries plane\+Of} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2)
\begin{DoxyCompactList}\small\item\em Get the normal unit vector to the plane created by two vectors. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a3a172b92f8eee792705499c271696954}\label{namespacequickgeom_a3a172b92f8eee792705499c271696954}} 
static double {\bfseries dihedral\+Between} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2, const Eigen\+::\+Vector3d \&v3)
\begin{DoxyCompactList}\small\item\em Given three bond vectors, calculate the dihedral angle they make. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}\label{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}} 
static auto {\bfseries get\+Rotation\+Matrix} (const Eigen\+::\+Vector3d \&axis, double angle)
\begin{DoxyCompactList}\small\item\em Get a rotation matrix for rotation about a particular axis, by a given angle. \end{DoxyCompactList}\item 
static Eigen\+::\+Vector3d \mbox{\hyperlink{namespacequickgeom_a15be590bb59c45ea47f2501c383cb467}{get\+Rotation}} (const Eigen\+::\+Vector3d \&vi, const Eigen\+::\+Vector3d \&vf)
\begin{DoxyCompactList}\small\item\em Get a rotation matrix to rotate a vector from intital to final state. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_aa2a985eca968dd07d69c6460717c1d1c}\label{namespacequickgeom_aa2a985eca968dd07d69c6460717c1d1c}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Cone\+Positions} (const Eigen\+::\+Vector3d \&fixed, double length, double angle, int num=10, int devid=0)
\begin{DoxyCompactList}\small\item\em Get positions inside the cross-\/section of cone for trialling positions with given bond length and angle. \end{DoxyCompactList}\item 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ \mbox{\hyperlink{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}{get\+Arc\+Positions}} (const Eigen\+::\+Vector3d \&fixed, const Eigen\+::\+Vector3d \&def, double length, double angle, const std\+::vector$<$ double $>$ \&dihedral, int num=10, int devid=0)
\begin{DoxyCompactList}\small\item\em The function used for generating trial positions with a given length, angle and set of allowed dihedrals. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a315e97c84928b360f2c24b0cc39f2831}\label{namespacequickgeom_a315e97c84928b360f2c24b0cc39f2831}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Arc\+Positions} (const Eigen\+::\+Vector3d \&fixed, const Eigen\+::\+Vector3d \&def, double length, double angle, double dihedral, int num=10)
\begin{DoxyCompactList}\small\item\em A wrapper for calling \mbox{\hyperlink{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}{get\+Arc\+Positions()}} with a single allowed dihedral instead of a set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_ac87a99974f08e140495028c84bd5218f}\label{namespacequickgeom_ac87a99974f08e140495028c84bd5218f}} 
static Eigen\+::\+Vector3d {\bfseries get\+Random\+Position\+In\+Space} (\mbox{\hyperlink{classquickgeom_1_1Container}{quickgeom\+::\+Container}} $\ast$cnt)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{namespaceRNG}{RNG}} to generate positions in any region in space. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_af810526addff4d3fcd284afde1687573}\label{namespacequickgeom_af810526addff4d3fcd284afde1687573}} 
static Eigen\+::\+Vector3d {\bfseries get\+Random\+Unit\+Vector} ()
\begin{DoxyCompactList}\small\item\em Get literally {\bfseries{any}} random unit vector. \end{DoxyCompactList}\item 
static Eigen\+::\+Vector3d \mbox{\hyperlink{namespacequickgeom_a92859df06e8b2131cd4a358ccb4fe722}{get\+Random\+Vector\+In\+Shell}} (const Eigen\+::\+Vector3d \&origin, const double \&radius)
\begin{DoxyCompactList}\small\item\em Get a random vector pointing to a point at a given distance from a fixed center. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a7d72bdab9c2441d326788d2b50d29602}\label{namespacequickgeom_a7d72bdab9c2441d326788d2b50d29602}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Random\+Vectors\+In\+Shell} (const Eigen\+::\+Vector3d \&origin, const double \&radius, int sample\+Size)
\begin{DoxyCompactList}\small\item\em A wrapper to generate multiple vectors around a given centre (useful while trialling seed positions or the position of the second atom). See \mbox{\hyperlink{namespacequickgeom_a92859df06e8b2131cd4a358ccb4fe722}{get\+Random\+Vector\+In\+Shell(const Eigen\+::\+Vector3d\&,const double\&)}} \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}\label{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}} 
static double {\bfseries angle\+Between} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2)
\begin{DoxyCompactList}\small\item\em Get the angle subtended by two vectors. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a9931a326c1368d02b5249e68a0cd00ee}\label{namespacequickgeom_a9931a326c1368d02b5249e68a0cd00ee}} 
static Eigen\+::\+Vector3d {\bfseries plane\+Of} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2)
\begin{DoxyCompactList}\small\item\em Get the normal unit vector to the plane created by two vectors. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a3a172b92f8eee792705499c271696954}\label{namespacequickgeom_a3a172b92f8eee792705499c271696954}} 
static double {\bfseries dihedral\+Between} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2, const Eigen\+::\+Vector3d \&v3)
\begin{DoxyCompactList}\small\item\em Given three bond vectors, calculate the dihedral angle they make. \end{DoxyCompactList}\item 
static auto \mbox{\hyperlink{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}{get\+Rotation\+Matrix}} (const Eigen\+::\+Vector3d \&axis, double angle)
\item 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ \mbox{\hyperlink{namespacequickgeom_a04d8cab088ba791a90c1586a23f6feaf}{get\+Arc\+Positions}} (const Eigen\+::\+Vector3d \&fixed, const Eigen\+::\+Vector3d \&def, double length, double angle, const std\+::vector$<$ double $>$ \&dihedral, int num=10)
\begin{DoxyCompactList}\small\item\em The function used for generating trial positions with a given length, angle and set of allowed dihedrals. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a315e97c84928b360f2c24b0cc39f2831}\label{namespacequickgeom_a315e97c84928b360f2c24b0cc39f2831}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Arc\+Positions} (const Eigen\+::\+Vector3d \&fixed, const Eigen\+::\+Vector3d \&def, double length, double angle, double dihedral, int num=10)
\begin{DoxyCompactList}\small\item\em A wrapper for calling \mbox{\hyperlink{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}{get\+Arc\+Positions()}} with a single allowed dihedral instead of a set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a96b76be4834ffe4dda706fcb091fe9b1}\label{namespacequickgeom_a96b76be4834ffe4dda706fcb091fe9b1}} 
static Eigen\+::\+Vector3d {\bfseries get\+Random\+Unit\+Vector} (int devid=0)
\begin{DoxyCompactList}\small\item\em Get literally {\bfseries{any}} random unit vector. \end{DoxyCompactList}\item 
static Eigen\+::\+Vector3d \mbox{\hyperlink{namespacequickgeom_a02e4c893cad9213aba7e80dc2345c2b2}{get\+Random\+Vector\+In\+Shell}} (const Eigen\+::\+Vector3d \&origin, const double \&radius, int devid=0)
\begin{DoxyCompactList}\small\item\em Get a random vector pointing to a point at a given distance from a fixed center. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a78c6886551455b71fe88580560aae508}\label{namespacequickgeom_a78c6886551455b71fe88580560aae508}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Random\+Vectors\+In\+Shell} (const Eigen\+::\+Vector3d \&origin, const double \&radius, int sample\+Size, int devid=0)
\begin{DoxyCompactList}\small\item\em A wrapper to generate multiple vectors around a given centre (useful while trialling seed positions or the position of the second atom). See \mbox{\hyperlink{namespacequickgeom_a92859df06e8b2131cd4a358ccb4fe722}{get\+Random\+Vector\+In\+Shell(const Eigen\+::\+Vector3d\&,const double\&)}} \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}\label{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}} 
static double {\bfseries angle\+Between} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2)
\begin{DoxyCompactList}\small\item\em Get the angle subtended by two vectors. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a9931a326c1368d02b5249e68a0cd00ee}\label{namespacequickgeom_a9931a326c1368d02b5249e68a0cd00ee}} 
static Eigen\+::\+Vector3d {\bfseries plane\+Of} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2)
\begin{DoxyCompactList}\small\item\em Get the normal unit vector to the plane created by two vectors. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a3a172b92f8eee792705499c271696954}\label{namespacequickgeom_a3a172b92f8eee792705499c271696954}} 
static double {\bfseries dihedral\+Between} (const Eigen\+::\+Vector3d \&v1, const Eigen\+::\+Vector3d \&v2, const Eigen\+::\+Vector3d \&v3)
\begin{DoxyCompactList}\small\item\em Given three bond vectors, calculate the dihedral angle they make. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}\label{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}} 
static auto {\bfseries get\+Rotation\+Matrix} (const Eigen\+::\+Vector3d \&axis, double angle)
\begin{DoxyCompactList}\small\item\em Get a rotation matrix for rotation about a particular axis, by a given angle. \end{DoxyCompactList}\item 
static Eigen\+::\+Vector3d \mbox{\hyperlink{namespacequickgeom_a15be590bb59c45ea47f2501c383cb467}{get\+Rotation}} (const Eigen\+::\+Vector3d \&vi, const Eigen\+::\+Vector3d \&vf)
\begin{DoxyCompactList}\small\item\em Get a rotation matrix to rotate a vector from intital to final state. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_aa2a985eca968dd07d69c6460717c1d1c}\label{namespacequickgeom_aa2a985eca968dd07d69c6460717c1d1c}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Cone\+Positions} (const Eigen\+::\+Vector3d \&fixed, double length, double angle, int num=10, int devid=0)
\begin{DoxyCompactList}\small\item\em Get positions inside the cross-\/section of cone for trialling positions with given bond length and angle. \end{DoxyCompactList}\item 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ \mbox{\hyperlink{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}{get\+Arc\+Positions}} (const Eigen\+::\+Vector3d \&fixed, const Eigen\+::\+Vector3d \&def, double length, double angle, const std\+::vector$<$ double $>$ \&dihedral, int num=10, int devid=0)
\begin{DoxyCompactList}\small\item\em The function used for generating trial positions with a given length, angle and set of allowed dihedrals. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespacequickgeom_a315e97c84928b360f2c24b0cc39f2831}\label{namespacequickgeom_a315e97c84928b360f2c24b0cc39f2831}} 
static std\+::vector$<$ Eigen\+::\+Vector3d $>$ {\bfseries get\+Arc\+Positions} (const Eigen\+::\+Vector3d \&fixed, const Eigen\+::\+Vector3d \&def, double length, double angle, double dihedral, int num=10)
\begin{DoxyCompactList}\small\item\em A wrapper for calling \mbox{\hyperlink{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}{get\+Arc\+Positions()}} with a single allowed dihedral instead of a set. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This namespace contains all the methods used for geometric evaluations in De\+Novo. This includes position trialling, angle calculation, and random radial vector generation.~\newline
Note\+: All angle related methods take angle input in radians and output is given also in radians This namespace makes extensive use of the Eigen libraries. See Eigen\+: \href{http://eigen.tuxfamily.org/}{\texttt{ http\+://eigen.\+tuxfamily.\+org/}} for more details. (git repo\+: \href{https://gitlab.com/libeigen/eigen.git}{\texttt{ https\+://gitlab.\+com/libeigen/eigen.\+git}}) 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacequickgeom_a04d8cab088ba791a90c1586a23f6feaf}\label{namespacequickgeom_a04d8cab088ba791a90c1586a23f6feaf}} 
\index{quickgeom@{quickgeom}!getArcPositions@{getArcPositions}}
\index{getArcPositions@{getArcPositions}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getArcPositions()}{getArcPositions()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static std\+::vector$<$ Eigen\+::\+Vector3d $>$ quickgeom\+::get\+Arc\+Positions (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{fixed,  }\item[{const Eigen\+::\+Vector3d \&}]{def,  }\item[{double}]{length,  }\item[{double}]{angle,  }\item[{const std\+::vector$<$ double $>$ \&}]{dihedral,  }\item[{int}]{num = {\ttfamily 10} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



The function used for generating trial positions with a given length, angle and set of allowed dihedrals. 

This function uses geometric calculations to choose trial positions when placing a new atom. It also adds in the gaussian error. See the algorithm PDF for details on the calculation. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fixed} & The primary axis vector (The vector representing the bond whose one end will be connected to the atom being trialled) \\
\hline
\mbox{\texttt{ in}}  & {\em def} & The defining vector (or fixed vector). It is the bond-\/vector with respect to which the dihedrals are defined. \\
\hline
\mbox{\texttt{ in}}  & {\em length} & The bond length. The vectors returned will have this magnitude, ensuring that the new atom is placed at this distance from the source. \\
\hline
\mbox{\texttt{ in}}  & {\em angle} & The bond angle. This angle will be maintained from the \char`\"{}fixed\char`\"{} vector. See algorithm PDF for details on the exact calculation. \\
\hline
\mbox{\texttt{ in}}  & {\em dihedral} & The set of all allowed dihedrals in a vector object \\
\hline
\mbox{\texttt{ in}}  & {\em num} & Number of trial positions to generate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A list of Vectors (Eigen\+::\+Vector3d) which has the suggested positions. All vectors are centered at origin and have to be translated to the source atom. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{commons__oldRNG_8h_source_l00383}{383}} of file \mbox{\hyperlink{commons__oldRNG_8h_source}{commons\+\_\+old\+RNG.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00384}00384     \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00385}00385         \textcolor{keywordtype}{double} beta=fixed.dot(def)/(fixed.norm()*def.norm());}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00386}00386         \textcolor{comment}{//Eigen::Vector3d plane=fixed.cross(def); plane/=plane.norm();}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00387}00387         \textcolor{keywordtype}{double} theta,phi;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00388}00388         std::vector<Eigen::Vector3d> poses;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00389}00389         Eigen::Vector3d prpos,per=def-\/(def.dot(fixed)/fixed.norm())*(fixed/fixed.norm()); per/=per.norm(); \textcolor{comment}{//per=def/def.norm()-\/(def.dot(fixed/fixed.norm())*fixed/fixed.norm()); per/=per.norm();}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00390}00390         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<num;i++)}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00391}00391         \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00392}00392             theta=throwarandompoint\_normal(angle,ANGVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00393}00393             \textcolor{keywordflow}{if}(dihedral.size()==1) phi=throwarandompoint\_normal(dihedral[0],DIHVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00394}00394             \textcolor{keywordflow}{else} phi=throwarandompoint\_normal(randomSelect(dihedral),DIHVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00395}00395             \textcolor{comment}{//double x=((toss())?1:-\/1)*acos((cos(theta)*beta -\/ sqrt(beta*beta + sin(theta)*sin(theta)))/(1+beta*beta));}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00396}00396             \textcolor{comment}{//prpos=(sin(x)*(fixed/fixed.norm())+cos(x)*(def/def.norm()));}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00397}00397             prpos=cos(theta)*(fixed/fixed.norm())+sin(theta)*per;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00398}00398             \textcolor{comment}{//cout << prpos.norm()<<"{},"{};}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00399}00399             \textcolor{comment}{//if(prpos.cross(fixed).dot(plane)>0) phi+=PI;}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00400}00400             \textcolor{keyword}{auto} nrM=\mbox{\hyperlink{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}{getRotationMatrix}}(fixed/fixed.norm(),(toss()?-\/1:1)*phi);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00401}00401             poses.push\_back(nrM*(length*prpos));}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00402}00402         \}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00403}00403         \textcolor{comment}{//cout << "{}\(\backslash\)n"{};}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00404}00404         \textcolor{keywordflow}{return} poses;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00405}00405     \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}\label{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}} 
\index{quickgeom@{quickgeom}!getArcPositions@{getArcPositions}}
\index{getArcPositions@{getArcPositions}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getArcPositions()}{getArcPositions()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static std\+::vector$<$ Eigen\+::\+Vector3d $>$ quickgeom\+::get\+Arc\+Positions (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{fixed,  }\item[{const Eigen\+::\+Vector3d \&}]{def,  }\item[{double}]{length,  }\item[{double}]{angle,  }\item[{const std\+::vector$<$ double $>$ \&}]{dihedral,  }\item[{int}]{num = {\ttfamily 10},  }\item[{int}]{devid = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



The function used for generating trial positions with a given length, angle and set of allowed dihedrals. 

This function uses geometric calculations to choose trial positions when placing a new atom. It also adds in the gaussian error. See the algorithm PDF for details on the calculation. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fixed} & The primary axis vector (The vector representing the bond whose one end will be connected to the atom being trialled) \\
\hline
\mbox{\texttt{ in}}  & {\em def} & The defining vector (or fixed vector). It is the bond-\/vector with respect to which the dihedrals are defined. \\
\hline
\mbox{\texttt{ in}}  & {\em length} & The bond length. The vectors returned will have this magnitude, ensuring that the new atom is placed at this distance from the source. \\
\hline
\mbox{\texttt{ in}}  & {\em angle} & The bond angle. This angle will be maintained from the \char`\"{}fixed\char`\"{} vector. See algorithm PDF for details on the exact calculation. \\
\hline
\mbox{\texttt{ in}}  & {\em dihedral} & The set of all allowed dihedrals in a vector object \\
\hline
\mbox{\texttt{ in}}  & {\em num} & Number of trial positions to generate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A list of Vectors (Eigen\+::\+Vector3d) which has the suggested positions. All vectors are centered at origin and have to be translated to the source atom. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{commons_8h_source_l00559}{559}} of file \mbox{\hyperlink{commons_8h_source}{commons.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00560}00560     \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00561}00561         \textcolor{keywordtype}{double} beta=fixed.dot(def)/(fixed.norm()*def.norm());}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00562}00562         \textcolor{comment}{//Eigen::Vector3d plane=fixed.cross(def); plane/=plane.norm();}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00563}00563         \textcolor{keywordtype}{double} theta,phi;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00564}00564         std::vector<Eigen::Vector3d> poses;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00565}00565         Eigen::Vector3d prpos,per=def-\/(def.dot(fixed)/fixed.norm())*(fixed/fixed.norm()); per/=per.norm(); \textcolor{comment}{//per=def/def.norm()-\/(def.dot(fixed/fixed.norm())*fixed/fixed.norm()); per/=per.norm();}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00566}00566         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<num;i++)}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00567}00567         \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00568}00568             theta=RNG::throwarandompoint\_normal(devid,angle,ANGVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00569}00569             \textcolor{keywordflow}{if}(dihedral.size()==1) phi=RNG::throwarandompoint\_normal(devid,dihedral[0],DIHVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00570}00570             \textcolor{keywordflow}{else} phi=RNG::throwarandompoint\_normal(devid,randomSelect(dihedral,devid),DIHVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00571}00571             \textcolor{comment}{//double x=((toss(devid))?1:-\/1)*acos((cos(theta)*beta -\/ sqrt(beta*beta + sin(theta)*sin(theta)))/(1+beta*beta));}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00572}00572             \textcolor{comment}{//prpos=(sin(x)*(fixed/fixed.norm())+cos(x)*(def/def.norm()));}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00573}00573             prpos=cos(theta)*(fixed/fixed.norm())+sin(theta)*per;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00574}00574             \textcolor{comment}{//cout << prpos.norm()<<"{},"{};}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00575}00575             \textcolor{comment}{//if(prpos.cross(fixed).dot(plane)>0) phi+=PI;}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00576}00576             \textcolor{keyword}{auto} nrM=\mbox{\hyperlink{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}{getRotationMatrix}}(fixed/fixed.norm(),(toss(devid)?-\/1:1)*phi);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00577}00577             poses.push\_back(nrM*(length*prpos));}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00578}00578         \}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00579}00579         \textcolor{comment}{//cout << "{}\(\backslash\)n"{};}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00580}00580         \textcolor{keywordflow}{return} poses;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00581}00581     \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}\label{namespacequickgeom_af60aae27d8f525f83c7088e81fcda69f}} 
\index{quickgeom@{quickgeom}!getArcPositions@{getArcPositions}}
\index{getArcPositions@{getArcPositions}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getArcPositions()}{getArcPositions()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static std\+::vector$<$ Eigen\+::\+Vector3d $>$ quickgeom\+::get\+Arc\+Positions (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{fixed,  }\item[{const Eigen\+::\+Vector3d \&}]{def,  }\item[{double}]{length,  }\item[{double}]{angle,  }\item[{const std\+::vector$<$ double $>$ \&}]{dihedral,  }\item[{int}]{num = {\ttfamily 10},  }\item[{int}]{devid = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



The function used for generating trial positions with a given length, angle and set of allowed dihedrals. 

This function uses geometric calculations to choose trial positions when placing a new atom. It also adds in the gaussian error. See the algorithm PDF for details on the calculation. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fixed} & The primary axis vector (The vector representing the bond whose one end will be connected to the atom being trialled) \\
\hline
\mbox{\texttt{ in}}  & {\em def} & The defining vector (or fixed vector). It is the bond-\/vector with respect to which the dihedrals are defined. \\
\hline
\mbox{\texttt{ in}}  & {\em length} & The bond length. The vectors returned will have this magnitude, ensuring that the new atom is placed at this distance from the source. \\
\hline
\mbox{\texttt{ in}}  & {\em angle} & The bond angle. This angle will be maintained from the \char`\"{}fixed\char`\"{} vector. See algorithm PDF for details on the exact calculation. \\
\hline
\mbox{\texttt{ in}}  & {\em dihedral} & The set of all allowed dihedrals in a vector object \\
\hline
\mbox{\texttt{ in}}  & {\em num} & Number of trial positions to generate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A list of Vectors (Eigen\+::\+Vector3d) which has the suggested positions. All vectors are centered at origin and have to be translated to the source atom. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{commons__omegastable_8h_source_l00426}{426}} of file \mbox{\hyperlink{commons__omegastable_8h_source}{commons\+\_\+omegastable.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00427}00427     \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00428}00428         \textcolor{keywordtype}{double} beta=fixed.dot(def)/(fixed.norm()*def.norm());}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00429}00429         \textcolor{comment}{//Eigen::Vector3d plane=fixed.cross(def); plane/=plane.norm();}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00430}00430         \textcolor{keywordtype}{double} theta,phi;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00431}00431         std::vector<Eigen::Vector3d> poses;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00432}00432         Eigen::Vector3d prpos,per=def-\/(def.dot(fixed)/fixed.norm())*(fixed/fixed.norm()); per/=per.norm(); \textcolor{comment}{//per=def/def.norm()-\/(def.dot(fixed/fixed.norm())*fixed/fixed.norm()); per/=per.norm();}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00433}00433         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0;i<num;i++)}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00434}00434         \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00435}00435             theta=RNG::throwarandompoint\_normal(devid,angle,ANGVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00436}00436             \textcolor{keywordflow}{if}(dihedral.size()==1) phi=RNG::throwarandompoint\_normal(devid,dihedral[0],DIHVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00437}00437             \textcolor{keywordflow}{else} phi=RNG::throwarandompoint\_normal(devid,randomSelect(dihedral,devid),DIHVAR);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00438}00438             \textcolor{comment}{//double x=((toss(devid))?1:-\/1)*acos((cos(theta)*beta -\/ sqrt(beta*beta + sin(theta)*sin(theta)))/(1+beta*beta));}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00439}00439             \textcolor{comment}{//prpos=(sin(x)*(fixed/fixed.norm())+cos(x)*(def/def.norm()));}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00440}00440             prpos=cos(theta)*(fixed/fixed.norm())+sin(theta)*per;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00441}00441             \textcolor{comment}{//cout << prpos.norm()<<"{},"{};}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00442}00442             \textcolor{comment}{//if(prpos.cross(fixed).dot(plane)>0) phi+=PI;}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00443}00443             \textcolor{keyword}{auto} nrM=\mbox{\hyperlink{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}{getRotationMatrix}}(fixed/fixed.norm(),(toss(devid)?-\/1:1)*phi);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00444}00444             poses.push\_back(nrM*(length*prpos));}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00445}00445         \}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00446}00446         \textcolor{comment}{//cout << "{}\(\backslash\)n"{};}}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00447}00447         \textcolor{keywordflow}{return} poses;}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00448}00448     \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_a92859df06e8b2131cd4a358ccb4fe722}\label{namespacequickgeom_a92859df06e8b2131cd4a358ccb4fe722}} 
\index{quickgeom@{quickgeom}!getRandomVectorInShell@{getRandomVectorInShell}}
\index{getRandomVectorInShell@{getRandomVectorInShell}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getRandomVectorInShell()}{getRandomVectorInShell()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static Eigen\+::\+Vector3d quickgeom\+::get\+Random\+Vector\+In\+Shell (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{origin,  }\item[{const double \&}]{radius }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Get a random vector pointing to a point at a given distance from a fixed center. 

This method generates a vector pointing to a point dispersed randomly around a fixed center at a given distance from it 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em origin} & The center about which the points are to be dispersed \\
\hline
\mbox{\texttt{ in}}  & {\em radius} & The distance from the center for all the points \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{commons__oldRNG_8h_source_l00310}{310}} of file \mbox{\hyperlink{commons__oldRNG_8h_source}{commons\+\_\+old\+RNG.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00310}00310 \{\textcolor{keywordflow}{return} radius*\mbox{\hyperlink{namespacequickgeom_af810526addff4d3fcd284afde1687573}{getRandomUnitVector}}()+origin;\}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_a02e4c893cad9213aba7e80dc2345c2b2}\label{namespacequickgeom_a02e4c893cad9213aba7e80dc2345c2b2}} 
\index{quickgeom@{quickgeom}!getRandomVectorInShell@{getRandomVectorInShell}}
\index{getRandomVectorInShell@{getRandomVectorInShell}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getRandomVectorInShell()}{getRandomVectorInShell()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static Eigen\+::\+Vector3d quickgeom\+::get\+Random\+Vector\+In\+Shell (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{origin,  }\item[{const double \&}]{radius,  }\item[{int}]{devid = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Get a random vector pointing to a point at a given distance from a fixed center. 

This method generates a vector pointing to a point dispersed randomly around a fixed center at a given distance from it 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em origin} & The center about which the points are to be dispersed \\
\hline
\mbox{\texttt{ in}}  & {\em radius} & The distance from the center for all the points \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{commons_8h_source_l00497}{497}} of file \mbox{\hyperlink{commons_8h_source}{commons.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00497}00497 \{\textcolor{keywordflow}{return} radius*\mbox{\hyperlink{namespacequickgeom_a96b76be4834ffe4dda706fcb091fe9b1}{getRandomUnitVector}}(devid)+origin;\}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_a02e4c893cad9213aba7e80dc2345c2b2}\label{namespacequickgeom_a02e4c893cad9213aba7e80dc2345c2b2}} 
\index{quickgeom@{quickgeom}!getRandomVectorInShell@{getRandomVectorInShell}}
\index{getRandomVectorInShell@{getRandomVectorInShell}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getRandomVectorInShell()}{getRandomVectorInShell()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static Eigen\+::\+Vector3d quickgeom\+::get\+Random\+Vector\+In\+Shell (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{origin,  }\item[{const double \&}]{radius,  }\item[{int}]{devid = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Get a random vector pointing to a point at a given distance from a fixed center. 

This method generates a vector pointing to a point dispersed randomly around a fixed center at a given distance from it 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em origin} & The center about which the points are to be dispersed \\
\hline
\mbox{\texttt{ in}}  & {\em radius} & The distance from the center for all the points \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{commons__omegastable_8h_source_l00342}{342}} of file \mbox{\hyperlink{commons__omegastable_8h_source}{commons\+\_\+omegastable.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00342}00342 \{\textcolor{keywordflow}{return} radius*\mbox{\hyperlink{namespacequickgeom_a96b76be4834ffe4dda706fcb091fe9b1}{getRandomUnitVector}}(devid)+origin;\}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_a15be590bb59c45ea47f2501c383cb467}\label{namespacequickgeom_a15be590bb59c45ea47f2501c383cb467}} 
\index{quickgeom@{quickgeom}!getRotation@{getRotation}}
\index{getRotation@{getRotation}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getRotation()}{getRotation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static Eigen\+::\+Vector3d quickgeom\+::get\+Rotation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{vi,  }\item[{const Eigen\+::\+Vector3d \&}]{vf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Get a rotation matrix to rotate a vector from intital to final state. 

The rotation is in the plane containing both vectors. The resulting vector faces in the direction of the normal to the plane of rotation, and the magnitude of vector is the angle. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vi} & Initial position vector \\
\hline
\mbox{\texttt{ in}}  & {\em vf} & Final position vector \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{commons_8h_source_l00525}{525}} of file \mbox{\hyperlink{commons_8h_source}{commons.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00526}00526     \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00527}00527         Eigen::Vector3d n=vi.cross(vf);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00528}00528         \textcolor{keywordflow}{return} n*(\mbox{\hyperlink{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}{angleBetween}}(vi,vf)/n.norm());}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00529}00529     \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_a15be590bb59c45ea47f2501c383cb467}\label{namespacequickgeom_a15be590bb59c45ea47f2501c383cb467}} 
\index{quickgeom@{quickgeom}!getRotation@{getRotation}}
\index{getRotation@{getRotation}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getRotation()}{getRotation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static Eigen\+::\+Vector3d quickgeom\+::get\+Rotation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{vi,  }\item[{const Eigen\+::\+Vector3d \&}]{vf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Get a rotation matrix to rotate a vector from intital to final state. 

The rotation is in the plane containing both vectors. The resulting vector faces in the direction of the normal to the plane of rotation, and the magnitude of vector is the angle. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vi} & Initial position vector \\
\hline
\mbox{\texttt{ in}}  & {\em vf} & Final position vector \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{commons__omegastable_8h_source_l00364}{364}} of file \mbox{\hyperlink{commons__omegastable_8h_source}{commons\+\_\+omegastable.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00365}00365     \{}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00366}00366         Eigen::Vector3d n=vi.cross(vf);}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00367}00367         \textcolor{keywordflow}{return} n*(\mbox{\hyperlink{namespacequickgeom_a215bf456c473c34054e4be483d30bd28}{angleBetween}}(vi,vf)/n.norm());}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00368}00368     \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}\label{namespacequickgeom_a0c722fa92ca4d7948501f81c1de9f17f}} 
\index{quickgeom@{quickgeom}!getRotationMatrix@{getRotationMatrix}}
\index{getRotationMatrix@{getRotationMatrix}!quickgeom@{quickgeom}}
\doxysubsubsection{\texorpdfstring{getRotationMatrix()}{getRotationMatrix()}}
{\footnotesize\ttfamily static auto quickgeom\+::get\+Rotation\+Matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector3d \&}]{axis,  }\item[{double}]{angle }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Get a rotation matrix for rotation about a particular axis, by a given angle 

Definition at line \mbox{\hyperlink{commons__oldRNG_8h_source_l00327}{327}} of file \mbox{\hyperlink{commons__oldRNG_8h_source}{commons\+\_\+old\+RNG.\+h}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\Hypertarget{namespacequickgeom_l00327}00327 \{\textcolor{keywordflow}{return} Eigen::AngleAxisd(angle,axis);\} \textcolor{comment}{//angle in radians}}

\end{DoxyCode}
