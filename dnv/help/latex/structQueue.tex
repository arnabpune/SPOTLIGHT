\hypertarget{structQueue}{}\doxysection{Queue\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Class Template Reference}
\label{structQueue}\index{Queue$<$ T $>$@{Queue$<$ T $>$}}


{\ttfamily \#include \char`\"{}support/commons.\+h\char`\"{}}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{structQueue_a646dd47a86597b672f61b093a38a06b5}\label{structQueue_a646dd47a86597b672f61b093a38a06b5}} 
int {\bfseries get\+Size} () const volatile
\begin{DoxyCompactList}\small\item\em Get the number of elements actively in this queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_ac2cc5c6e464ff5976f26ef71adef6a7a}\label{structQueue_ac2cc5c6e464ff5976f26ef71adef6a7a}} 
T {\bfseries next} () volatile
\begin{DoxyCompactList}\small\item\em Get the next element (and remove it from queue) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a55e001fe67c3cd2098508eb3844c4a4b}\label{structQueue_a55e001fe67c3cd2098508eb3844c4a4b}} 
T $\ast$ {\bfseries push} (const T \&obj) volatile
\begin{DoxyCompactList}\small\item\em Add an element to the queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_ae4f0b5429854794a322fe054ea5a8667}\label{structQueue_ae4f0b5429854794a322fe054ea5a8667}} 
bool {\bfseries is\+Empty} () const volatile
\begin{DoxyCompactList}\small\item\em Is the queue empty? \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a7ce29aaa666b9fd905df8548021f671a}\label{structQueue_a7ce29aaa666b9fd905df8548021f671a}} 
std\+::vector$<$ T $>$ {\bfseries drain} () volatile
\begin{DoxyCompactList}\small\item\em Empty the queue into a vector and return it. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a646dd47a86597b672f61b093a38a06b5}\label{structQueue_a646dd47a86597b672f61b093a38a06b5}} 
int {\bfseries get\+Size} () const volatile
\begin{DoxyCompactList}\small\item\em Get the number of elements actively in this queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_ac2cc5c6e464ff5976f26ef71adef6a7a}\label{structQueue_ac2cc5c6e464ff5976f26ef71adef6a7a}} 
T {\bfseries next} () volatile
\begin{DoxyCompactList}\small\item\em Get the next element (and remove it from queue) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a55e001fe67c3cd2098508eb3844c4a4b}\label{structQueue_a55e001fe67c3cd2098508eb3844c4a4b}} 
T $\ast$ {\bfseries push} (const T \&obj) volatile
\begin{DoxyCompactList}\small\item\em Add an element to the queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_ae4f0b5429854794a322fe054ea5a8667}\label{structQueue_ae4f0b5429854794a322fe054ea5a8667}} 
bool {\bfseries is\+Empty} () const volatile
\begin{DoxyCompactList}\small\item\em Is the queue empty? \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a7ce29aaa666b9fd905df8548021f671a}\label{structQueue_a7ce29aaa666b9fd905df8548021f671a}} 
std\+::vector$<$ T $>$ {\bfseries drain} () volatile
\begin{DoxyCompactList}\small\item\em Empty the queue into a vector and return it. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a646dd47a86597b672f61b093a38a06b5}\label{structQueue_a646dd47a86597b672f61b093a38a06b5}} 
int {\bfseries get\+Size} () const volatile
\begin{DoxyCompactList}\small\item\em Get the number of elements actively in this queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_ac2cc5c6e464ff5976f26ef71adef6a7a}\label{structQueue_ac2cc5c6e464ff5976f26ef71adef6a7a}} 
T {\bfseries next} () volatile
\begin{DoxyCompactList}\small\item\em Get the next element (and remove it from queue) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a55e001fe67c3cd2098508eb3844c4a4b}\label{structQueue_a55e001fe67c3cd2098508eb3844c4a4b}} 
T $\ast$ {\bfseries push} (const T \&obj) volatile
\begin{DoxyCompactList}\small\item\em Add an element to the queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_ae4f0b5429854794a322fe054ea5a8667}\label{structQueue_ae4f0b5429854794a322fe054ea5a8667}} 
bool {\bfseries is\+Empty} () const volatile
\begin{DoxyCompactList}\small\item\em Is the queue empty? \end{DoxyCompactList}\item 
\mbox{\Hypertarget{structQueue_a7ce29aaa666b9fd905df8548021f671a}\label{structQueue_a7ce29aaa666b9fd905df8548021f671a}} 
std\+::vector$<$ T $>$ {\bfseries drain} () volatile
\begin{DoxyCompactList}\small\item\em Empty the queue into a vector and return it. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T$>$\newline
class Queue$<$ T $>$}
This class is De\+Novo\textquotesingle{}s implementation of the standard cyclic queue with a constant maximum limit of allowed elements.~\newline
 It will not be explained in detail 

Definition at line \mbox{\hyperlink{commons_8h_source_l00843}{843}} of file \mbox{\hyperlink{commons_8h_source}{commons.\+h}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
support/commons.\+h\item 
support/commons\+\_\+old\+RNG.\+h\item 
support/commons\+\_\+omegastable.\+h\end{DoxyCompactItemize}
